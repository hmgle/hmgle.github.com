
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>用C语言改写平面刚架静力分析程序（二） - My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="续 /读入并输出杆件、结点及支承条件的数据/ void iomjs(int nm,int nj,int ns,int ist,int ien,float ar,float ri,float x,float y,int is,float vs) { int i; for(i=0;i&lt;nm;i &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hmgle.github.com/blog/2007/10/08/e794a8ce8afade8a880e694b9e58699e5b9b3e99da2e5889ae69eb6e99d99e58a9be58886e69e90e7a88be5ba8fefbc88e4ba8cefbc89">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hmgle.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">用C语言改写平面刚架静力分析程序（二）</h1>
    
    
      <p class="meta">
        








  


<time datetime="2007-10-08T22:45:00+08:00" pubdate data-updated="true">Oct 8<span>th</span>, 2007</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>续</p>

<p>/<em>读入并输出杆件、结点及支承条件的数据</em>/</p>

<p>void iomjs(int nm,int nj,int ns,int <em>ist,int </em>ien,float <em>ar,float </em>ri,float <em>x,float </em>y,int</p>

<p><em>is,float </em>vs)</p>

<p>{</p>

<p>int i;</p>

<p>for(i=0;i&lt;nm;i++)</p>

<p>    {</p>

<p>     fscanf(IDFP,&#8221;%d&#8221;,ist+i);</p>

<p>     fscanf(IDFP,&#8221;%d&#8221;,ien+i);</p>

<p>     fscanf(IDFP,&#8221;%f&#8221;,ar+i);</p>

<p>     fscanf(IDFP,&#8221;%f&#8221;,ri+i);</p>

<p>     CH=fgetc(IDFP);</p>

<p>    }</p>

<p>for(i=0;i&lt;nm;i++)</p>

<p>    {</p>

<p>     fprintf(OUTFP,&#8221;%4d&#8221;,i+1);</p>

<p>     fprintf(OUTFP,&#8221;%8d&#8221;,*(ist+i));</p>

<p>     fprintf(OUTFP,&#8221;%6d&#8221;,*(ien+i));</p>

<p>      fprintf(OUTFP,&#8221;%16.6e&#8221;,*(ar+i));</p>

<p>      fprintf(OUTFP,&#8221;%16.6e&#8221;,*(ri+i));</p>

<p>fprintf(OUTFP,&#8221;\n&#8221;);</p>

<p>    }</p>

<p>fprintf(OUTFP,&#8221;           The joint Coordinates\n&#8221;);</p>

<p>fprintf(OUTFP,&#8221;joint          X                 Y\n&#8221;);</p>

<p>for(i=0;i&lt;nj;i++)</p>

<p>    {</p>

<p>     fscanf(IDFP,&#8221;%f&#8221;,x+i);</p>

<p>     fscanf(IDFP,&#8221;%f&#8221;,y+i);</p>

<p>     CH=fgetc(IDFP);</p>

<p>    }</p>

<p>for(i=0;i&lt;nj;i++)</p>

<p>    {</p>

<p>     fprintf(OUTFP,&#8221;%5d%16.6f%16.6f\n&#8221;,i+1,<em>(x+i),</em>(y+i));</p>

<p>    }</p>

<p>fprintf(OUTFP,&#8221;           The Information of Supports\n&#8221;);</p>

<p>fprintf(OUTFP,&#8221;     IS          VS\n&#8221;);</p>

<p>for(i=0;i&lt;ns;i++)</p>

<p>    {</p>

<p>     fscanf(IDFP,&#8221;%d&#8221;,is+i);</p>

<p>     fscanf(IDFP,&#8221;%f&#8221;,vs+i);</p>

<p>     CH=fgetc(IDFP);</p>

<p>    }</p>

<p>for(i=0;i&lt;ns;i++)</p>

<p>    {</p>

<p>      fprintf(OUTFP,&#8221;%5d&#8221;,*(is+i));</p>

<p>      fprintf(OUTFP,&#8221;%15.6f\n&#8221;,*(vs+i));</p>

<p>    }</p>

<p>}</p>

<p>/<em>确定独立未知量号</em>/</p>

<p>void idun(int nj,int <em>n,int </em>iu,float <em>x,float </em>y)</p>

<p>{</p>

<p>int i,j,flag=0;</p>

<p>float dx,dy;</p>

<p>*(iu+0)=1;</p>

<p>*(iu+1)=2;</p>

<p>*(iu+2)=3;</p>

<p>*n=3;</p>

<p>for(j=1;j&lt;nj;j++)</p>

<p>    {</p>

<p>      for(i=j-1;i>=0;i&#8211;)</p>

<p>       {</p>

<p>          dx=(float)(fabs((double)(<em>(x+j)-</em>(x+i))));</p>

<p>          dy=(float)(fabs((double)(<em>(y+j)-</em>(y+i))));</p>

<p>          if(dx&lt;(1e-4)&amp;&amp;dy&lt;(1e-4))</p>

<p>           {</p>

<p>              flag=1;</p>

<p>              <em>(iu+j</em>3+0)=<em>(iu+i</em>3+0);</p>

<p>              <em>(iu+j</em>3+1)=<em>(iu+i</em>3+1);</p>

<p>              <em>(iu+j</em>3+2)=*n+1;</p>

<p>     <em>n=</em>(iu+j*3+2);</p>

<p>           }</p>

<p>    }</p>

<p>      if(flag==0)</p>

<p>       {</p>

<p>          <em>(iu+j</em>3+0)=*n+1;</p>

<p>          <em>(iu+j</em>3+1)=*n+2;</p>

<p>          <em>(iu+j</em>3+2)=*n+3;</p>

<p>          <em>n=</em>(iu+j*3+2);</p>

<p>       }</p>

<p>      flag=0;</p>

<p>    }</p>

<p>}</p>

<p>/<em>确定单元定位向量</em>/</p>

<p>void lcvct(int nm,int <em>ist,int </em>ien,int <em>lv,int </em>iu)</p>

<p>{</p>

<p>      int m,i,j;</p>

<p>      for(m=0;m&lt;nm;m++)</p>

<p>       {</p>

<p>          i=*(ist+m);</p>

<p>          j=*(ien+m);</p>

<p>          <em>(lv+m</em>6+0)=<em>(iu+(i-1)</em>3+0);</p>

<p>          <em>(lv+m</em>6+1)=<em>(iu+(i-1)</em>3+1);</p>

<p>          <em>(lv+m</em>6+2)=<em>(iu+(i-1)</em>3+2);</p>

<p>          <em>(lv+m</em>6+3)=<em>(iu+(j-1)</em>3+0);</p>

<p>          <em>(lv+m</em>6+4)=<em>(iu+(j-1)</em>3+1);</p>

<p>          <em>(lv+m</em>6+5)=<em>(iu+(j-1)</em>3+2);</p>

<p>       }</p>

<p>}</p>

<p>/<em>确定总刚的对角元地址</em>/</p>

<p>void lcdia(int nm,int n,int <em>lv,int </em>min,int <em>ibdw,int </em>ld,int <em>maxbdw,int </em>na)</p>

<p>{</p>

<p>      int i,m,minlv;</p>

<p>      for(i=0;i&lt;n;i++)</p>

<p>       {</p>

<p>          *(min+i)=i+1;</p>

<p>       }</p>

<p>      for(m=0;m&lt;nm;m++)</p>

<p>       {</p>

<p>          minlv=<em>(lv+m</em>6+0);</p>

<p>          for(i=1;i&lt;6;i++)</p>

<p>           {</p>

<p>              if(<em>(lv+m</em>6+i)&lt;minlv)</p>

<p>              minlv=<em>(lv+m</em>6+i);</p>

<p>           }</p>

<p>          for(i=0;i&lt;6;i++)</p>

<p>           {</p>

<p>              if(minlv&lt;<em>(min+</em>(lv+m*6+i)-1))</p>

<p>             <em>(min+</em>(lv+m*6+i)-1)=minlv;</p>

<p>           }</p>

<p>       }</p>

<p>      *maxbdw=0;</p>

<p>      for(i=0;i&lt;n;i++)</p>

<p>       {</p>

<p>          <em>(ibdw+i)=i-</em>(min+i)+2;</p>

<p>          if(<em>(ibdw+i)></em>maxbdw)</p>

<p>           {</p>

<p>              <em>maxbdw=</em>(ibdw+i);</p>

<p>           }</p>

<p>       }</p>

<p>      <em>ld=</em>ibdw;</p>

<p>      for(i=1;i&lt;n;i++)</p>

<p>       {</p>

<p>          <em>(ld+i)=</em>(ld+i-1)+*(ibdw+i);</p>

<p>       }</p>

<p>      <em>na=</em>(ld+n-1);</p>

<p>}</p>

<p>/<em>计算杆件的杆长、余弦和正弦</em>/</p>

<p>void lcs(int m,int <em>ist,int </em>ien,float <em>x,float </em>y,double <em>rl,double </em>c,double *s)</p>

<p>{</p>

<p>      int i,j;</p>

<p>      double x1,y1;</p>

<p>      i=*(ist+m)-1;</p>

<p>      j=*(ien+m)-1;</p>

<p>      x1=<em>(x+j)-</em>(x+i);</p>

<p>      y1=<em>(y+j)-</em>(y+i);</p>

<p>      <em>rl=sqrt(x1</em>x1+y1*y1);</p>

<p>      <em>c=x1/(</em>rl);</p>

<p>      <em>s=y1/(</em>rl);</p>

<p>}</p>

<p>/<em>计算局部坐标单刚</em>/</p>

<p>void kebar(int m,float e,int <em>ist,int </em>ien,float <em>ar,float </em>ri,float <em>x,float</em>y,double</p>

<p><em>c,double </em>s,double <em>e1,double </em>e2,double <em>e3,double </em>e4)</p>

<p>{</p>

<p>      double rl;</p>

<p>      double *prl=&rl;</p>

<p>      lcs(m,ist,ien,x,y,prl,c,s);</p>

<p>      <em>e1=e</em>(*(ar+m))/rl;</p>

<p>      <em>e2=12.0</em>e<em>(</em>(ri+m))/(rl<em>rl</em>rl);</p>

<p>      <em>e3=0.5</em>(<em>e2)</em>rl;</p>

<p>      <em>e4=4.0</em>e<em>(</em>(ri+m))/rl;</p>

<p>}</p>

<p>/<em>计算整体坐标单刚</em>/</p>

<p>void ke(int m,float e,int <em>ist,int </em>ien,float <em>ar,float </em>ri,float <em>x,float </em>y,double *ae)</p>

<p>{</p>

<p>      double c,s,e1,e2,e3,e4,a1,a2,a3,a4,a5,a6;</p>

<p>      double <em>pc=&amp;c,</em>ps=&amp;s,<em>pe1=&amp;e1,</em>pe2=&amp;e2,<em>pe3=&amp;e3,</em>pe4=&e4;</p>

<p>      kebar(m,e,ist,ien,ar,ri,x,y,pc,ps,pe1,pe2,pe3,pe4);</p>

<p>      a1=e1<em>c</em>c+e2<em>s</em>s;</p>

<p>      a2=(e1-e2)<em>c</em>s;</p>

<p>      a3=e1<em>s</em>s+e2<em>c</em>c;</p>

<p>      a4=e3*s;</p>

<p>      a5=e3*c;</p>

<p>      a6=e4;</p>

<p>      <em>(ae+0</em>6+0)=a1;</p>

<p>      <em>(ae+0</em>6+1)=a2;</p>

<p>      <em>(ae+1</em>6+1)=a3;</p>

<p>      <em>(ae+0</em>6+2)=-a4;</p>

<p>      <em>(ae+1</em>6+2)=a5;</p>

<p>      <em>(ae+2</em>6+2)=a6;</p>

<p>      <em>(ae+0</em>6+3)=-a1;</p>

<p>      <em>(ae+1</em>6+3)=-a2;</p>

<p>      <em>(ae+2</em>6+3)=a4;</p>

<p>      <em>(ae+3</em>6+3)=a1;</p>

<p>      <em>(ae+0</em>6+4)=-a2;</p>

<p>      <em>(ae+1</em>6+4)=-a3;</p>

<p>      <em>(ae+2</em>6+4)=-a5;</p>

<p>      <em>(ae+3</em>6+4)=a2;</p>

<p>      <em>(ae+4</em>6+4)=a3;</p>

<p>      <em>(ae+0</em>6+5)=-a4;</p>

<p>      <em>(ae+1</em>6+5)=a5;</p>

<p>      <em>(ae+2</em>6+5)=0.5*a6;</p>

<p>      <em>(ae+3</em>6+5)=a4;</p>

<p>      <em>(ae+4</em>6+5)=-a5;</p>

<p>      <em>(ae+5</em>6+5)=a6;</p>

<p>}</p>

<p>/<em>形成总刚</em>/</p>

<p>void forma(float e,int nm,int <em>ist,int </em>ien,float <em>ar,float </em>ri,float <em>x,float </em>y,int</p>

<p><em>lv,double </em>ae,int <em>ld,double </em>a)</p>

<p>{</p>

<p>      int m,i,j;</p>

<p>      for(m=0;m&lt;nm;m++)</p>

<p>       {</p>

<p>          ke(m,e,ist,ien,ar,ri,x,y,ae);</p>

<p>          for(i=0;i&lt;6;i++)</p>

<p>           {</p>

<p>              for(j=0;j&lt;=i;j++)</p>

<p>               {</p>

<p>                  if(<em>(lv+m</em>6+i)>=<em>(lv+m</em>6+j))</p>

<p>                   {</p>

<p>                      <em>(a+(</em>(ld+<em>(lv+m</em>6+i)-1)-1-<em>(lv+m</em>6+i)+1+<em>(lv+m</em>6+j)-1))+=<em>(ae+j</em>6+i);</p>

<p>                   }</p>

<p>                  else</p>

<p>                   {</p>

<p>                      <em>(a+(</em>(ld+<em>(lv+m</em>6+j)-1)-1-<em>(lv+m</em>6+j)+1+<em>(lv+m</em>6+i)-1))+=<em>(ae+j</em>6+i);</p>

<p>                   }</p>

<p>               }</p>

<p>           }</p>

<p>       }</p>

<p>}</p>

<p>/<em>总刚a引用支承条件</em>/</p>

<p>void as(int ns,int <em>is,int </em>iu,int <em>ld,double </em>a)</p>

<p>{</p>

<p>      int m,j,i,k;</p>

<p>      for(m=0;m&lt;ns;m++)</p>

<p>       {</p>

<p>          j=*(is+m)/10-1;</p>

<p>          i=(*(is+m))%10-1;</p>

<p>          k=<em>(iu+j</em>3+i);</p>

<p>          <em>(a+</em>(ld+k-1)-1)=1e22;</p>

<p>       }</p>

<p>}</p>

<p>/<em>解方程组之一    总刚分解</em>/</p>

<p>void ldlt(int n,int <em>ld,double </em>a,double *t)</p>

<p>{</p>

<p>      double sum;</p>

<p>      int i,i1,j,j1,ldi,ldj,k;</p>

<p>      for(i=1;i&lt;n;i++)</p>

<p>       {</p>

<p>          ldi=*(ld+i);</p>

<p>          i1=i+1-ldi+*(ld+i-1)+1;</p>

<p>          for(j=i1-1;j&lt;i;j++)</p>

<p>           {</p>

<p>              ldj=*(ld+j);</p>

<p>              j1=j+1-ldj+*(ld+j-1)+1;</p>

<p>              if(i1>j1)j1=i1;</p>

<p>              sum=0.0e0;</p>

<p>              for(k=j1-1;k&lt;j;k++)</p>

<p>               {</p>

<p>                  sum+=<em>(t+k)</em>(*(a+ldj-j+k-1));</p>

<p>               }</p>

<p>              <em>(t+j)=</em>(a+ldi-i+j-1)-sum;</p>

<p>              <em>(a+ldi-i+j-1)=</em>(t+j)/(*(a+ldj-1));</p>

<p>              <em>(a+ldi-1)-=</em>(t+j)<em>(</em>(a+ldi-i+j-1));</p>

<p>           }</p>

<p>       }</p>

<p>}</p>

<p>/<em>结点荷载列阵b置零</em>/</p>

<p>void b0(int lc,int n,int nlj,double *b)</p>

<p>{</p>

<p>      int i;</p>

<p>      fprintf(OUTFP,&#8221;                Loading Case%3d\n&#8221;,lc);</p>

<p>      fprintf(OUTFP,&#8221;           The Loadings at Joints\n&#8221;);</p>

<p>      fprintf(OUTFP,&#8221;                  NLJ=%4d\n&#8221;,nlj);</p>

<p>      for(i=0;i&lt;n;i++)</p>

<p>       {</p>

<p>          *(b+i)=0.0e0;</p>

<p>       }</p>

<p>}</p>

<p>/<em>读入并输出结点荷载，形成结点荷载列阵b</em>/</p>

<p>void ioljb(int nlj,int <em>iu,int </em>lj,float <em>fx,float </em>fy,float <em>fm,double </em>b)</p>

<p>{</p>

<p>      int m,j;</p>

<p>      fprintf(OUTFP,&#8221;joint          FX                FY                  FM\n&#8221;);</p>

<p>      for(m=0;m&lt;nlj;m++)</p>

<p>       {</p>

<p>          fscanf(IDFP,&#8221;%d&#8221;,lj+m);</p>

<p>          fscanf(IDFP,&#8221;%f&#8221;,fx+m);</p>

<p>          fscanf(IDFP,&#8221;%f&#8221;,fy+m);</p>

<p>          fscanf(IDFP,&#8221;%f&#8221;,fm+m);</p>

<p>          CH=fgetc(IDFP);</p>

<p>       }</p>

<p>      for(m=0;m&lt;nlj;m++)</p>

<p>       {</p>

<p>          fprintf(OUTFP,&#8221;%4d%16.6f%16.6f%18.6f\n&#8221;,<em>(lj+m),</em>(fx+m),<em>(fy+m),</em>(fm+m));</p>

<p>       }</p>

<p>       for(m=0;m&lt;nlj;m++)</p>

<p>        {</p>

<p>           j=*(lj+m)-1;</p>

<p>           <em>(b+</em>(iu+j<em>3+0)-1)=</em>(fx+m);</p>

<p>           <em>(b+</em>(iu+j<em>3+1)-1)=</em>(fy+m);</p>

<p>           <em>(b+</em>(iu+j<em>3+2)-1)=</em>(fm+m);</p>

<p>        }</p>

<p>}</p>

<p>/<em>杆端力f置零</em>/</p>

<p>void f0(int nlm,int nm,double *f)</p>

<p>{</p>

<p>      int i,j;</p>

<p>      fprintf(OUTFP,&#8221;           The Loadings at Members\n&#8221;);</p>

<p>      fprintf(OUTFP,&#8221;                  NLM=%4d\n&#8221;,nlm);</p>

<p>      for(j=0;j&lt;nm;j++)</p>

<p>       {</p>

<p>          for(i=0;i&lt;6;i++)</p>

<p>           {</p>

<p>              <em>(f+j</em>6+i)=0.0e0;</p>

<p>           }</p>

<p>    }  </p>

<p>}</p>

<p>/<em>读入并输出非结点荷载，计算固端力，计算等效结点荷载并叠加到结点荷载列阵b中</em>/</p>

<p>void iolmfb(int nlm,int <em>lm,int </em>lt,float <em>vf,float </em>dst,int <em>ist,int </em>ien,float *x,float</p>

<p><em>y,int </em>lv,double <em>f,double </em>b)</p>

<p>{</p>

<p>      int m,l;</p>

<p>      double d1,d2,p1,p2,f1,f2,f3,f4,f5,f6,g;</p>

<p>      double rl,c,s;</p>

<p>      double <em>prl=&amp;rl,</em>pc=&amp;c,*ps=&s;</p>

<p>      fprintf(OUTFP,&#8221;membet    type           VF                DST\n&#8221;);</p>

<p>      for(m=0;m&lt;nlm;m++)</p>

<p>       {</p>

<p>          fscanf(IDFP,&#8221;%d&#8221;,lm+m);</p>

<p>          fscanf(IDFP,&#8221;%d&#8221;,lt+m);</p>

<p>          fscanf(IDFP,&#8221;%f&#8221;,vf+m);</p>

<p>          fscanf(IDFP,&#8221;%f&#8221;,dst+m);</p>

<p>          CH=fgetc(IDFP);</p>

<p>       }</p>

<p>      for(m=0;m&lt;nlm;m++)</p>

<p>       {</p>

<p>          fprintf(OUTFP,&#8221;%4d%7d %16.6f%16.6f\n&#8221;,<em>(lm+m),</em>(lt+m),<em>(vf+m),</em>(dst+m));</p>

<p>       }</p>

<p>      for(m=0;m&lt;nlm;m++)</p>

<p>       {</p>

<p>          l=*(lm+m);</p>

<p>          lcs(l,ist,ien,x,y,prl,pc,ps);</p>

<p>          d1=*(dst+m);</p>

<p>          d2=rl-d1;</p>

<p>          if(<em>(lt+m)==1||</em>(lt+m)==3)</p>

<p>           {</p>

<p>              p1=<em>(vf+m)</em>c;</p>

<p>              p2=-(<em>(vf+m)</em>s);</p>

<p>           }</p>

<p>          if(<em>(lt+m)==2||</em>(lt+m)==4)</p>

<p>           {</p>

<p>              p1=<em>(vf+m)</em>s;</p>

<p>              p2=<em>(vf+m)</em>c;</p>

<p>           }</p>

<p>          if(<em>(lt+m)==1||</em>(lt+m)==2)</p>

<p>           {</p>

<p>              f1=-p1*d2/rl;</p>

<p>              f4=-p1-f1;</p>

<p>              f2=-p2<em>d2</em>d2<em>(rl+2.0</em>d1)/(rl<em>rl</em>rl);</p>

<p>              f5=-p2-f2;</p>

<p>              f3=-p2<em>d1</em>d2<em>d2/(rl</em>rl);</p>

<p>              f6=p2<em>d1</em>d1<em>d2/(rl</em>rl);</p>

<p>           }</p>

<p>          if(<em>(lt+m)==3||</em>(lt+m)==4)</p>

<p>           {</p>

<p>              g=p2<em>d1</em>d1/(12.0<em>rl</em>rl);</p>

<p>              f3=-g<em>((6.0</em>rl-8.0<em>d1)</em>rl+3.0<em>d1</em>d1);</p>

<p>              f6=g<em>d1</em>(4.0<em>rl-3.0</em>d1);</p>

<p>              f5=-6.0<em>g</em>d1*(2.0-d1/rl);</p>

<p>              f2=-p2*d1-f5;</p>

<p>              f4=-p1*d1-f5;</p>

<p>              f1=-p1*d1-f4;</p>

<p>           }</p>

<p>          l&#8211;;</p>

<p>          <em>(f+l</em>6+0)+=f1;</p>

<p>          <em>(f+l</em>6+1)+=f2;</p>

<p>          <em>(f+l</em>6+2)+=f3;</p>

<p>          <em>(f+l</em>6+3)+=f4;</p>

<p>          <em>(f+l</em>6+4)+=f5;</p>

<p>          <em>(f+l</em>6+5)+=f6;</p>

<p>          <em>(b+</em>(lv+l<em>6+0)-1)-=f1</em>c-f2*s;</p>

<p>          <em>(b+</em>(lv+l<em>6+1)-1)-=f1</em>s+f2*c;</p>

<p>          <em>(b+</em>(lv+l*6+2)-1)-=f3;</p>

<p>          <em>(b+</em>(lv+l<em>6+3)-1)-=f4</em>c-f5*s;</p>

<p>          <em>(b+</em>(lv+l<em>6+4)-1)-=f4</em>s+f5*c;</p>

<p>          <em>(b+</em>(lv+l*6+5)-1)-=f6;</p>

<p>       }</p>

<p>}</p>

<p>/<em>结点荷载列阵b引入支承条件</em>/</p>

<p>void bs(int ns,int <em>is,float </em>vs,int <em>iu,double </em>b)</p>

<p>{</p>

<p>      int i,j,k,m;</p>

<p>      for(m=0;m&lt;ns;m++)</p>

<p>       {</p>

<p>          j=*(is+m)/10-1;</p>

<p>          i=(*(is+m)%10)-1;</p>

<p>          k=<em>(iu+j</em>3+i)-1;</p>

<p>          <em>(b+k)=</em>(vs+m)*1e22;</p>

<p>       }</p>

<p>}</p>

<p>/<em>解方程组之二    向前和向后回代</em>/</p>

<p>void slveq(int n,int maxbdw,int <em>ld,double </em>a,double *b)</p>

<p>{</p>

<p>      int i,j,ldi,ldj,i1,imin,j1;</p>

<p>      for(i=1;i&lt;n;i++)</p>

<p>       {</p>

<p>          ldi=*(ld+i);</p>

<p>          i1=i+1-ldi+*(ld+i-1)+1;</p>

<p>          for(j=i1-1;j&lt;i;j++)</p>

<p>           {</p>

<p>              <em>(b+i)-=</em>(a+ldi-1-i+j)<em>(</em>(b+j));</p>

<p>           }</p>

<p>    }  </p>

<p>      for(i=0;i&lt;n;i++)</p>

<p>       {</p>

<p>          <em>(b+i)/=</em>(a+*(ld+i)-1);</p>

<p>       }</p>

<p>      for(i=n-2;i>=0;i&#8211;)</p>

<p>       {</p>

<p>          imin=i+1+maxbdw;</p>

<p>          if(imin>n)imin=n;</p>

<p>          for(j=i+1;j&lt;imin;j++)</p>

<p>           {</p>

<p>              ldj=*(ld+j);</p>

<p>              j1=j+1-ldj+*(ld+j-1)+1;</p>

<p>              if(i+1>=j1)</p>

<p>     {</p>

<p>      <em>(b+i)=</em>(b+i)-(<em>(a+ldj-j+i-1)</em>(*(b+j)));</p>

<p>     }</p>

<p>           }</p>

<p>       }</p>

<p>}</p>

<p>/<em>输出结点位移</em>/</p>

<p>void ojd(int nj,int <em>iu,double </em>b)</p>

<p>{</p>

<p>      int j;</p>

<p>      fprintf(OUTFP,&#8221;              The Results of Calculation\n&#8221;);</p>

<p>      fprintf(OUTFP,&#8221;           The Joint Displacements\n&#8221;);</p>

<p>      fprintf(OUTFP,&#8221;joint          u                 v              rotation\n&#8221;);</p>

<p>      for(j=0;j&lt;nj;j++)</p>

<p>       {</p>

<p>          fprintf(OUTFP,&#8221;%4d%16.6e%16.6e%16.6e\n&#8221;,j+1,<em>(b+</em>(iu+j<em>3+0)-1),</em>(b+<em>(iu+j</em>3+1)-1),*</p>

<p>(b+<em>(iu+j</em>3+2)-1));</p>

<p>       }</p>

<p>}</p>

<p>/<em>计算并输出杆端力</em>/</p>

<p>void cotf(float e,int nm,int <em>ist,int </em>ien,float <em>ar,float </em>ri,float <em>x,float </em>y,int</p>

<p><em>lv,double </em>b,double *f)</p>

<p>{</p>

<p>      int m;</p>

<p>      double c,s,e1,e2,e3,e4,u1,u2,u3,u4,u5,u6;</p>

<p>      double <em>pc=&amp;c,</em>ps=&amp;s,<em>pe1=&amp;e1,</em>pe2=&amp;e2,<em>pe3=&amp;e3,</em>pe4=&e4;</p>

<p>      fprintf(OUTFP,&#8221;           The Terminal Forces\n&#8221;);</p>

<p>      fprintf(OUTFP,&#8221;member                    FN                FS                  M\n&#8221;);</p>

<p>      for(m=0;m&lt;nm;m++)</p>

<p>       {</p>

<p>          kebar(m,e,ist,ien,ar,ri,x,y,pc,ps,pe1,pe2,pe3,pe4);</p>

<p>          u1=<em>(b+</em>(lv+m<em>6+0)-1)</em>c+<em>(b+</em>(lv+m<em>6+1)-1)</em>s;</p>

<p>          u2=-<em>(b+</em>(lv+m<em>6+0)-1)</em>s+<em>(b+</em>(lv+m<em>6+1)-1)</em>c;</p>

<p>          u3=<em>(b+</em>(lv+m*6+2)-1);</p>

<p>          u4=<em>(b+</em>(lv+m<em>6+3)-1)</em>c+<em>(b+</em>(lv+m<em>6+4)-1)</em>s;</p>

<p>          u5=-<em>(b+</em>(lv+m<em>6+3)-1)</em>s+<em>(b+</em>(lv+m<em>6+4)-1)</em>c;</p>

<p>          u6=<em>(b+</em>(lv+m*6+5)-1);</p>

<p>          <em>(f+m</em>6+0)+=e1*(u1-u4);</p>

<p>          <em>(f+m</em>6+1)+=e2<em>(u2-u5)+e3</em>(u3+u6);</p>

<p>          <em>(f+m</em>6+2)+=e3<em>(u2-u5)+e4</em>(u3+0.5*u6);</p>

<p>          <em>(f+m</em>6+3)+=e1*(u4-u1);</p>

<p>          <em>(f+m</em>6+4)+=e2<em>(u5-u2)-e3</em>(u3+u6);</p>

<p>          <em>(f+m</em>6+5)+=e3<em>(u2-u5)+e4</em>(0.5*u3+u6);</p>

<p>          fprintf(OUTFP,&#8221;%4d    start%4d%16.6f%16.6f%18.6f\n&#8221;,m+1,<em>(ist+m),</em>(f+m<em>6+0),</em></p>

<p>(f+m<em>6+1),</em>(f+m*6+2));</p>

<p>          fprintf(OUTFP,&#8221;          end%4d%16.6f%16.6f%18.6f\n&#8221;,<em>(ien+m),</em>(f+m<em>6+3),</em>(f+m<em>6+4),</em></p>

<p>(f+m*6+5));</p>

<p>       }</p>

<p>}</p>

<p>/<em>主函数 读入并输出控制数据，分配动态数组地址，并通过调用各个函数来调用整个计算</em>/</p>

<p>int main()</p>

<p>{</p>

<p>int</p>

<p>l1,l2,l3,l4,l11,l12,l21,l22,l31,l32,l41,l51,l52,l53,l54,l61,l62,l63,l64,l71,l81,l82,l83,l84;</p>

<p>int lc;</p>

<p>char idfn[13],outfn[13];</p>

<p>printf(&#8220;Input Data File Name:\n&#8221;);</p>

<p>gets(idfn);</p>

<p>if((IDFP=fopen(idfn,&#8221;r&#8221;))==NULL)</p>

<p>    {</p>

<p>     printf(&#8220;can not open Data File!\n&#8221;);</p>

<p>     exit (0);</p>

<p>    }</p>

<p>printf(&#8220;Output File Name:\n&#8221;);</p>

<p>gets(outfn);</p>

<p>if((OUTFP=fopen(outfn,&#8221;w+&#8221;))==NULL)</p>

<p>    {</p>

<p>     printf(&#8220;can not open Output File!\n&#8221;);</p>

<p>     exit (0);</p>

<p>    }</p>

<p>fprintf(OUTFP,&#8221;Input Data File Name:%s\n&#8221;,idfn);</p>

<p>fprintf(OUTFP,&#8221;Output File Name:%s\n&#8221;,outfn);</p>

<p>    {</p>

<p>     int i=0;</p>

<p>     do</p>

<p>      {</p>

<p>    CH=fgetc(IDFP);</p>

<p>    fputc(CH,OUTFP);</p>

<p>    if(CH==&#8217;\n&#8217;)i++;</p>

<p>}</p>

<p>     while(i&lt;5);</p>

<p>    }</p>

<p>fprintf(OUTFP,&#8221;\n&#8221;);</p>

<p>fprintf(OUTFP,&#8221;                  The Input Data\n&#8221;);</p>

<p>fprintf(OUTFP,&#8221;             The General Information\n&#8221;);</p>

<p>fprintf(OUTFP,&#8221;       E           NM       NJ       NS       NLC\n&#8221;);</p>

<p>fscanf(IDFP,&#8221;%f&#8221;,&amp;E);</p>

<p>fscanf(IDFP,&#8221;%d&#8221;,&amp;NM);</p>

<p>fscanf(IDFP,&#8221;%d&#8221;,&amp;NJ);</p>

<p>fscanf(IDFP,&#8221;%d&#8221;,&amp;NS);</p>

<p>fscanf(IDFP,&#8221;%d&#8221;,&amp;NLC);</p>

<p>fprintf(OUTFP,&#8221;%10.3e&#8221;,E);</p>

<p>fprintf(OUTFP,&#8221;%7d&#8221;,NM);</p>

<p>fprintf(OUTFP,&#8221;%7d&#8221;,NJ);</p>

<p>fprintf(OUTFP,&#8221;%7d&#8221;,NS);</p>

<p>fprintf(OUTFP,&#8221;%7d\n&#8221;,NLC);</p>

<p>fprintf(OUTFP,&#8221;           The Information of Members\n&#8221;);</p>

<p>fprintf(OUTFP,&#8221;member    start    end           A                 I\n&#8221;);</p>

<p>l1=0;</p>

<p>l2=l1+NM;</p>

<p>l3=0;</p>

<p>l4=l3+NM;</p>

<p>l11=l4+NM;</p>

<p>l12=l11+NJ;</p>

<p>l21=l2+NM;</p>

<p>l22=l12+NJ;</p>

<p>l31=l21+NS;</p>

<p>l32=l31+3*NJ;</p>

<p>l41=l32+6*NM;</p>

<p>iomjs(NM,NJ,NS,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l21,W2+l22);</p>

<p>idun(NJ,PN,W1+l31,W2+l11,W2+l12);</p>

<p>lcvct(NM,W1+l1,W1+l2,W1+l32,W1+l31);</p>

<p>lcdia(NM,N,W1+l32,W1+l41,W1+l41,W1+l41,PMAXBDW,PNA);</p>

<p>l51=0;</p>

<p>l52=l51+72;</p>

<p>l53=l52+NA*2;</p>

<p>l54=l53;</p>

<p>l61=l41+N;</p>

<p>forma(E,NM,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l32,W3+l51,W1+l41,W3+l52);</p>

<p>as(NS,W1+l21,W1+l31,W1+l41,W3+l52);</p>

<p>ldlt(N,W1+l41,W3+l52,W3+l53);</p>

<p>for(lc=1;lc&lt;=NLC;lc++)</p>

<p>    {</p>

<p>     fscanf(IDFP,&#8221;%d&#8221;,&amp;NLJ);</p>

<p>     CH=fgetc(IDFP);</p>

<p>     l62=l22+NS;</p>

<p>     l63=l62+NLJ;</p>

<p>     l64=l63+NLJ;</p>

<p>     l71=l54+N*2;</p>

<p>     l81=l61+NLJ;</p>

<p>     b0(lc,N,NLJ,W3+l54);</p>

<p>     if(NLJ!=0)</p>

<p>      ioljb(NLJ,W1+l31,W1+l61,W2+l62,W2+l63,W2+l64,W3+l54);</p>

<p>     fscanf(IDFP,&#8221;%d&#8221;,&amp;NLM);</p>

<p>     CH=fgetc(IDFP);</p>

<p>     l82=l81+NLM;</p>

<p>     l83=l64+NLJ;</p>

<p>     l84=l83+NLM;</p>

<p>     f0(NLM,NM,W3+l71);</p>

<p>     if(NLM!=0)</p>

<p>      iolmfb(NLM,W1+l81,W1+l82,W2+l83,W2+l84,W1+l1,W1+l2,W2+l11,W2+l12,W1+l32,W3+l71,W3+l54);</p>

<p>     bs(NS,W1+l21,W2+l22,W1+l31,W3+l54);</p>

<p>     slveq(N,MAXBDW,W1+l41,W3+l52,W3+l54);</p>

<p>     ojd(NJ,W1+l31,W3+l54);</p>

<p>     cotf(E,NM,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l32,W3+l54,W3+l71);</p>

<p>     fprintf(OUTFP,&#8221;              (NA=%4d)\n&#8221;,NA);</p>

<p>    }</p>

<p>fclose(IDFP);</p>

<p>fclose(OUTFP);</p>

<p>printf(&#8220;处理完毕\n&#8221;);</p>

<p>system(&#8220;pause&#8221;);</p>

<p>return (0);</p>

<p>}</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Your Name</span></span>

      








  


<time datetime="2007-10-08T22:45:00+08:00" pubdate data-updated="true">Oct 8<span>th</span>, 2007</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/流入/'>流入</a>, <a class='category' href='/blog/categories/逐浪/'>逐浪</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://hmgle.github.com/blog/2007/10/08/e794a8ce8afade8a880e694b9e58699e5b9b3e99da2e5889ae69eb6e99d99e58a9be58886e69e90e7a88be5ba8fefbc88e4ba8cefbc89/" data-via="" data-counturl="http://hmgle.github.com/blog/2007/10/08/e794a8ce8afade8a880e694b9e58699e5b9b3e99da2e5889ae69eb6e99d99e58a9be58886e69e90e7a88be5ba8fefbc88e4ba8cefbc89/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2007/10/08/e794a8ce8afade8a880e694b9e58699e5b9b3e99da2e5889ae69eb6e99d99e58a9be58886e69e90e7a88be5ba8fefbc88e4b880efbc89/" title="Previous Post: 用C语言改写平面刚架静力分析程序（一）">&laquo; 用C语言改写平面刚架静力分析程序（一）</a>
      
      
        <a class="basic-alignment right" href="/blog/2007/10/08/e794a8ce8afade8a880e694b9e58699e5b9b3e99da2e5889ae69eb6e99d99e58a9be58886e69e90e7a88be5ba8fefbc88e4b889efbc89/" title="Next Post: 用C语言改写平面刚架静力分析程序（三）">用C语言改写平面刚架静力分析程序（三） &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/05/01/e6898be69cbae58fb7e7a081patch/">手机号码patch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/03/17/arme5b9b3e58fb0e4b88be4bd8de59f9fe7bb93e69e84e4bd93e79a84e997aee9a298/">ARM平台下位域结构体的问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/12/e98092e5bd92e4b8ade79a84e694b9e8bf9b/">递归中的改进</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/12/26/e4b880e6aca1e99da2e8af95/">一次面试</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/12/11/e79c8be4ba86e8bf99e6a0b7e79a84makefile/">看了这样的makefile</a>
      </li>
    
  </ul>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
