<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/3.3.1" created="2012-05-26 04:08" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.1/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.1/"
>

<channel>
	<title>调和的微光 - HARMONIC GLEAM</title>
	<link>http://hmgle.com</link>
	<description></description>
	<pubDate>Sat, 26 May 2012 04:08:46 +0000</pubDate>
	<language>en</language>
	<wp:wxr_version>1.1</wp:wxr_version>
	<wp:base_site_url>http://hmgle.com</wp:base_site_url>
	<wp:base_blog_url>http://hmgle.com</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login>hmgle</wp:author_login><wp:author_email>dustgle@gmail.com</wp:author_email><wp:author_display_name><![CDATA[hmgle]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>


	<generator>http://wordpress.org/?v=3.3.1</generator>

	<item>
		<title>终于可以上网了！</title>
		<link>http://hmgle.com/archives/10</link>
		<pubDate>Sun, 02 Dec 2007 17:03:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/10</guid>
		<description></description>
		<content:encoded><![CDATA[承众多linux用户的帮助，该死的校园网用的华为认证客户端（h3c802.1xClient）总算搞定了。需要linux下的客户端的同学可以在Ubuntu的中文论坛等地方下载，或留下邮箱我发给你（们），无论静态ip还是学校动态分配的ip都可通过认证，我们学校的是静态ip的。设置好后按照附带的readme文件使用。

第一次在Ubuntu下发博客，存图留念一下 ：
<a href="http://hmgle.com/wp-content/uploads/2007/12/Screenshot.png"><img class="alignnone size-full wp-image-299" title="Screenshot" src="http://hmgle.com/wp-content/uploads/2007/12/Screenshot.png" alt="" width="1024" height="768" /></a>
<div></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[     承众多linux用户的帮助，该死的校园网用的华为认证客户端（h3c802.1xClient）总算搞定了。需要linux下的客户端的同学可以在Ubuntu的中文论坛等地方下载，或留下邮箱我发给你（们），无论静态ip还是学校动态分配的ip都可通过认证，我们学校的是静态ip的。设置好后按照附带的readme文件使用。<br/>
     第一次在Ubuntu下发博客，存图留念一下 ：
<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/273ea03dc312e70dbba167b0.jpg" small="0" class="blogimg"/></div>]]></excerpt:encoded>
		<wp:post_id>10</wp:post_id>
		<wp:post_date>2007-12-02 17:03:00</wp:post_date>
		<wp:post_date_gmt>2007-12-02 17:03:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%bb%88%e4%ba%8e%e5%8f%af%e4%bb%a5%e4%b8%8a%e7%bd%91%e4%ba%86%ef%bc%81</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ubuntu"><![CDATA[Ubuntu]]></category>
		<category domain="post_tag" nicename="%e4%b8%8a%e7%bd%91"><![CDATA[上网]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="category" nicename="%e9%80%90%e6%b5%aa"><![CDATA[逐浪]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>数理逻辑：if p then q</title>
		<link>http://hmgle.com/archives/11</link>
		<pubDate>Fri, 09 Nov 2007 20:37:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/11</guid>
		<description></description>
		<content:encoded><![CDATA[<font size="3">If A is true then B is true<br/>
1、如果[[如果我在说真话，那么我并非永远说谎]是真命题]，那么[[[我（永远/并非永远）说谎]v[我在说（真话/谎）]]是假命题]。<br/>
2、如果[[如果[[如果我说一句谎话，那么我的鼻子将长一寸]是真命题]]，那么[如果我说：“明天太阳从西边升起”后还是原来的塌鼻子]是真命题],那么[我说谎后，鼻子（会/不会）增长一寸]。<br/>
提示：1.[]表示嵌套，借用Tcl语言的;<br/>
2.p蕴含q的真假和p，q的真假关系定义如下：<br/>
p-&gt;q假当且仅当p真q假。<br/>
打开</font><a href="http://www.cut-the-knot.org/do_you_know/falsity.shtml"><font size="3">http://www.cut-the-knot.org/do_you_know/falsity.shtml</font></a><font size="3">查看更多。<br/></font><a href="http://www.cut-the-knot.org/"><font size="3">http://www.cut-the-knot.org/</font></a><font size="3">一个非常有意思的网站。</font>]]></content:encoded>
		<excerpt:encoded><![CDATA[<font size="3">If A is true then B is true<br/>
1、如果[[如果我在说真话，那么我并非永远说谎]是真命题]，那么[[[我（永远/并非永远）说谎]v[我在说（真话/谎）]]是假命题]。<br/>
2、如果[[如果[[如果我说一句谎话，那么我的鼻子将长一寸]是真命题]]，那么[如果我说：“明天太阳从西边升起”后还是原来的塌鼻子]是真命题],那么[我说谎后，鼻子（会/不会）增长一寸]。<br/>
提示：1.[]表示嵌套，借用Tcl语言的;<br/>
2.p蕴含q的真假和p，q的真假关系定义如下：<br/>
p-&gt;q假当且仅当p真q假。<br/>
打开</font><a href="http://www.cut-the-knot.org/do_you_know/falsity.shtml"><font size="3">http://www.cut-the-knot.org/do_you_know/falsity.shtml</font></a><font size="3">查看更多。<br/></font><a href="http://www.cut-the-knot.org/"><font size="3">http://www.cut-the-knot.org/</font></a><font size="3">一个非常有意思的网站。</font>]]></excerpt:encoded>
		<wp:post_id>11</wp:post_id>
		<wp:post_date>2007-11-09 20:37:00</wp:post_date>
		<wp:post_date_gmt>2007-11-09 20:37:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%95%b0%e7%90%86%e9%80%bb%e8%be%91%ef%bc%9aif-p-then-q</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e7%90%86%e9%80%bb%e8%be%91"><![CDATA[数理逻辑]]></category>
		<category domain="post_tag" nicename="%e6%9c%89%e8%b6%a3"><![CDATA[有趣]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>平面桁架机动分析程序</title>
		<link>http://hmgle.com/archives/12</link>
		<pubDate>Fri, 09 Nov 2007 20:22:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/12</guid>
		<description></description>
		<content:encoded><![CDATA[<p>     《计算结构力学——杆件结构》（钟万勰等著，高等教育出版社）一书的第三章第五节介绍了能处理大型复杂结构的机动分析算法。据此写了个简单的平面杆件机动分析程序，功能单一，不考虑界面。</p>
<p>
<pre lang="c" line="1">
/*一个简单的平面机动分析程序
 *作者：hmgle
 *时间：2007-10-25
 *版本：v1.0
 */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

void f0(float *p,int a)
{
	int i;
	for(i=0;i<a;i++)
	{
		*(p+i)=0.0;
	}
}

int main()
{
	const int NULL = 0;
	int nj,nz,nm;   //nj:非地基结点数，nz:地基结点数，nm:约束杆件数
	int ist,ien;    //ist:始端,ien:末端
	float x[100],y[100];    //结点坐标
	float e[10000]; //基底向量
	float fz[100]; //内积向量
	float c[100];   //约束向量
	float ej[100]; //e中内积最大的向量
	int nf;    //自由度
	float d1,d2;    //约束方程系数
	char fname[13];     //输入文件名称
	FILE *fp;
	char ch;
	float x3,x1,x2;
	int i,j,k;
	float max; //最大内积
	int imax; //最大内积行号
    
	printf(“请输入数据文件名称:\n”);
	gets(fname);
	if((fp=fopen(fname,”r”))==NULL)
	{
		printf(“文件打开失败，请确认文件是否存在。\n”);
		exit (0);
	}
	for(i=0;i<5; )
	{
		ch=fgetc(fp);
		if(ch==’\n’)
		{
			i++;
		}
		putchar(ch);
	}
	fscanf(fp,”%d”,&nj);
	fscanf(fp,”%d”,&nz);
	fscanf(fp,”%d”,&nm);
	ch=fgetc(fp);
	
	for(i=0;i<(nj+nz);i++)
	{
		fscanf(fp,”%f”,x+i);
		fscanf(fp,”%f”,y+i);
		ch=fgetc(fp);
	}
	f0(e,(2*nj)*(2*nj));
	for(i=0;i<(2*nj);i++)
	{
		*(e+i*(2*nj)+i)=1.0;
	}
	nf=(2*nj);
	if(nf<=0)
	{
		printf(“数据错误,请检查.\n”);
		exit (0);
	}
	for(i=0;i<nm;i++)
	{
		d1=0.0;
		d2=0.0;
		fscanf(fp,”%d”,&ist);
		fscanf(fp,”%d”,&ien);
		ch=fgetc(fp);
		if(*(x+ien-1)-*(x+ist-1)>0.3)
		{
			d1=1.0;
		}
		if(*(y+ien-1)-*(y+ist-1)>0.3)
		{
			d2=1.0;
		}
		f0(c,(2*nj));
		*(c+2*(ist-1))=d1;
		*(c+2*(ist-1)+1)=d2;
		*(c+2*(ien-1))=-d1;
		*(c+2*(ien-1)+1)=-d2;
		f0(fz,nf);
		for(j=0;j<nf;j++)
		{
			for(k=0;k<(2*nj);k++)
			{
				*(fz+j)+=(*(e+j*(2*nj)+k)*(*(c+k)));
			}
		}
	
		/*判断新约束是否有效*/
		max=*fz;
		imax=0;
		for(j=1;j<nf;j++)
		{
			if(*(fz+j)>max)
			{
				max=*(fz+j);
				imax=j;
			}
		}
		for(j=0;j<(2*nj);++j)
		{
			*(ej+j)=*(e+imax*(2*nj)+j);
		}
		if(fabs((double) (max))>1e-3)
		{
			if(nf>=1)
			{
				nf–;
			}
		}
		if((nf==0)&&(nm-i>1))
		{
			printf(“体系为超静定结构,多余联系为%d\n”,nm-i-1);
			system(“pause”);
			exit (0);
		}
		if((nf==0)&&(nm-i==1))
		{
			printf(“体系为静定结构\n”);
			system(“pause”);
			exit (0);
		}
		if((nf>0)&&(nm-i==1))
		{
			printf(“体系几何可变\n”);
			system(“pause”);
			exit (0);
		}
	
		/*构造新基地向量*/
		for(j=0;j<nf;j++)
		{
			x1=0.;
			x2=0.;
			for(k=0;k<(2*nj);k++)
			{
				x1+=*(c+k)*(*(e+j*(2*nj)+k));
				x2+=*(c+k)*(*(ej+k));
			}
			x3=x1/x2;
			for(k=0;k<(2*nj);k++)
			{
				*(e+j*(2*nj)+k)-=x3*(*(ej+k));
			}
		}
	}
	fclose(fp); 
	system(“pause”);
	return (0);
}

</pre>
<p> </p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p>     《计算结构力学——杆件结构》（钟万勰等著，高等教育出版社）一书的第三章第五节介绍了能处理大型复杂结构的机动分析算法。据此写了个简单的平面杆件机动分析程序，功能单一，不考虑界面。</p>
]]></excerpt:encoded>
		<wp:post_id>12</wp:post_id>
		<wp:post_date>2007-11-09 20:22:00</wp:post_date>
		<wp:post_date_gmt>2007-11-09 20:22:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%b9%b3%e9%9d%a2%e6%a1%81%e6%9e%b6%e6%9c%ba%e5%8a%a8%e5%88%86%e6%9e%90%e7%a8%8b%e5%ba%8f</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%a8%8b%e5%ba%8f"><![CDATA[程序]]></category>
		<category domain="post_tag" nicename="%e7%bb%93%e6%9e%84%e5%8a%9b%e5%ad%a6"><![CDATA[结构力学]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>用C语言改写平面刚架静力分析程序（三）</title>
		<link>http://hmgle.com/archives/13</link>
		<pubDate>Mon, 08 Oct 2007 22:46:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/13</guid>
		<description></description>
		<content:encoded><![CDATA[<p>续2<br/>
原来的用FORTRAN 77写的源程序：<br/>
<pre lang="fortran" line="1">
C    PF.FOR (A program for analysis of plane frame)
C    Version 4.3   1994
C    Main program reads the control data & organizes the whole
C    calculation by calling subroutines.
DIMENSION W(20000)
CHARACTER IDFN*20,TITLE(5)*72
READ (*,’(A12)’)IDFN
OPEN (3,FILE=IDFN,STATUS=’OLD’)
READ (3,’(A72)’)(TITLE(M),M=1,5)
READ (3,*)E,NM,NJ,NS,NLC
L1=1
L2=L1+NM
L3=L2+NM
L4=L3+NM
L11=L4+NM
L12=L11+NJ
L21=L12+NJ
L22=L21+NS
L31=L22+NS
L41=L31+6*NM
CALL IOMJS (TITLE,E,NM,NJ,NS,NLC,W(L1),W(L2),W(L3),
      &               W(L4),W(L11),W(L12),W(L21),W(L22))
CALL LCVCT (NM,W(L1),W(L2),W(L31),NJ,N)
CALL LCDIA (NM,N,W(L31),W(L41),W(L41),W(L41),MAXBDW,NA)
L51=L41+N
L52=L51+36
L53=L52+NA*2
L54=L53
L61=L54+N*2
NW=L61+6*NM-1
    WRITE (*,1)NA,NW
   1 FORMAT(/40X,’( NA=’,I6,’ )’
      &          /40X,’( NW=’,I6,’ )’)
CALL FORMA (E,NM,NJ,N,NA,W(L1),W(L2),W(L3),W(L4),
      &               W(L11),W(L12),W(L31),W(L51),W(L41),W(L52))
CALL AS (NS,N,NA,W(L21),W(L41),W(L52))
CALL LDLT (N,NA,W(L41),W(L52),W(L53))
DO 100 LC=1,NLC
    READ (3,*)NLJ
    L62=L61+NLJ
    L63=L62+NLJ
    L64=L63+NLJ
    L71=L61
    L81=L71+6*NM
    CALL B0 (LC,N,NLJ,W(L54))
    IF (NLJ.NE.0) CALL IOLJB (N,NLJ,W(L61),W(L62),
      &         W(L63),W(L64),W(L54))
    READ (3,*)NLM
    L82=L81+NLM
    L83=L82+NLM
    L84=L83+NLM
    CALL F0 (NLM,NM,W(L71))
    IF (NLM.NE.0) CALL IOLMFB (NM,NJ,N,NLM,W(L81),
      &         W(L82),W(L83),W(L84),W(L1),W(L2),W(L11),
      &         W(L12),W(L31),W(L71),W(L54))
    CALL BS (NS,N,W(L21),W(L22),W(L54))
    CALL SLVEQ (N,NA,MAXBDW,W(L41),W(L52),W(L54))
    CALL OJD (NJ,N,W(L54))
    CALL COTF (E,NM,NJ,N,W(L1),W(L2),W(L3),W(L4),
      &                W(L11),W(L12),W(L31),W(L54),W(L71))
    NW=L84+NLM-1
    WRITE (*,1)NA,NW
100 CONTINUE
WRITE (*,’(/)’)
END
SUBROUTINE IOMJS (TITLE,E,NM,NJ,NS,NLC,IST,IEN,
      &                     AR,RI,X,Y,IS,VS)
C    Read data of members, joints, supports & print them
DIMENSION IST(NM),IEN(NM),AR(NM),RI(NM),
      &             X(NJ),Y(NJ),IS(NS),VS(NS)
CHARACTER TITLE(5)*72
WRITE (*,’(/)’)
WRITE (*,1)(TITLE(M),M=1,5)
   1 FORMAT(1X,A72)
WRITE (*,2)E,NM,NJ,NS,NLC
   2 FORMAT(/13X,’The Input Data’
      &          //10X,’The General Information’
      &          //6X,’E',9X,’NM’,5X,’NJ’,5X,’NS’,5X,’NLC’
      &          /1X,1PE10.3,4I7)
READ   (3,*)(IST(M),IEN(M),AR(M),RI(M),M=1,NM)
WRITE (*,3)
   3 FORMAT(/10X,’The Information of Members’
      &          //1X,’member’,2X,’start’,2X,’end’,9X,’A',15X,’I')
WRITE (*,4)(M,IST(M),IEN(M),AR(M),RI(M),M=1,NM)
   4 FORMAT(1X,I4,I8,I6,1P2E16.6)
READ   (3,*)(X(M),Y(M),M=1,NJ)
WRITE (*,5)
   5 FORMAT(/10X,’The Joint Coordinates’
      &          //1X,’joint’,11X,’X',17X,’Y')
WRITE (*,6)(M,X(M),Y(M),M=1,NJ)
   6 FORMAT(1X,I4,2F18.6)
READ   (3,*)(IS(M),VS(M),M=1,NS)
WRITE (*,7)
   7 FORMAT(/10X,’The Information of Supports’
      &          //4X,’IS’,9X,’VS’)
WRITE (*,8)(IS(M),VS(M),M=1,NS)
   8 FORMAT(1X,I5,F16.6)
RETURN
END
SUBROUTINE LCVCT (NM,IST,IEN,LV,NJ,N)
C    Determine location vector of element
DIMENSION IST(NM),IEN(NM),LV(6,NM)
DO 100 M=1,NM
    I=IST(M)*3
    J=IEN(M)*3
    LV(1,M)=I-2
    LV(2,M)=I-1
    LV(3,M)=I
    LV(4,M)=J-2
    LV(5,M)=J-1
    LV(6,M)=J
100      CONTINUE
N=NJ*3
RETURN
END
SUBROUTINE LCDIA (NM,N,LV,MIN,IBDW,LD,MAXBDW,NA)
C    Determine location of diagonal elements of global stiffness
C    matrix A
DIMENSION LV(6,NM),MIN(N),IBDW(N),LD(N)
DO 100 I=1,N
    MIN(I)=I
100 CONTINUE
DO 400 M=1,NM
    MINLV=LV(1,M)
    DO 200 I=2,6
      IF (LV(I,M).LT.MINLV) MINLV=LV(I,M)
200    CONTINUE
    DO 300 I=1,6
      IF (MINLV.LT.MIN(LV(I,M))) MIN(LV(I,M))=MINLV
300    CONTINUE
400 CONTINUE
MAXBDW=0
DO 500 I=1,N
    IBDW(I)=I-MIN(I)+1
    IF (IBDW(I).GT.MAXBDW) MAXBDW=IBDW(I)
500 CONTINUE
LD(1)=IBDW(1)
DO 600 I=2,N
    LD(I)=LD(I-1)+IBDW(I)
600 CONTINUE
NA=LD(N)
RETURN
END
SUBROUTINE RLCS (M,NM,NJ,IST,IEN,X,Y,RL,C,S)
C    Calculate length, cosine & sine of member
DIMENSION IST(NM),IEN(NM),X(NJ),Y(NJ)
I=IST(M)
J=IEN(M)
         X1=X(J)-X(I)
         Y1=Y(J)-Y(I)
RL=SQRT(X1*X1+Y1*Y1)
C=X1/RL
         S=Y1/RL
RETURN
END
SUBROUTINE KEBAR (M,E,NM,NJ,IST,IEN,AR,RI,
      &                     X,Y,C,S,E1,E2,E3,E4)
C    Calculate element stiffness matrix along local axes
DIMENSION IST(NM),IEN(NM),X(NJ),Y(NJ),AR(NM),RI(NM)
CALL RLCS (M,NM,NJ,IST,IEN,X,Y,RL,C,S)
E1=E*AR(M)/RL
E2=12.0*E*RI(M)/(RL*RL*RL)
E3=0.5*E2*RL
E4=0.6666667*E3*RL
RETURN
END
SUBROUTINE KE (M,E,NM,NJ,IST,IEN,AR,RI,X,Y,AE)
C    Calculate element stiffness matrix along global axes
DIMENSION IST(NM),IEN(NM),AR(NM),RI(NM),
      &            X(NJ),Y(NJ),AE(6,6)
CALL KEBAR (M,E,NM,NJ,IST,IEN,AR,RI,X,Y,C,S,E1,E2,E3,E4)
A1=E1*C*C+E2*S*S
A2=(E1-E2)*C*S
A3=E1*S*S+E2*C*C
A4=E3*S
A5=E3*C
A6=E4
AE(1,1)=A1
AE(2,1)=A2
AE(2,2)=A3
AE(3,1)=-A4
AE(3,2)=A5
AE(3,3)=A6
AE(4,1)=-A1
AE(4,2)=-A2
AE(4,3)=A4
AE(4,4)=A1
AE(5,1)=-A2
AE(5,2)=-A3
AE(5,3)=-A5
AE(5,4)=A2
AE(5,5)=A3
AE(6,1)=-A4
AE(6,2)=A5
AE(6,3)=0.5*A6
AE(6,4)=A4
AE(6,5)=-A5
AE(6,6)=A6
RETURN
END
SUBROUTINE FORMA (E,NM,NJ,N,NA,IST,IEN,AR,RI,
      &                     X,Y,LV,AE,LD,A)
C    Form global stiffness matrix A
DIMENSION IST(NM),IEN(NM),AR(NM),RI(NM),X(NJ),Y(NJ),
      &             LV(6,NM),AE(6,6),LD(N)
DOUBLE PRECISION A(NA)
DO 300 M=1,NM
    CALL KE (M,E,NM,NJ,IST,IEN,AR,RI,X,Y,AE)
    DO 200 I=1,6
      DO 100 J=1,I
        IF (LV(I,M).GE.LV(J,M)) THEN
           A(LD(LV(I,M))-LV(I,M)+LV(J,M))
      &           =A(LD(LV(I,M))-LV(I,M)+LV(J,M))+AE(I,J)
        ELSE
           A(LD(LV(J,M))-LV(J,M)+LV(I,M))
      &           =A(LD(LV(J,M))-LV(J,M)+LV(I,M))+AE(I,J)
        END IF
100      CONTINUE
200    CONTINUE
300 CONTINUE
RETURN
END
SUBROUTINE AS (NS,N,NA,IS,LD,A)
C    Introduce support conditions into global stiffness matrix A
DIMENSION IS(NS),LD(N)
DOUBLE PRECISION A(NA)
DO 100 M=1,NS
    I=3*(IS(M)/10)-3+MOD(IS(M),10)
    A(LD(I))=1D22
100 CONTINUE
RETURN
END
SUBROUTINE LDLT (N,NA,LD,A,T)
C    Solve equations (1) – decomposition of matrix A
DIMENSION LD(N)
DOUBLE PRECISION A(NA),T(N),SUM
DO 300 I=2,N
    LDI=LD(I)
    I1=I-LDI+LD(I-1)+1
    DO 200 J=I1,I-1
      LDJ=LD(J)
      J1=J-LDJ+LD(J-1)+1
      IF(I1.GT.J1) J1=I1
      SUM=0.0D0
      DO 100 K=J1,J-1
        SUM=SUM+T(K)*A(LDJ-J+K)
100      CONTINUE
      T(J)=A(LDI-I+J)-SUM
      A(LDI-I+J)=T(J)/A(LDJ)
      A(LDI)=A(LDI)-T(J)*A(LDI-I+J)
200    CONTINUE
300 CONTINUE
RETURN
END
SUBROUTINE SLVEQ (N,NA,MAXBDW,LD,A,B)
C    Solve equations (2) – forward & back substitution
DIMENSION LD(N)
DOUBLE PRECISION A(NA),B(N)
DO 200 I=2,N
    LDI=LD(I)
    I1=I-LDI+LD(I-1)+1
    DO 100 J=I1,I-1
      B(I)=B(I)-A(LDI-I+J)*B(J)
100    CONTINUE
200 CONTINUE
DO 300 I=1,N
    B(I)=B(I)/A(LD(I))
300 CONTINUE
DO 500 I=N-1,1,-1
    IMIN=I+MAXBDW
    IF(IMIN.GT.N) IMIN=N
    DO 400 J=I+1,IMIN
      LDJ=LD(J)
      J1=J-LDJ+LD(J-1)+1
      IF(I.GE.J1) B(I)=B(I)-A(LDJ-J+I)*B(J)
400    CONTINUE
500 CONTINUE
RETURN
END
SUBROUTINE B0 (LC,N,NLJ,B)
C    Initialize joint load vector B
DOUBLE PRECISION B(N)
         WRITE (*,1)LC,NLJ
   1 FORMAT(/15X,’Loading Case’,I3
      &          //10X,’The Loadings at Joints’
      &          //17X,’NLJ=’,I4)
DO 100 I=1,N
    B(I)=0.0D0
100 CONTINUE
         RETURN
END
SUBROUTINE IOLJB (N,NLJ,ILJ,PX,PY,PM,B)
C    Read data of loading at joint & form joint load vector B
DIMENSION ILJ(NLJ),PX(NLJ),PY(NLJ),PM(NLJ)
DOUBLE PRECISION B(N)
         READ   (3,*)(ILJ(M),PX(M),PY(M),PM(M),M=1,NLJ)
WRITE (*,1)
   1      FORMAT(/2X,’ILJ’,11X,’PX’,14X,’PY’,15X,’PM’)
WRITE (*,2)(ILJ(M),PX(M),PY(M),PM(M),M=1,NLJ)
   2      FORMAT(1X,I4,2F16.4,F18.5)
DO 100 M=1,NLJ
    I=ILJ(M)*3
    B(I-2)=PX(M)
    B(I-1)=PY(M)
    B(I)=PM(M)
100 CONTINUE
RETURN 
END
SUBROUTINE F0 (NLM,NM,F)
C    Initialize terminal forces of members
DIMENSION F(6,NM)
WRITE (*,1) NLM
   1      FORMAT(/10X,’The Loadings at Members’
      &          //17X,’NLM=’,I4)
DO 200 J=1,NM
    DO 100 I=1,6
      F(I,J)=0.0
100    CONTINUE
200 CONTINUE
         RETURN
END
SUBROUTINE IOLMFB (NM,NJ,N,NLM,ILM,ITL,PV,DST,
      &                      IST,IEN,X,Y,LV,F,B)
C    Read data of loading at member & calculate fixed-end forces,
C    add equivalent joint loads to vector B
DIMENSION ILM(NLM),ITL(NLM),PV(NLM),DST(NLM),IST(NM),
      &            IEN(NM),X(NJ),Y(NJ),LV(6,NM),F(6,NM)
DOUBLE PRECISION B(N)
READ   (3,*)(ILM(M),ITL(M),PV(M),DST(M),M=1,NLM)
WRITE (*,1)
   1 FORMAT(/2X,’ILM’,2X,’ITL’,11X,’PV’,12X,’DST’)
WRITE (*,2)(ILM(M),ITL(M),PV(M),DST(M),M=1,NLM)
   2 FORMAT(1X,I4,I5,F16.4,F16.6)
DO 100 M=1,NLM
    L=ILM(M)
    CALL RLCS (L,NM,NJ,IST,IEN,X,Y,RL,C,S)
    D1=DST(M)
    D2=RL-D1
    IF (ITL(M).EQ.1.OR.ITL(M).EQ.3) THEN
      P1=PV(M)*C
      P2=-PV(M)*S
    END IF
    IF (ITL(M).EQ.2.OR.ITL(M).EQ.4) THEN
      P1=PV(M)*S
      P2=PV(M)*C
    END IF
    IF (ITL(M).EQ.1.OR.ITL(M).EQ.2) THEN
      F1=-P1*D2/RL
      F4=-P1-F1
      F2=-P2*D2*D2*(RL+2.0*D1)/(RL*RL*RL)
      F5=-P2-F2
      F3=-P2*D1*D2*D2/(RL*RL)
      F6=P2*D1*D1*D2/(RL*RL)
    END IF
    IF (ITL(M).EQ.3.OR.ITL(M).EQ.4) THEN
      G=P2*D1*D1/(12.0*RL*RL)
      F3=-G*((6.0*RL-8.0*D1)*RL+3.0*D1*D1)
      F6=G*D1*(4.0*RL-3.0*D1)
      F5=-6.0*G*D1*(2.0-D1/RL)
      F2=-P2*D1-F5
      F4=-P1*D1*D1/(2.0*RL)
      F1=-P1*D1-F4
    END IF
    F(1,L)=F(1,L)+F1
    F(2,L)=F(2,L)+F2
    F(3,L)=F(3,L)+F3
    F(4,L)=F(4,L)+F4
    F(5,L)=F(5,L)+F5
    F(6,L)=F(6,L)+F6
    B(LV(1,L))=B(LV(1,L))-F1*C+F2*S
    B(LV(2,L))=B(LV(2,L))-F1*S-F2*C
    B(LV(3,L))=B(LV(3,L))-F3
    B(LV(4,L))=B(LV(4,L))-F4*C+F5*S
    B(LV(5,L))=B(LV(5,L))-F4*S-F5*C
    B(LV(6,L))=B(LV(6,L))-F6
100 CONTINUE
RETURN
END
SUBROUTINE BS (NS,N,IS,VS,B)
C    Introduce support conditions into joint load vector B
DIMENSION IS(NS),VS(NS)
DOUBLE PRECISION B(N)
DO 100 M=1,NS
    I=3*(IS(M)/10)-3+MOD(IS(M),10)
    B(I)=VS(M)*1D22
100      CONTINUE
RETURN
END
SUBROUTINE OJD (NJ,N,B)
C    Print joint displacements
DOUBLE PRECISION B(N)
WRITE (*,1)
   1     FORMAT(/13X,’The Results of Calculation’
      &          //10X,’The Joint Displacements’
      &          //1X,’joint’,8X,’u',15X,’v',14X,’phi’)
WRITE (*,2)(M,B(3*M-2),B(3*M-1),B(3*M),M=1,NJ)
   2      FORMAT(1X,I4,1P3E16.6)
RETURN
END
SUBROUTINE COTF (E,NM,NJ,N,IST,IEN,AR,RI,X,Y,LV,B,F)
C    Calculate & print terminal forces of members
DIMENSION IST(NM),IEN(NM),AR(NM),RI(NM),X(NJ),Y(NJ),
      &             LV(6,NM),F(6,NM)
DOUBLE PRECISION B(N),U1,U2,U3,U4,U5,U6
WRITE (*,1)
   1      FORMAT(/10X,’The Terminal Forces’
      &          //1X,’member’,4X,’N(st)’,6X,’Q(st)’,7X,’M(st)’,
      &                        6X,’N(en)’,6X,’Q(en)’,7X,’M(en)’)
DO 100 M=1,NM
    CALL KEBAR (M,E,NM,NJ,IST,IEN,AR,RI,X,Y,C,S,E1,E2,E3,E4)
    U1=B(LV(1,M))*C+B(LV(2,M))*S
    U2=-B(LV(1,M))*S+B(LV(2,M))*C
    U3=B(LV(3,M))
    U4=B(LV(4,M))*C+B(LV(5,M))*S
    U5=-B(LV(4,M))*S+B(LV(5,M))*C
    U6=B(LV(6,M))
    F(1,M)=F(1,M)+E1*(U1-U4)
    F(2,M)=F(2,M)+E2*(U2-U5)+E3*(U3+U6)
    F(3,M)=F(3,M)+E3*(U2-U5)+E4*(U3+0.5*U6)
    F(4,M)=F(4,M)+E1*(U4-U1)
    F(5,M)=F(5,M)+E2*(U5-U2)-E3*(U3+U6)
    F(6,M)=F(6,M)+E3*(U2-U5)+E4*(0.5*U3+U6)
    WRITE (*,2)M,F(1,M),F(2,M),F(3,M),
      &                  F(4,M),F(5,M),F(6,M)
   2        FORMAT(1X,I4,2(2F11.3,F12.3))
100      CONTINUE
         RETURN
END
</pre>
<br/><br/>
（完）</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p>续2<br/>
原来的用FORTRAN 77写的源程序：<br/>
C    PF.FOR (A program for analysis of plane frame)<br/>
C    Version 4.3   1994<br/>
C    Main program reads the control data &amp; organizes the whole<br/>
C    calculation by calling subroutines.<br/>
 DIMENSION W(20000)<br/>
 CHARACTER IDFN*20,TITLE(5)*72<br/>
 READ (*,'(A12)')IDFN<br/>
 OPEN (3,FILE=IDFN,STATUS='OLD')<br/>
 READ (3,'(A72)')(TITLE(M),M=1,5)<br/>
 READ (3,*)E,NM,NJ,NS,NLC<br/>
 L1=1<br/>
 L2=L1+NM<br/>
 L3=L2+NM<br/>
 L4=L3+NM<br/>
 L11=L4+NM<br/>
 L12=L11+NJ<br/>
 L21=L12+NJ<br/>
 L22=L21+NS<br/>
 L31=L22+NS<br/>
 L41=L31+6*NM<br/>
 CALL IOMJS (TITLE,E,NM,NJ,NS,NLC,W(L1),W(L2),W(L3),<br/>
      &amp;               W(L4),W(L11),W(L12),W(L21),W(L22))<br/>
 CALL LCVCT (NM,W(L1),W(L2),W(L31),NJ,N)<br/>
 CALL LCDIA (NM,N,W(L31),W(L41),W(L41),W(L41),MAXBDW,NA)<br/>
 L51=L41+N<br/>
 L52=L51+36<br/>
 L53=L52+NA*2<br/>
 L54=L53<br/>
 L61=L54+N*2<br/>
 NW=L61+6*NM-1<br/>
    WRITE (*,1)NA,NW<br/>
   1 FORMAT(/40X,'( NA=',I6,' )'<br/>
      &amp;          /40X,'( NW=',I6,' )')<br/>
 CALL FORMA (E,NM,NJ,N,NA,W(L1),W(L2),W(L3),W(L4),<br/>
      &amp;               W(L11),W(L12),W(L31),W(L51),W(L41),W(L52))<br/>
 CALL AS (NS,N,NA,W(L21),W(L41),W(L52))<br/>
 CALL LDLT (N,NA,W(L41),W(L52),W(L53))<br/>
 DO 100 LC=1,NLC<br/>
    READ (3,*)NLJ<br/>
    L62=L61+NLJ<br/>
    L63=L62+NLJ<br/>
    L64=L63+NLJ<br/>
    L71=L61<br/>
    L81=L71+6*NM<br/>
    CALL B0 (LC,N,NLJ,W(L54))<br/>
    IF (NLJ.NE.0) CALL IOLJB (N,NLJ,W(L61),W(L62),<br/>
      &amp;         W(L63),W(L64),W(L54))<br/>
    READ (3,*)NLM<br/>
    L82=L81+NLM<br/>
    L83=L82+NLM<br/>
    L84=L83+NLM<br/>
    CALL F0 (NLM,NM,W(L71))<br/>
    IF (NLM.NE.0) CALL IOLMFB (NM,NJ,N,NLM,W(L81),<br/>
      &amp;         W(L82),W(L83),W(L84),W(L1),W(L2),W(L11),<br/>
      &amp;         W(L12),W(L31),W(L71),W(L54))<br/>
    CALL BS (NS,N,W(L21),W(L22),W(L54))<br/>
    CALL SLVEQ (N,NA,MAXBDW,W(L41),W(L52),W(L54))<br/>
    CALL OJD (NJ,N,W(L54))<br/>
    CALL COTF (E,NM,NJ,N,W(L1),W(L2),W(L3),W(L4),<br/>
      &amp;                W(L11),W(L12),W(L31),W(L54),W(L71))<br/>
    NW=L84+NLM-1<br/>
    WRITE (*,1)NA,NW<br/>
100 CONTINUE<br/>
 WRITE (*,'(/)')<br/>
 END<br/>
 SUBROUTINE IOMJS (TITLE,E,NM,NJ,NS,NLC,IST,IEN,<br/>
      &amp;                     AR,RI,X,Y,IS,VS)<br/>
C    Read data of members, joints, supports &amp; print them<br/>
 DIMENSION IST(NM),IEN(NM),AR(NM),RI(NM),<br/>
      &amp;             X(NJ),Y(NJ),IS(NS),VS(NS)<br/>
 CHARACTER TITLE(5)*72<br/>
 WRITE (*,'(/)')<br/>
 WRITE (*,1)(TITLE(M),M=1,5)<br/>
   1 FORMAT(1X,A72)<br/>
 WRITE (*,2)E,NM,NJ,NS,NLC<br/>
   2 FORMAT(/13X,'The Input Data'<br/>
      &amp;          //10X,'The General Information'<br/>
      &amp;          //6X,'E',9X,'NM',5X,'NJ',5X,'NS',5X,'NLC'<br/>
      &amp;          /1X,1PE10.3,4I7)<br/>
 READ   (3,*)(IST(M),IEN(M),AR(M),RI(M),M=1,NM)<br/>
 WRITE (*,3)<br/>
   3 FORMAT(/10X,'The Information of Members'<br/>
      &amp;          //1X,'member',2X,'start',2X,'end',9X,'A',15X,'I')<br/>
 WRITE (*,4)(M,IST(M),IEN(M),AR(M),RI(M),M=1,NM)<br/>
   4 FORMAT(1X,I4,I8,I6,1P2E16.6)<br/>
 READ   (3,*)(X(M),Y(M),M=1,NJ)<br/>
 WRITE (*,5)<br/>
   5 FORMAT(/10X,'The Joint Coordinates'<br/>
      &amp;          //1X,'joint',11X,'X',17X,'Y')<br/>
 WRITE (*,6)(M,X(M),Y(M),M=1,NJ)<br/>
   6 FORMAT(1X,I4,2F18.6)<br/>
 READ   (3,*)(IS(M),VS(M),M=1,NS)<br/>
 WRITE (*,7)<br/>
   7 FORMAT(/10X,'The Information of Supports'<br/>
      &amp;          //4X,'IS',9X,'VS')<br/>
 WRITE (*,8)(IS(M),VS(M),M=1,NS)<br/>
   8 FORMAT(1X,I5,F16.6)<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE LCVCT (NM,IST,IEN,LV,NJ,N)<br/>
C    Determine location vector of element<br/>
 DIMENSION IST(NM),IEN(NM),LV(6,NM)<br/>
 DO 100 M=1,NM<br/>
    I=IST(M)*3<br/>
    J=IEN(M)*3<br/>
    LV(1,M)=I-2<br/>
    LV(2,M)=I-1<br/>
    LV(3,M)=I<br/>
    LV(4,M)=J-2<br/>
    LV(5,M)=J-1<br/>
    LV(6,M)=J<br/>
100      CONTINUE<br/>
 N=NJ*3<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE LCDIA (NM,N,LV,MIN,IBDW,LD,MAXBDW,NA)<br/>
C    Determine location of diagonal elements of global stiffness<br/>
C    matrix A<br/>
 DIMENSION LV(6,NM),MIN(N),IBDW(N),LD(N)<br/>
 DO 100 I=1,N<br/>
    MIN(I)=I<br/>
100 CONTINUE<br/>
 DO 400 M=1,NM<br/>
    MINLV=LV(1,M)<br/>
    DO 200 I=2,6<br/>
      IF (LV(I,M).LT.MINLV) MINLV=LV(I,M)<br/>
200    CONTINUE<br/>
    DO 300 I=1,6<br/>
      IF (MINLV.LT.MIN(LV(I,M))) MIN(LV(I,M))=MINLV<br/>
300    CONTINUE<br/>
400 CONTINUE<br/>
 MAXBDW=0<br/>
 DO 500 I=1,N<br/>
    IBDW(I)=I-MIN(I)+1<br/>
    IF (IBDW(I).GT.MAXBDW) MAXBDW=IBDW(I)<br/>
500 CONTINUE<br/>
 LD(1)=IBDW(1)<br/>
 DO 600 I=2,N<br/>
    LD(I)=LD(I-1)+IBDW(I)<br/>
600 CONTINUE<br/>
 NA=LD(N)<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE RLCS (M,NM,NJ,IST,IEN,X,Y,RL,C,S)<br/>
C    Calculate length, cosine &amp; sine of member<br/>
 DIMENSION IST(NM),IEN(NM),X(NJ),Y(NJ)<br/>
 I=IST(M)<br/>
 J=IEN(M)<br/>
         X1=X(J)-X(I)<br/>
         Y1=Y(J)-Y(I)<br/>
 RL=SQRT(X1*X1+Y1*Y1)<br/>
 C=X1/RL<br/>
         S=Y1/RL<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE KEBAR (M,E,NM,NJ,IST,IEN,AR,RI,<br/>
      &amp;                     X,Y,C,S,E1,E2,E3,E4)<br/>
C    Calculate element stiffness matrix along local axes<br/>
 DIMENSION IST(NM),IEN(NM),X(NJ),Y(NJ),AR(NM),RI(NM)<br/>
 CALL RLCS (M,NM,NJ,IST,IEN,X,Y,RL,C,S)<br/>
 E1=E*AR(M)/RL<br/>
 E2=12.0*E*RI(M)/(RL*RL*RL)<br/>
 E3=0.5*E2*RL<br/>
 E4=0.6666667*E3*RL<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE KE (M,E,NM,NJ,IST,IEN,AR,RI,X,Y,AE)<br/>
C    Calculate element stiffness matrix along global axes<br/>
 DIMENSION IST(NM),IEN(NM),AR(NM),RI(NM),<br/>
      &amp;            X(NJ),Y(NJ),AE(6,6)<br/>
 CALL KEBAR (M,E,NM,NJ,IST,IEN,AR,RI,X,Y,C,S,E1,E2,E3,E4)<br/>
 A1=E1*C*C+E2*S*S<br/>
 A2=(E1-E2)*C*S<br/>
 A3=E1*S*S+E2*C*C<br/>
 A4=E3*S<br/>
 A5=E3*C<br/>
 A6=E4<br/>
 AE(1,1)=A1<br/>
 AE(2,1)=A2<br/>
 AE(2,2)=A3<br/>
 AE(3,1)=-A4<br/>
 AE(3,2)=A5<br/>
 AE(3,3)=A6<br/>
 AE(4,1)=-A1<br/>
 AE(4,2)=-A2<br/>
 AE(4,3)=A4<br/>
 AE(4,4)=A1<br/>
 AE(5,1)=-A2<br/>
 AE(5,2)=-A3<br/>
 AE(5,3)=-A5<br/>
 AE(5,4)=A2<br/>
 AE(5,5)=A3<br/>
 AE(6,1)=-A4<br/>
 AE(6,2)=A5<br/>
 AE(6,3)=0.5*A6<br/>
 AE(6,4)=A4<br/>
 AE(6,5)=-A5<br/>
 AE(6,6)=A6<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE FORMA (E,NM,NJ,N,NA,IST,IEN,AR,RI,<br/>
      &amp;                     X,Y,LV,AE,LD,A)<br/>
C    Form global stiffness matrix A<br/>
 DIMENSION IST(NM),IEN(NM),AR(NM),RI(NM),X(NJ),Y(NJ),<br/>
      &amp;             LV(6,NM),AE(6,6),LD(N)<br/>
 DOUBLE PRECISION A(NA)<br/>
 DO 300 M=1,NM<br/>
    CALL KE (M,E,NM,NJ,IST,IEN,AR,RI,X,Y,AE)<br/>
    DO 200 I=1,6<br/>
      DO 100 J=1,I<br/>
        IF (LV(I,M).GE.LV(J,M)) THEN<br/>
           A(LD(LV(I,M))-LV(I,M)+LV(J,M))<br/>
      &amp;           =A(LD(LV(I,M))-LV(I,M)+LV(J,M))+AE(I,J)<br/>
        ELSE<br/>
           A(LD(LV(J,M))-LV(J,M)+LV(I,M))<br/>
      &amp;           =A(LD(LV(J,M))-LV(J,M)+LV(I,M))+AE(I,J)<br/>
        END IF<br/>
100      CONTINUE<br/>
200    CONTINUE<br/>
300 CONTINUE<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE AS (NS,N,NA,IS,LD,A)<br/>
C    Introduce support conditions into global stiffness matrix A<br/>
 DIMENSION IS(NS),LD(N)<br/>
 DOUBLE PRECISION A(NA)<br/>
 DO 100 M=1,NS<br/>
    I=3*(IS(M)/10)-3+MOD(IS(M),10)<br/>
    A(LD(I))=1D22<br/>
100 CONTINUE<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE LDLT (N,NA,LD,A,T)<br/>
C    Solve equations (1) - decomposition of matrix A<br/>
 DIMENSION LD(N)<br/>
 DOUBLE PRECISION A(NA),T(N),SUM<br/>
 DO 300 I=2,N<br/>
    LDI=LD(I)<br/>
    I1=I-LDI+LD(I-1)+1<br/>
    DO 200 J=I1,I-1<br/>
      LDJ=LD(J)<br/>
      J1=J-LDJ+LD(J-1)+1<br/>
      IF(I1.GT.J1) J1=I1<br/>
      SUM=0.0D0<br/>
      DO 100 K=J1,J-1<br/>
        SUM=SUM+T(K)*A(LDJ-J+K)<br/>
100      CONTINUE<br/>
      T(J)=A(LDI-I+J)-SUM<br/>
      A(LDI-I+J)=T(J)/A(LDJ)<br/>
      A(LDI)=A(LDI)-T(J)*A(LDI-I+J)<br/>
200    CONTINUE<br/>
300 CONTINUE<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE SLVEQ (N,NA,MAXBDW,LD,A,B)<br/>
C    Solve equations (2) - forward &amp; back substitution<br/>
 DIMENSION LD(N)<br/>
 DOUBLE PRECISION A(NA),B(N)<br/>
 DO 200 I=2,N<br/>
    LDI=LD(I)<br/>
    I1=I-LDI+LD(I-1)+1<br/>
    DO 100 J=I1,I-1<br/>
      B(I)=B(I)-A(LDI-I+J)*B(J)<br/>
100    CONTINUE<br/>
200 CONTINUE<br/>
 DO 300 I=1,N<br/>
    B(I)=B(I)/A(LD(I))<br/>
300 CONTINUE<br/>
 DO 500 I=N-1,1,-1<br/>
    IMIN=I+MAXBDW<br/>
    IF(IMIN.GT.N) IMIN=N<br/>
    DO 400 J=I+1,IMIN<br/>
      LDJ=LD(J)<br/>
      J1=J-LDJ+LD(J-1)+1<br/>
      IF(I.GE.J1) B(I)=B(I)-A(LDJ-J+I)*B(J)<br/>
400    CONTINUE<br/>
500 CONTINUE<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE B0 (LC,N,NLJ,B)<br/>
C    Initialize joint load vector B<br/>
 DOUBLE PRECISION B(N)<br/>
         WRITE (*,1)LC,NLJ<br/>
   1 FORMAT(/15X,'Loading Case',I3<br/>
      &amp;          //10X,'The Loadings at Joints'<br/>
      &amp;          //17X,'NLJ=',I4)<br/>
 DO 100 I=1,N<br/>
    B(I)=0.0D0<br/>
100 CONTINUE<br/>
         RETURN<br/>
 END<br/>
 SUBROUTINE IOLJB (N,NLJ,ILJ,PX,PY,PM,B)<br/>
C    Read data of loading at joint &amp; form joint load vector B<br/>
 DIMENSION ILJ(NLJ),PX(NLJ),PY(NLJ),PM(NLJ)<br/>
 DOUBLE PRECISION B(N)<br/>
         READ   (3,*)(ILJ(M),PX(M),PY(M),PM(M),M=1,NLJ)<br/>
 WRITE (*,1)<br/>
   1      FORMAT(/2X,'ILJ',11X,'PX',14X,'PY',15X,'PM')<br/>
 WRITE (*,2)(ILJ(M),PX(M),PY(M),PM(M),M=1,NLJ)<br/>
   2      FORMAT(1X,I4,2F16.4,F18.5)<br/>
 DO 100 M=1,NLJ<br/>
    I=ILJ(M)*3<br/>
    B(I-2)=PX(M)<br/>
    B(I-1)=PY(M)<br/>
    B(I)=PM(M)<br/>
100 CONTINUE<br/>
 RETURN <br/>
 END<br/>
 SUBROUTINE F0 (NLM,NM,F)<br/>
C    Initialize terminal forces of members<br/>
 DIMENSION F(6,NM)<br/>
 WRITE (*,1) NLM<br/>
   1      FORMAT(/10X,'The Loadings at Members'<br/>
      &amp;          //17X,'NLM=',I4)<br/>
 DO 200 J=1,NM<br/>
    DO 100 I=1,6<br/>
      F(I,J)=0.0<br/>
100    CONTINUE<br/>
200 CONTINUE<br/>
         RETURN<br/>
 END<br/>
 SUBROUTINE IOLMFB (NM,NJ,N,NLM,ILM,ITL,PV,DST,<br/>
      &amp;                      IST,IEN,X,Y,LV,F,B)<br/>
C    Read data of loading at member &amp; calculate fixed-end forces,<br/>
C    add equivalent joint loads to vector B<br/>
 DIMENSION ILM(NLM),ITL(NLM),PV(NLM),DST(NLM),IST(NM),<br/>
      &amp;            IEN(NM),X(NJ),Y(NJ),LV(6,NM),F(6,NM)<br/>
 DOUBLE PRECISION B(N)<br/>
 READ   (3,*)(ILM(M),ITL(M),PV(M),DST(M),M=1,NLM)<br/>
 WRITE (*,1)<br/>
   1 FORMAT(/2X,'ILM',2X,'ITL',11X,'PV',12X,'DST')<br/>
 WRITE (*,2)(ILM(M),ITL(M),PV(M),DST(M),M=1,NLM)<br/>
   2 FORMAT(1X,I4,I5,F16.4,F16.6)<br/>
 DO 100 M=1,NLM<br/>
    L=ILM(M)<br/>
    CALL RLCS (L,NM,NJ,IST,IEN,X,Y,RL,C,S)<br/>
    D1=DST(M)<br/>
    D2=RL-D1<br/>
    IF (ITL(M).EQ.1.OR.ITL(M).EQ.3) THEN<br/>
      P1=PV(M)*C<br/>
      P2=-PV(M)*S<br/>
    END IF<br/>
    IF (ITL(M).EQ.2.OR.ITL(M).EQ.4) THEN<br/>
      P1=PV(M)*S<br/>
      P2=PV(M)*C<br/>
    END IF<br/>
    IF (ITL(M).EQ.1.OR.ITL(M).EQ.2) THEN<br/>
      F1=-P1*D2/RL<br/>
      F4=-P1-F1<br/>
      F2=-P2*D2*D2*(RL+2.0*D1)/(RL*RL*RL)<br/>
      F5=-P2-F2<br/>
      F3=-P2*D1*D2*D2/(RL*RL)<br/>
      F6=P2*D1*D1*D2/(RL*RL)<br/>
    END IF<br/>
    IF (ITL(M).EQ.3.OR.ITL(M).EQ.4) THEN<br/>
      G=P2*D1*D1/(12.0*RL*RL)<br/>
      F3=-G*((6.0*RL-8.0*D1)*RL+3.0*D1*D1)<br/>
      F6=G*D1*(4.0*RL-3.0*D1)<br/>
      F5=-6.0*G*D1*(2.0-D1/RL)<br/>
      F2=-P2*D1-F5<br/>
      F4=-P1*D1*D1/(2.0*RL)<br/>
      F1=-P1*D1-F4<br/>
    END IF<br/>
    F(1,L)=F(1,L)+F1<br/>
    F(2,L)=F(2,L)+F2<br/>
    F(3,L)=F(3,L)+F3<br/>
    F(4,L)=F(4,L)+F4<br/>
    F(5,L)=F(5,L)+F5<br/>
    F(6,L)=F(6,L)+F6<br/>
    B(LV(1,L))=B(LV(1,L))-F1*C+F2*S<br/>
    B(LV(2,L))=B(LV(2,L))-F1*S-F2*C<br/>
    B(LV(3,L))=B(LV(3,L))-F3<br/>
    B(LV(4,L))=B(LV(4,L))-F4*C+F5*S<br/>
    B(LV(5,L))=B(LV(5,L))-F4*S-F5*C<br/>
    B(LV(6,L))=B(LV(6,L))-F6<br/>
100 CONTINUE<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE BS (NS,N,IS,VS,B)<br/>
C    Introduce support conditions into joint load vector B<br/>
 DIMENSION IS(NS),VS(NS)<br/>
 DOUBLE PRECISION B(N)<br/>
 DO 100 M=1,NS<br/>
    I=3*(IS(M)/10)-3+MOD(IS(M),10)<br/>
    B(I)=VS(M)*1D22<br/>
100      CONTINUE<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE OJD (NJ,N,B)<br/>
C    Print joint displacements<br/>
 DOUBLE PRECISION B(N)<br/>
 WRITE (*,1)<br/>
   1     FORMAT(/13X,'The Results of Calculation'<br/>
      &amp;          //10X,'The Joint Displacements'<br/>
      &amp;          //1X,'joint',8X,'u',15X,'v',14X,'phi')<br/>
 WRITE (*,2)(M,B(3*M-2),B(3*M-1),B(3*M),M=1,NJ)<br/>
   2      FORMAT(1X,I4,1P3E16.6)<br/>
 RETURN<br/>
 END<br/>
 SUBROUTINE COTF (E,NM,NJ,N,IST,IEN,AR,RI,X,Y,LV,B,F)<br/>
C    Calculate &amp; print terminal forces of members<br/>
 DIMENSION IST(NM),IEN(NM),AR(NM),RI(NM),X(NJ),Y(NJ),<br/>
      &amp;             LV(6,NM),F(6,NM)<br/>
 DOUBLE PRECISION B(N),U1,U2,U3,U4,U5,U6<br/>
 WRITE (*,1)<br/>
   1      FORMAT(/10X,'The Terminal Forces'<br/>
      &amp;          //1X,'member',4X,'N(st)',6X,'Q(st)',7X,'M(st)',<br/>
      &amp;                        6X,'N(en)',6X,'Q(en)',7X,'M(en)')<br/>
 DO 100 M=1,NM<br/>
    CALL KEBAR (M,E,NM,NJ,IST,IEN,AR,RI,X,Y,C,S,E1,E2,E3,E4)<br/>
    U1=B(LV(1,M))*C+B(LV(2,M))*S<br/>
    U2=-B(LV(1,M))*S+B(LV(2,M))*C<br/>
    U3=B(LV(3,M))<br/>
    U4=B(LV(4,M))*C+B(LV(5,M))*S<br/>
    U5=-B(LV(4,M))*S+B(LV(5,M))*C<br/>
    U6=B(LV(6,M))<br/>
    F(1,M)=F(1,M)+E1*(U1-U4)<br/>
    F(2,M)=F(2,M)+E2*(U2-U5)+E3*(U3+U6)<br/>
    F(3,M)=F(3,M)+E3*(U2-U5)+E4*(U3+0.5*U6)<br/>
    F(4,M)=F(4,M)+E1*(U4-U1)<br/>
    F(5,M)=F(5,M)+E2*(U5-U2)-E3*(U3+U6)<br/>
    F(6,M)=F(6,M)+E3*(U2-U5)+E4*(0.5*U3+U6)<br/>
    WRITE (*,2)M,F(1,M),F(2,M),F(3,M),<br/>
      &amp;                  F(4,M),F(5,M),F(6,M)<br/>
   2        FORMAT(1X,I4,2(2F11.3,F12.3))<br/>
100      CONTINUE<br/>
         RETURN<br/>
 END<br/><br/>
（完）</p>]]></excerpt:encoded>
		<wp:post_id>13</wp:post_id>
		<wp:post_date>2007-10-08 22:46:00</wp:post_date>
		<wp:post_date_gmt>2007-10-08 22:46:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%94%a8c%e8%af%ad%e8%a8%80%e6%94%b9%e5%86%99%e5%b9%b3%e9%9d%a2%e5%88%9a%e6%9e%b6%e9%9d%99%e5%8a%9b%e5%88%86%e6%9e%90%e7%a8%8b%e5%ba%8f%ef%bc%88%e4%b8%89%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="fortran"><![CDATA[Fortran]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%a8%8b%e5%ba%8f"><![CDATA[程序]]></category>
		<category domain="category" nicename="%e9%80%90%e6%b5%aa"><![CDATA[逐浪]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>用C语言改写平面刚架静力分析程序（二）</title>
		<link>http://hmgle.com/archives/14</link>
		<pubDate>Mon, 08 Oct 2007 22:45:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/14</guid>
		<description></description>
		<content:encoded><![CDATA[<p>续</p>
<p>/*读入并输出杆件、结点及支承条件的数据*/<br/>
void iomjs(int nm,int nj,int ns,int *ist,int *ien,float *ar,float *ri,float *x,float *y,int </p>
<p>*is,float *vs)<br/>
{<br/>
int i;<br/>
for(i=0;i&lt;nm;i++)<br/>
    {<br/>
     fscanf(IDFP,"%d",ist+i);<br/>
     fscanf(IDFP,"%d",ien+i);<br/>
     fscanf(IDFP,"%f",ar+i);<br/>
     fscanf(IDFP,"%f",ri+i);<br/>
     CH=fgetc(IDFP);<br/>
    }<br/>
for(i=0;i&lt;nm;i++)<br/>
    {<br/>
     fprintf(OUTFP,"%4d",i+1);<br/>
     fprintf(OUTFP,"%8d",*(ist+i));<br/>
     fprintf(OUTFP,"%6d",*(ien+i));<br/>
      fprintf(OUTFP,"%16.6e",*(ar+i));<br/>
      fprintf(OUTFP,"%16.6e",*(ri+i));<br/>
fprintf(OUTFP,"\n");<br/>
    }<br/>
fprintf(OUTFP,"           The joint Coordinates\n");<br/>
fprintf(OUTFP,"joint          X                 Y\n");<br/>
for(i=0;i&lt;nj;i++)<br/>
    {<br/>
     fscanf(IDFP,"%f",x+i);<br/>
     fscanf(IDFP,"%f",y+i);<br/>
     CH=fgetc(IDFP);<br/>
    }<br/>
for(i=0;i&lt;nj;i++)<br/>
    {<br/>
     fprintf(OUTFP,"%5d%16.6f%16.6f\n",i+1,*(x+i),*(y+i));<br/>
    }<br/>
fprintf(OUTFP,"           The Information of Supports\n");<br/>
fprintf(OUTFP,"     IS          VS\n");<br/>
for(i=0;i&lt;ns;i++)<br/>
    {<br/>
     fscanf(IDFP,"%d",is+i);<br/>
     fscanf(IDFP,"%f",vs+i);<br/>
     CH=fgetc(IDFP);<br/>
    }<br/>
for(i=0;i&lt;ns;i++)<br/>
    {<br/>
      fprintf(OUTFP,"%5d",*(is+i));<br/>
      fprintf(OUTFP,"%15.6f\n",*(vs+i));<br/>
    } <br/>
}</p>
<p>/*确定独立未知量号*/<br/>
void idun(int nj,int *n,int *iu,float *x,float *y)<br/>
{<br/>
int i,j,flag=0;<br/>
float dx,dy;<br/>
*(iu+0)=1;<br/>
*(iu+1)=2;<br/>
*(iu+2)=3;<br/>
*n=3;<br/>
for(j=1;j&lt;nj;j++)<br/>
    {<br/>
      for(i=j-1;i&gt;=0;i--)<br/>
       {<br/>
          dx=(float)(fabs((double)(*(x+j)-*(x+i))));<br/>
          dy=(float)(fabs((double)(*(y+j)-*(y+i))));<br/>
          if(dx&lt;(1e-4)&amp;&amp;dy&lt;(1e-4))<br/>
           {<br/>
              flag=1;<br/>
              *(iu+j*3+0)=*(iu+i*3+0);<br/>
              *(iu+j*3+1)=*(iu+i*3+1);<br/>
              *(iu+j*3+2)=*n+1;<br/>
     *n=*(iu+j*3+2);<br/>
           }<br/>
    }<br/>
      if(flag==0)<br/>
       {<br/>
          *(iu+j*3+0)=*n+1;<br/>
          *(iu+j*3+1)=*n+2;<br/>
          *(iu+j*3+2)=*n+3;<br/>
          *n=*(iu+j*3+2);<br/>
       }<br/>
      flag=0;<br/>
    }<br/>
}<br/>
/*确定单元定位向量*/<br/>
void lcvct(int nm,int *ist,int *ien,int *lv,int *iu)<br/>
{<br/>
      int m,i,j;<br/>
      for(m=0;m&lt;nm;m++)<br/>
       {<br/>
          i=*(ist+m);<br/>
          j=*(ien+m);<br/>
          *(lv+m*6+0)=*(iu+(i-1)*3+0);<br/>
          *(lv+m*6+1)=*(iu+(i-1)*3+1);<br/>
          *(lv+m*6+2)=*(iu+(i-1)*3+2);<br/>
          *(lv+m*6+3)=*(iu+(j-1)*3+0);<br/>
          *(lv+m*6+4)=*(iu+(j-1)*3+1);<br/>
          *(lv+m*6+5)=*(iu+(j-1)*3+2);<br/>
       }<br/>
}<br/>
/*确定总刚的对角元地址*/<br/>
void lcdia(int nm,int n,int *lv,int *min,int *ibdw,int *ld,int *maxbdw,int *na)<br/>
{<br/>
      int i,m,minlv;<br/>
      for(i=0;i&lt;n;i++)<br/>
       {<br/>
          *(min+i)=i+1;<br/>
       }<br/>
      for(m=0;m&lt;nm;m++)<br/>
       {<br/>
          minlv=*(lv+m*6+0);<br/>
          for(i=1;i&lt;6;i++)<br/>
           {<br/>
              if(*(lv+m*6+i)&lt;minlv)<br/>
              minlv=*(lv+m*6+i);<br/>
           }<br/>
          for(i=0;i&lt;6;i++)<br/>
           {<br/>
              if(minlv&lt;*(min+*(lv+m*6+i)-1))<br/>
             *(min+*(lv+m*6+i)-1)=minlv;<br/>
           }<br/>
       }<br/>
      *maxbdw=0;<br/>
      for(i=0;i&lt;n;i++)<br/>
       {<br/>
          *(ibdw+i)=i-*(min+i)+2;<br/>
          if(*(ibdw+i)&gt;*maxbdw)<br/>
           {<br/>
              *maxbdw=*(ibdw+i);<br/>
           }<br/>
       }<br/>
      *ld=*ibdw;<br/>
      for(i=1;i&lt;n;i++)<br/>
       {<br/>
          *(ld+i)=*(ld+i-1)+*(ibdw+i);<br/>
       }<br/>
      *na=*(ld+n-1);<br/>
}<br/>
/*计算杆件的杆长、余弦和正弦*/<br/>
void lcs(int m,int *ist,int *ien,float *x,float *y,double *rl,double *c,double *s)<br/>
{<br/>
      int i,j;<br/>
      double x1,y1;<br/>
      i=*(ist+m)-1;<br/>
      j=*(ien+m)-1;<br/>
      x1=*(x+j)-*(x+i);<br/>
      y1=*(y+j)-*(y+i);<br/>
      *rl=sqrt(x1*x1+y1*y1);<br/>
      *c=x1/(*rl);<br/>
      *s=y1/(*rl);<br/>
}</p>
<p><br/>
/*计算局部坐标单刚*/<br/>
void kebar(int m,float e,int *ist,int *ien,float *ar,float *ri,float *x,float*y,double </p>
<p>*c,double *s,double *e1,double *e2,double *e3,double *e4)<br/>
{<br/>
      double rl;<br/>
      double *prl=&amp;rl;<br/>
      lcs(m,ist,ien,x,y,prl,c,s);<br/>
      *e1=e*(*(ar+m))/rl;<br/>
      *e2=12.0*e*(*(ri+m))/(rl*rl*rl);<br/>
      *e3=0.5*(*e2)*rl;<br/>
      *e4=4.0*e*(*(ri+m))/rl;<br/>
}<br/>
/*计算整体坐标单刚*/<br/>
void ke(int m,float e,int *ist,int *ien,float *ar,float *ri,float *x,float *y,double *ae)<br/>
{<br/>
      double c,s,e1,e2,e3,e4,a1,a2,a3,a4,a5,a6;<br/>
      double *pc=&amp;c,*ps=&amp;s,*pe1=&amp;e1,*pe2=&amp;e2,*pe3=&amp;e3,*pe4=&amp;e4;<br/>
      kebar(m,e,ist,ien,ar,ri,x,y,pc,ps,pe1,pe2,pe3,pe4);<br/>
      a1=e1*c*c+e2*s*s;<br/>
      a2=(e1-e2)*c*s;<br/>
      a3=e1*s*s+e2*c*c;<br/>
      a4=e3*s;<br/>
      a5=e3*c;<br/>
      a6=e4;<br/>
      *(ae+0*6+0)=a1;<br/>
      *(ae+0*6+1)=a2;<br/>
      *(ae+1*6+1)=a3;<br/>
      *(ae+0*6+2)=-a4;<br/>
      *(ae+1*6+2)=a5;<br/>
      *(ae+2*6+2)=a6;<br/>
      *(ae+0*6+3)=-a1;<br/>
      *(ae+1*6+3)=-a2;<br/>
      *(ae+2*6+3)=a4;<br/>
      *(ae+3*6+3)=a1;<br/>
      *(ae+0*6+4)=-a2;<br/>
      *(ae+1*6+4)=-a3;<br/>
      *(ae+2*6+4)=-a5;<br/>
      *(ae+3*6+4)=a2;<br/>
      *(ae+4*6+4)=a3;<br/>
      *(ae+0*6+5)=-a4;<br/>
      *(ae+1*6+5)=a5;<br/>
      *(ae+2*6+5)=0.5*a6;<br/>
      *(ae+3*6+5)=a4;<br/>
      *(ae+4*6+5)=-a5;<br/>
      *(ae+5*6+5)=a6;<br/>
}<br/>
/*形成总刚*/<br/>
void forma(float e,int nm,int *ist,int *ien,float *ar,float *ri,float *x,float *y,int </p>
<p>*lv,double *ae,int *ld,double *a)<br/>
{<br/>
      int m,i,j;<br/>
      for(m=0;m&lt;nm;m++)<br/>
       {<br/>
          ke(m,e,ist,ien,ar,ri,x,y,ae);<br/>
          for(i=0;i&lt;6;i++)<br/>
           {<br/>
              for(j=0;j&lt;=i;j++)<br/>
               {<br/>
                  if(*(lv+m*6+i)&gt;=*(lv+m*6+j))<br/>
                   {<br/>
                      *(a+(*(ld+*(lv+m*6+i)-1)-1-*(lv+m*6+i)+1+*(lv+m*6+j)-1))+=*(ae+j*6+i);<br/>
                   }<br/>
                  else<br/>
                   {<br/>
                      *(a+(*(ld+*(lv+m*6+j)-1)-1-*(lv+m*6+j)+1+*(lv+m*6+i)-1))+=*(ae+j*6+i);<br/>
                   }<br/>
               }<br/>
           }<br/>
       }<br/>
}<br/>
/*总刚a引用支承条件*/<br/>
void as(int ns,int *is,int *iu,int *ld,double *a)<br/>
{<br/>
      int m,j,i,k;<br/>
      for(m=0;m&lt;ns;m++)<br/>
       {<br/>
          j=*(is+m)/10-1;<br/>
          i=(*(is+m))%10-1;<br/>
          k=*(iu+j*3+i);<br/>
          *(a+*(ld+k-1)-1)=1e22;<br/>
       }<br/>
}<br/>
/*解方程组之一    总刚分解*/<br/>
void ldlt(int n,int *ld,double *a,double *t)<br/>
{<br/>
      double sum;<br/>
      int i,i1,j,j1,ldi,ldj,k;<br/>
      for(i=1;i&lt;n;i++)<br/>
       {<br/>
          ldi=*(ld+i);<br/>
          i1=i+1-ldi+*(ld+i-1)+1;<br/>
          for(j=i1-1;j&lt;i;j++)<br/>
           {<br/>
              ldj=*(ld+j);<br/>
              j1=j+1-ldj+*(ld+j-1)+1;<br/>
              if(i1&gt;j1)j1=i1;<br/>
              sum=0.0e0;<br/>
              for(k=j1-1;k&lt;j;k++)<br/>
               {<br/>
                  sum+=*(t+k)*(*(a+ldj-j+k-1));<br/>
               }<br/>
              *(t+j)=*(a+ldi-i+j-1)-sum;<br/>
              *(a+ldi-i+j-1)=*(t+j)/(*(a+ldj-1));<br/>
              *(a+ldi-1)-=*(t+j)*(*(a+ldi-i+j-1));<br/>
           }<br/>
       }<br/>
}<br/>
/*结点荷载列阵b置零*/<br/>
void b0(int lc,int n,int nlj,double *b)<br/>
{<br/>
      int i;<br/>
      fprintf(OUTFP,"                Loading Case%3d\n",lc);<br/>
      fprintf(OUTFP,"           The Loadings at Joints\n");<br/>
      fprintf(OUTFP,"                  NLJ=%4d\n",nlj);<br/>
      for(i=0;i&lt;n;i++)<br/>
       {<br/>
          *(b+i)=0.0e0;<br/>
       }<br/>
}<br/>
/*读入并输出结点荷载，形成结点荷载列阵b*/<br/>
void ioljb(int nlj,int *iu,int *lj,float *fx,float *fy,float *fm,double *b)<br/>
{<br/>
      int m,j;<br/>
      fprintf(OUTFP,"joint          FX                FY                  FM\n");<br/>
      for(m=0;m&lt;nlj;m++)<br/>
       {<br/>
          fscanf(IDFP,"%d",lj+m);<br/>
          fscanf(IDFP,"%f",fx+m);<br/>
          fscanf(IDFP,"%f",fy+m);<br/>
          fscanf(IDFP,"%f",fm+m);<br/>
          CH=fgetc(IDFP);<br/>
       }<br/>
      for(m=0;m&lt;nlj;m++)<br/>
       {<br/>
          fprintf(OUTFP,"%4d%16.6f%16.6f%18.6f\n",*(lj+m),*(fx+m),*(fy+m),*(fm+m));<br/>
       }<br/>
       for(m=0;m&lt;nlj;m++)<br/>
        {<br/>
           j=*(lj+m)-1;<br/>
           *(b+*(iu+j*3+0)-1)=*(fx+m);<br/>
           *(b+*(iu+j*3+1)-1)=*(fy+m);<br/>
           *(b+*(iu+j*3+2)-1)=*(fm+m);<br/>
        }<br/>
}<br/>
/*杆端力f置零*/<br/>
void f0(int nlm,int nm,double *f)<br/>
{<br/>
      int i,j;<br/>
      fprintf(OUTFP,"           The Loadings at Members\n");<br/>
      fprintf(OUTFP,"                  NLM=%4d\n",nlm);<br/>
      for(j=0;j&lt;nm;j++)<br/>
       {<br/>
          for(i=0;i&lt;6;i++)<br/>
           {<br/>
              *(f+j*6+i)=0.0e0;<br/>
           }<br/>
    }  <br/>
}<br/>
/*读入并输出非结点荷载，计算固端力，计算等效结点荷载并叠加到结点荷载列阵b中*/<br/>
void iolmfb(int nlm,int *lm,int *lt,float *vf,float *dst,int *ist,int *ien,float *x,float </p>
<p>*y,int *lv,double *f,double *b)<br/>
{<br/>
      int m,l;<br/>
      double d1,d2,p1,p2,f1,f2,f3,f4,f5,f6,g;<br/>
      double rl,c,s;<br/>
      double *prl=&amp;rl,*pc=&amp;c,*ps=&amp;s;<br/>
      fprintf(OUTFP,"membet    type           VF                DST\n");<br/>
      for(m=0;m&lt;nlm;m++)<br/>
       {<br/>
          fscanf(IDFP,"%d",lm+m);<br/>
          fscanf(IDFP,"%d",lt+m);<br/>
          fscanf(IDFP,"%f",vf+m);<br/>
          fscanf(IDFP,"%f",dst+m);<br/>
          CH=fgetc(IDFP);<br/>
       }<br/>
      for(m=0;m&lt;nlm;m++)<br/>
       {<br/>
          fprintf(OUTFP,"%4d%7d %16.6f%16.6f\n",*(lm+m),*(lt+m),*(vf+m),*(dst+m));<br/>
       }<br/>
      for(m=0;m&lt;nlm;m++)<br/>
       {<br/>
          l=*(lm+m);<br/>
          lcs(l,ist,ien,x,y,prl,pc,ps);<br/>
          d1=*(dst+m);<br/>
          d2=rl-d1;<br/>
          if(*(lt+m)==1||*(lt+m)==3)<br/>
           {<br/>
              p1=*(vf+m)*c;<br/>
              p2=-(*(vf+m)*s);<br/>
           }<br/>
          if(*(lt+m)==2||*(lt+m)==4)<br/>
           {<br/>
              p1=*(vf+m)*s;<br/>
              p2=*(vf+m)*c;<br/>
           }<br/>
          if(*(lt+m)==1||*(lt+m)==2)<br/>
           {<br/>
              f1=-p1*d2/rl;<br/>
              f4=-p1-f1;<br/>
              f2=-p2*d2*d2*(rl+2.0*d1)/(rl*rl*rl);<br/>
              f5=-p2-f2;<br/>
              f3=-p2*d1*d2*d2/(rl*rl);<br/>
              f6=p2*d1*d1*d2/(rl*rl);<br/>
           }<br/>
          if(*(lt+m)==3||*(lt+m)==4)<br/>
           {<br/>
              g=p2*d1*d1/(12.0*rl*rl);<br/>
              f3=-g*((6.0*rl-8.0*d1)*rl+3.0*d1*d1);<br/>
              f6=g*d1*(4.0*rl-3.0*d1);<br/>
              f5=-6.0*g*d1*(2.0-d1/rl);<br/>
              f2=-p2*d1-f5;<br/>
              f4=-p1*d1-f5;<br/>
              f1=-p1*d1-f4;<br/>
           }<br/>
          l--;<br/>
          *(f+l*6+0)+=f1;<br/>
          *(f+l*6+1)+=f2;<br/>
          *(f+l*6+2)+=f3;<br/>
          *(f+l*6+3)+=f4;<br/>
          *(f+l*6+4)+=f5;<br/>
          *(f+l*6+5)+=f6;<br/>
          *(b+*(lv+l*6+0)-1)-=f1*c-f2*s;<br/>
          *(b+*(lv+l*6+1)-1)-=f1*s+f2*c;<br/>
          *(b+*(lv+l*6+2)-1)-=f3;<br/>
          *(b+*(lv+l*6+3)-1)-=f4*c-f5*s;<br/>
          *(b+*(lv+l*6+4)-1)-=f4*s+f5*c;<br/>
          *(b+*(lv+l*6+5)-1)-=f6;<br/>
       }<br/>
}<br/>
/*结点荷载列阵b引入支承条件*/<br/>
void bs(int ns,int *is,float *vs,int *iu,double *b)<br/>
{<br/>
      int i,j,k,m;<br/>
      for(m=0;m&lt;ns;m++)<br/>
       {<br/>
          j=*(is+m)/10-1;<br/>
          i=(*(is+m)%10)-1;<br/>
          k=*(iu+j*3+i)-1;<br/>
          *(b+k)=*(vs+m)*1e22;<br/>
       }<br/>
}<br/>
/*解方程组之二    向前和向后回代*/<br/>
void slveq(int n,int maxbdw,int *ld,double *a,double *b)<br/>
{<br/>
      int i,j,ldi,ldj,i1,imin,j1;<br/>
      for(i=1;i&lt;n;i++)<br/>
       {<br/>
          ldi=*(ld+i);<br/>
          i1=i+1-ldi+*(ld+i-1)+1;<br/>
          for(j=i1-1;j&lt;i;j++)<br/>
           {<br/>
              *(b+i)-=*(a+ldi-1-i+j)*(*(b+j));<br/>
           }<br/>
    }  <br/>
      for(i=0;i&lt;n;i++)<br/>
       {<br/>
          *(b+i)/=*(a+*(ld+i)-1);<br/>
       }<br/>
      for(i=n-2;i&gt;=0;i--)<br/>
       {<br/>
          imin=i+1+maxbdw;<br/>
          if(imin&gt;n)imin=n;<br/>
          for(j=i+1;j&lt;imin;j++)<br/>
           {<br/>
              ldj=*(ld+j);<br/>
              j1=j+1-ldj+*(ld+j-1)+1;<br/>
              if(i+1&gt;=j1)<br/>
     {<br/>
      *(b+i)=*(b+i)-(*(a+ldj-j+i-1)*(*(b+j)));<br/>
     }<br/>
           }<br/>
       }<br/>
}<br/>
/*输出结点位移*/<br/>
void ojd(int nj,int *iu,double *b)<br/>
{<br/>
      int j;<br/>
      fprintf(OUTFP,"              The Results of Calculation\n");<br/>
      fprintf(OUTFP,"           The Joint Displacements\n");<br/>
      fprintf(OUTFP,"joint          u                 v              rotation\n");<br/>
      for(j=0;j&lt;nj;j++)<br/>
       {<br/>
          fprintf(OUTFP,"%4d%16.6e%16.6e%16.6e\n",j+1,*(b+*(iu+j*3+0)-1),*(b+*(iu+j*3+1)-1),*</p>
<p>(b+*(iu+j*3+2)-1));<br/>
       }<br/>
}<br/>
/*计算并输出杆端力*/<br/>
void cotf(float e,int nm,int *ist,int *ien,float *ar,float *ri,float *x,float *y,int </p>
<p>*lv,double *b,double *f)<br/>
{<br/>
      int m;<br/>
      double c,s,e1,e2,e3,e4,u1,u2,u3,u4,u5,u6;<br/>
      double *pc=&amp;c,*ps=&amp;s,*pe1=&amp;e1,*pe2=&amp;e2,*pe3=&amp;e3,*pe4=&amp;e4;<br/>
      fprintf(OUTFP,"           The Terminal Forces\n");<br/>
      fprintf(OUTFP,"member                    FN                FS                  M\n");<br/>
      for(m=0;m&lt;nm;m++)<br/>
       {<br/>
          kebar(m,e,ist,ien,ar,ri,x,y,pc,ps,pe1,pe2,pe3,pe4);<br/>
          u1=*(b+*(lv+m*6+0)-1)*c+*(b+*(lv+m*6+1)-1)*s;<br/>
          u2=-*(b+*(lv+m*6+0)-1)*s+*(b+*(lv+m*6+1)-1)*c;<br/>
          u3=*(b+*(lv+m*6+2)-1);<br/>
          u4=*(b+*(lv+m*6+3)-1)*c+*(b+*(lv+m*6+4)-1)*s;<br/>
          u5=-*(b+*(lv+m*6+3)-1)*s+*(b+*(lv+m*6+4)-1)*c;<br/>
          u6=*(b+*(lv+m*6+5)-1);<br/>
          *(f+m*6+0)+=e1*(u1-u4);<br/>
          *(f+m*6+1)+=e2*(u2-u5)+e3*(u3+u6);<br/>
          *(f+m*6+2)+=e3*(u2-u5)+e4*(u3+0.5*u6);<br/>
          *(f+m*6+3)+=e1*(u4-u1);<br/>
          *(f+m*6+4)+=e2*(u5-u2)-e3*(u3+u6);<br/>
          *(f+m*6+5)+=e3*(u2-u5)+e4*(0.5*u3+u6);<br/>
          fprintf(OUTFP,"%4d    start%4d%16.6f%16.6f%18.6f\n",m+1,*(ist+m),*(f+m*6+0),*</p>
<p>(f+m*6+1),*(f+m*6+2));<br/>
          fprintf(OUTFP,"          end%4d%16.6f%16.6f%18.6f\n",*(ien+m),*(f+m*6+3),*(f+m*6+4),*</p>
<p>(f+m*6+5));<br/>
       }<br/>
}</p>
<p>/*主函数 读入并输出控制数据，分配动态数组地址，并通过调用各个函数来调用整个计算*/<br/>
int main()<br/>
{<br/>
int </p>
<p>l1,l2,l3,l4,l11,l12,l21,l22,l31,l32,l41,l51,l52,l53,l54,l61,l62,l63,l64,l71,l81,l82,l83,l84;<br/>
int lc;<br/>
char idfn[13],outfn[13];<br/><br/>
printf("Input Data File Name:\n");<br/>
gets(idfn);<br/>
if((IDFP=fopen(idfn,"r"))==NULL)<br/>
    {<br/>
     printf("can not open Data File!\n");<br/>
     exit (0);<br/>
    }<br/>
printf("Output File Name:\n");<br/>
gets(outfn);<br/>
if((OUTFP=fopen(outfn,"w+"))==NULL)<br/>
    {<br/>
     printf("can not open Output File!\n");<br/>
     exit (0);<br/>
    }<br/>
fprintf(OUTFP,"Input Data File Name:%s\n",idfn);<br/>
fprintf(OUTFP,"Output File Name:%s\n",outfn);<br/>
    {<br/>
     int i=0;<br/>
     do<br/>
      {<br/>
    CH=fgetc(IDFP);<br/>
    fputc(CH,OUTFP);<br/>
    if(CH=='\n')i++;<br/>
}<br/>
     while(i&lt;5);<br/>
    }<br/>
fprintf(OUTFP,"\n");<br/>
fprintf(OUTFP,"                  The Input Data\n");<br/>
fprintf(OUTFP,"             The General Information\n");<br/>
fprintf(OUTFP,"       E           NM       NJ       NS       NLC\n");<br/>
fscanf(IDFP,"%f",&amp;E);<br/>
fscanf(IDFP,"%d",&amp;NM);<br/>
fscanf(IDFP,"%d",&amp;NJ);<br/>
fscanf(IDFP,"%d",&amp;NS);<br/>
fscanf(IDFP,"%d",&amp;NLC);<br/>
fprintf(OUTFP,"%10.3e",E);<br/>
fprintf(OUTFP,"%7d",NM);<br/>
fprintf(OUTFP,"%7d",NJ);<br/>
fprintf(OUTFP,"%7d",NS);<br/>
fprintf(OUTFP,"%7d\n",NLC);<br/>
fprintf(OUTFP,"           The Information of Members\n");<br/>
fprintf(OUTFP,"member    start    end           A                 I\n");<br/>
l1=0;<br/>
l2=l1+NM;<br/>
l3=0;<br/>
l4=l3+NM;<br/>
l11=l4+NM;<br/>
l12=l11+NJ;<br/>
l21=l2+NM;<br/>
l22=l12+NJ;<br/>
l31=l21+NS;<br/>
l32=l31+3*NJ;<br/>
l41=l32+6*NM;<br/>
iomjs(NM,NJ,NS,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l21,W2+l22);<br/>
idun(NJ,PN,W1+l31,W2+l11,W2+l12);<br/>
lcvct(NM,W1+l1,W1+l2,W1+l32,W1+l31);<br/>
lcdia(NM,N,W1+l32,W1+l41,W1+l41,W1+l41,PMAXBDW,PNA);<br/>
l51=0;<br/>
l52=l51+72;<br/>
l53=l52+NA*2;<br/>
l54=l53;<br/>
l61=l41+N;<br/>
forma(E,NM,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l32,W3+l51,W1+l41,W3+l52);<br/>
as(NS,W1+l21,W1+l31,W1+l41,W3+l52);<br/>
ldlt(N,W1+l41,W3+l52,W3+l53);<br/>
for(lc=1;lc&lt;=NLC;lc++)<br/>
    {<br/>
     fscanf(IDFP,"%d",&amp;NLJ);<br/>
     CH=fgetc(IDFP);<br/>
     l62=l22+NS;<br/>
     l63=l62+NLJ;<br/>
     l64=l63+NLJ;<br/>
     l71=l54+N*2;<br/>
     l81=l61+NLJ;<br/>
     b0(lc,N,NLJ,W3+l54);<br/>
     if(NLJ!=0)<br/>
      ioljb(NLJ,W1+l31,W1+l61,W2+l62,W2+l63,W2+l64,W3+l54);<br/>
     fscanf(IDFP,"%d",&amp;NLM);<br/>
     CH=fgetc(IDFP);<br/>
     l82=l81+NLM;<br/>
     l83=l64+NLJ;<br/>
     l84=l83+NLM;<br/>
     f0(NLM,NM,W3+l71);<br/>
     if(NLM!=0)<br/>
      iolmfb(NLM,W1+l81,W1+l82,W2+l83,W2+l84,W1+l1,W1+l2,W2+l11,W2+l12,W1+l32,W3+l71,W3+l54);<br/>
     bs(NS,W1+l21,W2+l22,W1+l31,W3+l54);<br/>
     slveq(N,MAXBDW,W1+l41,W3+l52,W3+l54);<br/>
     ojd(NJ,W1+l31,W3+l54);<br/>
     cotf(E,NM,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l32,W3+l54,W3+l71);<br/>
     fprintf(OUTFP,"              (NA=%4d)\n",NA);<br/>
    }<br/>
fclose(IDFP);<br/>
fclose(OUTFP);<br/>
printf("处理完毕\n");<br/>
system("pause");<br/>
return (0);<br/>
}</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p>续</p>
<p>/*读入并输出杆件、结点及支承条件的数据*/<br/>
void iomjs(int nm,int nj,int ns,int *ist,int *ien,float *ar,float *ri,float *x,float *y,int </p>
<p>*is,float *vs)<br/>
{<br/>
int i;<br/>
for(i=0;i&lt;nm;i++)<br/>
    {<br/>
     fscanf(IDFP,"%d",ist+i);<br/>
     fscanf(IDFP,"%d",ien+i);<br/>
     fscanf(IDFP,"%f",ar+i);<br/>
     fscanf(IDFP,"%f",ri+i);<br/>
     CH=fgetc(IDFP);<br/>
    }<br/>
for(i=0;i&lt;nm;i++)<br/>
    {<br/>
     fprintf(OUTFP,"%4d",i+1);<br/>
     fprintf(OUTFP,"%8d",*(ist+i));<br/>
     fprintf(OUTFP,"%6d",*(ien+i));<br/>
      fprintf(OUTFP,"%16.6e",*(ar+i));<br/>
      fprintf(OUTFP,"%16.6e",*(ri+i));<br/>
fprintf(OUTFP,"\n");<br/>
    }<br/>
fprintf(OUTFP,"           The joint Coordinates\n");<br/>
fprintf(OUTFP,"joint          X                 Y\n");<br/>
for(i=0;i&lt;nj;i++)<br/>
    {<br/>
     fscanf(IDFP,"%f",x+i);<br/>
     fscanf(IDFP,"%f",y+i);<br/>
     CH=fgetc(IDFP);<br/>
    }<br/>
for(i=0;i&lt;nj;i++)<br/>
    {<br/>
     fprintf(OUTFP,"%5d%16.6f%16.6f\n",i+1,*(x+i),*(y+i));<br/>
    }<br/>
fprintf(OUTFP,"           The Information of Supports\n");<br/>
fprintf(OUTFP,"     IS          VS\n");<br/>
for(i=0;i&lt;ns;i++)<br/>
    {<br/>
     fscanf(IDFP,"%d",is+i);<br/>
     fscanf(IDFP,"%f",vs+i);<br/>
     CH=fgetc(IDFP);<br/>
    }<br/>
for(i=0;i&lt;ns;i++)<br/>
    {<br/>
      fprintf(OUTFP,"%5d",*(is+i));<br/>
      fprintf(OUTFP,"%15.6f\n",*(vs+i));<br/>
    } <br/>
}</p>
<p>/*确定独立未知量号*/<br/>
void idun(int nj,int *n,int *iu,float *x,float *y)<br/>
{<br/>
int i,j,flag=0;<br/>
float dx,dy;<br/>
*(iu+0)=1;<br/>
*(iu+1)=2;<br/>
*(iu+2)=3;<br/>
*n=3;<br/>
for(j=1;j&lt;nj;j++)<br/>
    {<br/>
      for(i=j-1;i&gt;=0;i--)<br/>
       {<br/>
          dx=(float)(fabs((double)(*(x+j)-*(x+i))));<br/>
          dy=(float)(fabs((double)(*(y+j)-*(y+i))));<br/>
          if(dx&lt;(1e-4)&amp;&amp;dy&lt;(1e-4))<br/>
           {<br/>
              flag=1;<br/>
              *(iu+j*3+0)=*(iu+i*3+0);<br/>
              *(iu+j*3+1)=*(iu+i*3+1);<br/>
              *(iu+j*3+2)=*n+1;<br/>
     *n=*(iu+j*3+2);<br/>
           }<br/>
    }<br/>
      if(flag==0)<br/>
       {<br/>
          *(iu+j*3+0)=*n+1;<br/>
          *(iu+j*3+1)=*n+2;<br/>
          *(iu+j*3+2)=*n+3;<br/>
          *n=*(iu+j*3+2);<br/>
       }<br/>
      flag=0;<br/>
    }<br/>
}<br/>
/*确定单元定位向量*/<br/>
void lcvct(int nm,int *ist,int *ien,int *lv,int *iu)<br/>
{<br/>
      int m,i,j;<br/>
      for(m=0;m&lt;nm;m++)<br/>
       {<br/>
          i=*(ist+m);<br/>
          j=*(ien+m);<br/>
          *(lv+m*6+0)=*(iu+(i-1)*3+0);<br/>
          *(lv+m*6+1)=*(iu+(i-1)*3+1);<br/>
          *(lv+m*6+2)=*(iu+(i-1)*3+2);<br/>
          *(lv+m*6+3)=*(iu+(j-1)*3+0);<br/>
          *(lv+m*6+4)=*(iu+(j-1)*3+1);<br/>
          *(lv+m*6+5)=*(iu+(j-1)*3+2);<br/>
       }<br/>
}<br/>
/*确定总刚的对角元地址*/<br/>
void lcdia(int nm,int n,int *lv,int *min,int *ibdw,int *ld,int *maxbdw,int *na)<br/>
{<br/>
      int i,m,minlv;<br/>
      for(i=0;i&lt;n;i++)<br/>
       {<br/>
          *(min+i)=i+1;<br/>
       }<br/>
      for(m=0;m&lt;nm;m++)<br/>
       {<br/>
          minlv=*(lv+m*6+0);<br/>
          for(i=1;i&lt;6;i++)<br/>
           {<br/>
              if(*(lv+m*6+i)&lt;minlv)<br/>
              minlv=*(lv+m*6+i);<br/>
           }<br/>
          for(i=0;i&lt;6;i++)<br/>
           {<br/>
              if(minlv&lt;*(min+*(lv+m*6+i)-1))<br/>
             *(min+*(lv+m*6+i)-1)=minlv;<br/>
           }<br/>
       }<br/>
      *maxbdw=0;<br/>
      for(i=0;i&lt;n;i++)<br/>
       {<br/>
          *(ibdw+i)=i-*(min+i)+2;<br/>
          if(*(ibdw+i)&gt;*maxbdw)<br/>
           {<br/>
              *maxbdw=*(ibdw+i);<br/>
           }<br/>
       }<br/>
      *ld=*ibdw;<br/>
      for(i=1;i&lt;n;i++)<br/>
       {<br/>
          *(ld+i)=*(ld+i-1)+*(ibdw+i);<br/>
       }<br/>
      *na=*(ld+n-1);<br/>
}<br/>
/*计算杆件的杆长、余弦和正弦*/<br/>
void lcs(int m,int *ist,int *ien,float *x,float *y,double *rl,double *c,double *s)<br/>
{<br/>
      int i,j;<br/>
      double x1,y1;<br/>
      i=*(ist+m)-1;<br/>
      j=*(ien+m)-1;<br/>
      x1=*(x+j)-*(x+i);<br/>
      y1=*(y+j)-*(y+i);<br/>
      *rl=sqrt(x1*x1+y1*y1);<br/>
      *c=x1/(*rl);<br/>
      *s=y1/(*rl);<br/>
}</p>
<p><br/>
/*计算局部坐标单刚*/<br/>
void kebar(int m,float e,int *ist,int *ien,float *ar,float *ri,float *x,float*y,double </p>
<p>*c,double *s,double *e1,double *e2,double *e3,double *e4)<br/>
{<br/>
      double rl;<br/>
      double *prl=&amp;rl;<br/>
      lcs(m,ist,ien,x,y,prl,c,s);<br/>
      *e1=e*(*(ar+m))/rl;<br/>
      *e2=12.0*e*(*(ri+m))/(rl*rl*rl);<br/>
      *e3=0.5*(*e2)*rl;<br/>
      *e4=4.0*e*(*(ri+m))/rl;<br/>
}<br/>
/*计算整体坐标单刚*/<br/>
void ke(int m,float e,int *ist,int *ien,float *ar,float *ri,float *x,float *y,double *ae)<br/>
{<br/>
      double c,s,e1,e2,e3,e4,a1,a2,a3,a4,a5,a6;<br/>
      double *pc=&amp;c,*ps=&amp;s,*pe1=&amp;e1,*pe2=&amp;e2,*pe3=&amp;e3,*pe4=&amp;e4;<br/>
      kebar(m,e,ist,ien,ar,ri,x,y,pc,ps,pe1,pe2,pe3,pe4);<br/>
      a1=e1*c*c+e2*s*s;<br/>
      a2=(e1-e2)*c*s;<br/>
      a3=e1*s*s+e2*c*c;<br/>
      a4=e3*s;<br/>
      a5=e3*c;<br/>
      a6=e4;<br/>
      *(ae+0*6+0)=a1;<br/>
      *(ae+0*6+1)=a2;<br/>
      *(ae+1*6+1)=a3;<br/>
      *(ae+0*6+2)=-a4;<br/>
      *(ae+1*6+2)=a5;<br/>
      *(ae+2*6+2)=a6;<br/>
      *(ae+0*6+3)=-a1;<br/>
      *(ae+1*6+3)=-a2;<br/>
      *(ae+2*6+3)=a4;<br/>
      *(ae+3*6+3)=a1;<br/>
      *(ae+0*6+4)=-a2;<br/>
      *(ae+1*6+4)=-a3;<br/>
      *(ae+2*6+4)=-a5;<br/>
      *(ae+3*6+4)=a2;<br/>
      *(ae+4*6+4)=a3;<br/>
      *(ae+0*6+5)=-a4;<br/>
      *(ae+1*6+5)=a5;<br/>
      *(ae+2*6+5)=0.5*a6;<br/>
      *(ae+3*6+5)=a4;<br/>
      *(ae+4*6+5)=-a5;<br/>
      *(ae+5*6+5)=a6;<br/>
}<br/>
/*形成总刚*/<br/>
void forma(float e,int nm,int *ist,int *ien,float *ar,float *ri,float *x,float *y,int </p>
<p>*lv,double *ae,int *ld,double *a)<br/>
{<br/>
      int m,i,j;<br/>
      for(m=0;m&lt;nm;m++)<br/>
       {<br/>
          ke(m,e,ist,ien,ar,ri,x,y,ae);<br/>
          for(i=0;i&lt;6;i++)<br/>
           {<br/>
              for(j=0;j&lt;=i;j++)<br/>
               {<br/>
                  if(*(lv+m*6+i)&gt;=*(lv+m*6+j))<br/>
                   {<br/>
                      *(a+(*(ld+*(lv+m*6+i)-1)-1-*(lv+m*6+i)+1+*(lv+m*6+j)-1))+=*(ae+j*6+i);<br/>
                   }<br/>
                  else<br/>
                   {<br/>
                      *(a+(*(ld+*(lv+m*6+j)-1)-1-*(lv+m*6+j)+1+*(lv+m*6+i)-1))+=*(ae+j*6+i);<br/>
                   }<br/>
               }<br/>
           }<br/>
       }<br/>
}<br/>
/*总刚a引用支承条件*/<br/>
void as(int ns,int *is,int *iu,int *ld,double *a)<br/>
{<br/>
      int m,j,i,k;<br/>
      for(m=0;m&lt;ns;m++)<br/>
       {<br/>
          j=*(is+m)/10-1;<br/>
          i=(*(is+m))%10-1;<br/>
          k=*(iu+j*3+i);<br/>
          *(a+*(ld+k-1)-1)=1e22;<br/>
       }<br/>
}<br/>
/*解方程组之一    总刚分解*/<br/>
void ldlt(int n,int *ld,double *a,double *t)<br/>
{<br/>
      double sum;<br/>
      int i,i1,j,j1,ldi,ldj,k;<br/>
      for(i=1;i&lt;n;i++)<br/>
       {<br/>
          ldi=*(ld+i);<br/>
          i1=i+1-ldi+*(ld+i-1)+1;<br/>
          for(j=i1-1;j&lt;i;j++)<br/>
           {<br/>
              ldj=*(ld+j);<br/>
              j1=j+1-ldj+*(ld+j-1)+1;<br/>
              if(i1&gt;j1)j1=i1;<br/>
              sum=0.0e0;<br/>
              for(k=j1-1;k&lt;j;k++)<br/>
               {<br/>
                  sum+=*(t+k)*(*(a+ldj-j+k-1));<br/>
               }<br/>
              *(t+j)=*(a+ldi-i+j-1)-sum;<br/>
              *(a+ldi-i+j-1)=*(t+j)/(*(a+ldj-1));<br/>
              *(a+ldi-1)-=*(t+j)*(*(a+ldi-i+j-1));<br/>
           }<br/>
       }<br/>
}<br/>
/*结点荷载列阵b置零*/<br/>
void b0(int lc,int n,int nlj,double *b)<br/>
{<br/>
      int i;<br/>
      fprintf(OUTFP,"                Loading Case%3d\n",lc);<br/>
      fprintf(OUTFP,"           The Loadings at Joints\n");<br/>
      fprintf(OUTFP,"                  NLJ=%4d\n",nlj);<br/>
      for(i=0;i&lt;n;i++)<br/>
       {<br/>
          *(b+i)=0.0e0;<br/>
       }<br/>
}<br/>
/*读入并输出结点荷载，形成结点荷载列阵b*/<br/>
void ioljb(int nlj,int *iu,int *lj,float *fx,float *fy,float *fm,double *b)<br/>
{<br/>
      int m,j;<br/>
      fprintf(OUTFP,"joint          FX                FY                  FM\n");<br/>
      for(m=0;m&lt;nlj;m++)<br/>
       {<br/>
          fscanf(IDFP,"%d",lj+m);<br/>
          fscanf(IDFP,"%f",fx+m);<br/>
          fscanf(IDFP,"%f",fy+m);<br/>
          fscanf(IDFP,"%f",fm+m);<br/>
          CH=fgetc(IDFP);<br/>
       }<br/>
      for(m=0;m&lt;nlj;m++)<br/>
       {<br/>
          fprintf(OUTFP,"%4d%16.6f%16.6f%18.6f\n",*(lj+m),*(fx+m),*(fy+m),*(fm+m));<br/>
       }<br/>
       for(m=0;m&lt;nlj;m++)<br/>
        {<br/>
           j=*(lj+m)-1;<br/>
           *(b+*(iu+j*3+0)-1)=*(fx+m);<br/>
           *(b+*(iu+j*3+1)-1)=*(fy+m);<br/>
           *(b+*(iu+j*3+2)-1)=*(fm+m);<br/>
        }<br/>
}<br/>
/*杆端力f置零*/<br/>
void f0(int nlm,int nm,double *f)<br/>
{<br/>
      int i,j;<br/>
      fprintf(OUTFP,"           The Loadings at Members\n");<br/>
      fprintf(OUTFP,"                  NLM=%4d\n",nlm);<br/>
      for(j=0;j&lt;nm;j++)<br/>
       {<br/>
          for(i=0;i&lt;6;i++)<br/>
           {<br/>
              *(f+j*6+i)=0.0e0;<br/>
           }<br/>
    }  <br/>
}<br/>
/*读入并输出非结点荷载，计算固端力，计算等效结点荷载并叠加到结点荷载列阵b中*/<br/>
void iolmfb(int nlm,int *lm,int *lt,float *vf,float *dst,int *ist,int *ien,float *x,float </p>
<p>*y,int *lv,double *f,double *b)<br/>
{<br/>
      int m,l;<br/>
      double d1,d2,p1,p2,f1,f2,f3,f4,f5,f6,g;<br/>
      double rl,c,s;<br/>
      double *prl=&amp;rl,*pc=&amp;c,*ps=&amp;s;<br/>
      fprintf(OUTFP,"membet    type           VF                DST\n");<br/>
      for(m=0;m&lt;nlm;m++)<br/>
       {<br/>
          fscanf(IDFP,"%d",lm+m);<br/>
          fscanf(IDFP,"%d",lt+m);<br/>
          fscanf(IDFP,"%f",vf+m);<br/>
          fscanf(IDFP,"%f",dst+m);<br/>
          CH=fgetc(IDFP);<br/>
       }<br/>
      for(m=0;m&lt;nlm;m++)<br/>
       {<br/>
          fprintf(OUTFP,"%4d%7d %16.6f%16.6f\n",*(lm+m),*(lt+m),*(vf+m),*(dst+m));<br/>
       }<br/>
      for(m=0;m&lt;nlm;m++)<br/>
       {<br/>
          l=*(lm+m);<br/>
          lcs(l,ist,ien,x,y,prl,pc,ps);<br/>
          d1=*(dst+m);<br/>
          d2=rl-d1;<br/>
          if(*(lt+m)==1||*(lt+m)==3)<br/>
           {<br/>
              p1=*(vf+m)*c;<br/>
              p2=-(*(vf+m)*s);<br/>
           }<br/>
          if(*(lt+m)==2||*(lt+m)==4)<br/>
           {<br/>
              p1=*(vf+m)*s;<br/>
              p2=*(vf+m)*c;<br/>
           }<br/>
          if(*(lt+m)==1||*(lt+m)==2)<br/>
           {<br/>
              f1=-p1*d2/rl;<br/>
              f4=-p1-f1;<br/>
              f2=-p2*d2*d2*(rl+2.0*d1)/(rl*rl*rl);<br/>
              f5=-p2-f2;<br/>
              f3=-p2*d1*d2*d2/(rl*rl);<br/>
              f6=p2*d1*d1*d2/(rl*rl);<br/>
           }<br/>
          if(*(lt+m)==3||*(lt+m)==4)<br/>
           {<br/>
              g=p2*d1*d1/(12.0*rl*rl);<br/>
              f3=-g*((6.0*rl-8.0*d1)*rl+3.0*d1*d1);<br/>
              f6=g*d1*(4.0*rl-3.0*d1);<br/>
              f5=-6.0*g*d1*(2.0-d1/rl);<br/>
              f2=-p2*d1-f5;<br/>
              f4=-p1*d1-f5;<br/>
              f1=-p1*d1-f4;<br/>
           }<br/>
          l--;<br/>
          *(f+l*6+0)+=f1;<br/>
          *(f+l*6+1)+=f2;<br/>
          *(f+l*6+2)+=f3;<br/>
          *(f+l*6+3)+=f4;<br/>
          *(f+l*6+4)+=f5;<br/>
          *(f+l*6+5)+=f6;<br/>
          *(b+*(lv+l*6+0)-1)-=f1*c-f2*s;<br/>
          *(b+*(lv+l*6+1)-1)-=f1*s+f2*c;<br/>
          *(b+*(lv+l*6+2)-1)-=f3;<br/>
          *(b+*(lv+l*6+3)-1)-=f4*c-f5*s;<br/>
          *(b+*(lv+l*6+4)-1)-=f4*s+f5*c;<br/>
          *(b+*(lv+l*6+5)-1)-=f6;<br/>
       }<br/>
}<br/>
/*结点荷载列阵b引入支承条件*/<br/>
void bs(int ns,int *is,float *vs,int *iu,double *b)<br/>
{<br/>
      int i,j,k,m;<br/>
      for(m=0;m&lt;ns;m++)<br/>
       {<br/>
          j=*(is+m)/10-1;<br/>
          i=(*(is+m)%10)-1;<br/>
          k=*(iu+j*3+i)-1;<br/>
          *(b+k)=*(vs+m)*1e22;<br/>
       }<br/>
}<br/>
/*解方程组之二    向前和向后回代*/<br/>
void slveq(int n,int maxbdw,int *ld,double *a,double *b)<br/>
{<br/>
      int i,j,ldi,ldj,i1,imin,j1;<br/>
      for(i=1;i&lt;n;i++)<br/>
       {<br/>
          ldi=*(ld+i);<br/>
          i1=i+1-ldi+*(ld+i-1)+1;<br/>
          for(j=i1-1;j&lt;i;j++)<br/>
           {<br/>
              *(b+i)-=*(a+ldi-1-i+j)*(*(b+j));<br/>
           }<br/>
    }  <br/>
      for(i=0;i&lt;n;i++)<br/>
       {<br/>
          *(b+i)/=*(a+*(ld+i)-1);<br/>
       }<br/>
      for(i=n-2;i&gt;=0;i--)<br/>
       {<br/>
          imin=i+1+maxbdw;<br/>
          if(imin&gt;n)imin=n;<br/>
          for(j=i+1;j&lt;imin;j++)<br/>
           {<br/>
              ldj=*(ld+j);<br/>
              j1=j+1-ldj+*(ld+j-1)+1;<br/>
              if(i+1&gt;=j1)<br/>
     {<br/>
      *(b+i)=*(b+i)-(*(a+ldj-j+i-1)*(*(b+j)));<br/>
     }<br/>
           }<br/>
       }<br/>
}<br/>
/*输出结点位移*/<br/>
void ojd(int nj,int *iu,double *b)<br/>
{<br/>
      int j;<br/>
      fprintf(OUTFP,"              The Results of Calculation\n");<br/>
      fprintf(OUTFP,"           The Joint Displacements\n");<br/>
      fprintf(OUTFP,"joint          u                 v              rotation\n");<br/>
      for(j=0;j&lt;nj;j++)<br/>
       {<br/>
          fprintf(OUTFP,"%4d%16.6e%16.6e%16.6e\n",j+1,*(b+*(iu+j*3+0)-1),*(b+*(iu+j*3+1)-1),*</p>
<p>(b+*(iu+j*3+2)-1));<br/>
       }<br/>
}<br/>
/*计算并输出杆端力*/<br/>
void cotf(float e,int nm,int *ist,int *ien,float *ar,float *ri,float *x,float *y,int </p>
<p>*lv,double *b,double *f)<br/>
{<br/>
      int m;<br/>
      double c,s,e1,e2,e3,e4,u1,u2,u3,u4,u5,u6;<br/>
      double *pc=&amp;c,*ps=&amp;s,*pe1=&amp;e1,*pe2=&amp;e2,*pe3=&amp;e3,*pe4=&amp;e4;<br/>
      fprintf(OUTFP,"           The Terminal Forces\n");<br/>
      fprintf(OUTFP,"member                    FN                FS                  M\n");<br/>
      for(m=0;m&lt;nm;m++)<br/>
       {<br/>
          kebar(m,e,ist,ien,ar,ri,x,y,pc,ps,pe1,pe2,pe3,pe4);<br/>
          u1=*(b+*(lv+m*6+0)-1)*c+*(b+*(lv+m*6+1)-1)*s;<br/>
          u2=-*(b+*(lv+m*6+0)-1)*s+*(b+*(lv+m*6+1)-1)*c;<br/>
          u3=*(b+*(lv+m*6+2)-1);<br/>
          u4=*(b+*(lv+m*6+3)-1)*c+*(b+*(lv+m*6+4)-1)*s;<br/>
          u5=-*(b+*(lv+m*6+3)-1)*s+*(b+*(lv+m*6+4)-1)*c;<br/>
          u6=*(b+*(lv+m*6+5)-1);<br/>
          *(f+m*6+0)+=e1*(u1-u4);<br/>
          *(f+m*6+1)+=e2*(u2-u5)+e3*(u3+u6);<br/>
          *(f+m*6+2)+=e3*(u2-u5)+e4*(u3+0.5*u6);<br/>
          *(f+m*6+3)+=e1*(u4-u1);<br/>
          *(f+m*6+4)+=e2*(u5-u2)-e3*(u3+u6);<br/>
          *(f+m*6+5)+=e3*(u2-u5)+e4*(0.5*u3+u6);<br/>
          fprintf(OUTFP,"%4d    start%4d%16.6f%16.6f%18.6f\n",m+1,*(ist+m),*(f+m*6+0),*</p>
<p>(f+m*6+1),*(f+m*6+2));<br/>
          fprintf(OUTFP,"          end%4d%16.6f%16.6f%18.6f\n",*(ien+m),*(f+m*6+3),*(f+m*6+4),*</p>
<p>(f+m*6+5));<br/>
       }<br/>
}</p>
<p>/*主函数 读入并输出控制数据，分配动态数组地址，并通过调用各个函数来调用整个计算*/<br/>
int main()<br/>
{<br/>
int </p>
<p>l1,l2,l3,l4,l11,l12,l21,l22,l31,l32,l41,l51,l52,l53,l54,l61,l62,l63,l64,l71,l81,l82,l83,l84;<br/>
int lc;<br/>
char idfn[13],outfn[13];<br/><br/>
printf("Input Data File Name:\n");<br/>
gets(idfn);<br/>
if((IDFP=fopen(idfn,"r"))==NULL)<br/>
    {<br/>
     printf("can not open Data File!\n");<br/>
     exit (0);<br/>
    }<br/>
printf("Output File Name:\n");<br/>
gets(outfn);<br/>
if((OUTFP=fopen(outfn,"w+"))==NULL)<br/>
    {<br/>
     printf("can not open Output File!\n");<br/>
     exit (0);<br/>
    }<br/>
fprintf(OUTFP,"Input Data File Name:%s\n",idfn);<br/>
fprintf(OUTFP,"Output File Name:%s\n",outfn);<br/>
    {<br/>
     int i=0;<br/>
     do<br/>
      {<br/>
    CH=fgetc(IDFP);<br/>
    fputc(CH,OUTFP);<br/>
    if(CH=='\n')i++;<br/>
}<br/>
     while(i&lt;5);<br/>
    }<br/>
fprintf(OUTFP,"\n");<br/>
fprintf(OUTFP,"                  The Input Data\n");<br/>
fprintf(OUTFP,"             The General Information\n");<br/>
fprintf(OUTFP,"       E           NM       NJ       NS       NLC\n");<br/>
fscanf(IDFP,"%f",&amp;E);<br/>
fscanf(IDFP,"%d",&amp;NM);<br/>
fscanf(IDFP,"%d",&amp;NJ);<br/>
fscanf(IDFP,"%d",&amp;NS);<br/>
fscanf(IDFP,"%d",&amp;NLC);<br/>
fprintf(OUTFP,"%10.3e",E);<br/>
fprintf(OUTFP,"%7d",NM);<br/>
fprintf(OUTFP,"%7d",NJ);<br/>
fprintf(OUTFP,"%7d",NS);<br/>
fprintf(OUTFP,"%7d\n",NLC);<br/>
fprintf(OUTFP,"           The Information of Members\n");<br/>
fprintf(OUTFP,"member    start    end           A                 I\n");<br/>
l1=0;<br/>
l2=l1+NM;<br/>
l3=0;<br/>
l4=l3+NM;<br/>
l11=l4+NM;<br/>
l12=l11+NJ;<br/>
l21=l2+NM;<br/>
l22=l12+NJ;<br/>
l31=l21+NS;<br/>
l32=l31+3*NJ;<br/>
l41=l32+6*NM;<br/>
iomjs(NM,NJ,NS,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l21,W2+l22);<br/>
idun(NJ,PN,W1+l31,W2+l11,W2+l12);<br/>
lcvct(NM,W1+l1,W1+l2,W1+l32,W1+l31);<br/>
lcdia(NM,N,W1+l32,W1+l41,W1+l41,W1+l41,PMAXBDW,PNA);<br/>
l51=0;<br/>
l52=l51+72;<br/>
l53=l52+NA*2;<br/>
l54=l53;<br/>
l61=l41+N;<br/>
forma(E,NM,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l32,W3+l51,W1+l41,W3+l52);<br/>
as(NS,W1+l21,W1+l31,W1+l41,W3+l52);<br/>
ldlt(N,W1+l41,W3+l52,W3+l53);<br/>
for(lc=1;lc&lt;=NLC;lc++)<br/>
    {<br/>
     fscanf(IDFP,"%d",&amp;NLJ);<br/>
     CH=fgetc(IDFP);<br/>
     l62=l22+NS;<br/>
     l63=l62+NLJ;<br/>
     l64=l63+NLJ;<br/>
     l71=l54+N*2;<br/>
     l81=l61+NLJ;<br/>
     b0(lc,N,NLJ,W3+l54);<br/>
     if(NLJ!=0)<br/>
      ioljb(NLJ,W1+l31,W1+l61,W2+l62,W2+l63,W2+l64,W3+l54);<br/>
     fscanf(IDFP,"%d",&amp;NLM);<br/>
     CH=fgetc(IDFP);<br/>
     l82=l81+NLM;<br/>
     l83=l64+NLJ;<br/>
     l84=l83+NLM;<br/>
     f0(NLM,NM,W3+l71);<br/>
     if(NLM!=0)<br/>
      iolmfb(NLM,W1+l81,W1+l82,W2+l83,W2+l84,W1+l1,W1+l2,W2+l11,W2+l12,W1+l32,W3+l71,W3+l54);<br/>
     bs(NS,W1+l21,W2+l22,W1+l31,W3+l54);<br/>
     slveq(N,MAXBDW,W1+l41,W3+l52,W3+l54);<br/>
     ojd(NJ,W1+l31,W3+l54);<br/>
     cotf(E,NM,W1+l1,W1+l2,W2+l3,W2+l4,W2+l11,W2+l12,W1+l32,W3+l54,W3+l71);<br/>
     fprintf(OUTFP,"              (NA=%4d)\n",NA);<br/>
    }<br/>
fclose(IDFP);<br/>
fclose(OUTFP);<br/>
printf("处理完毕\n");<br/>
system("pause");<br/>
return (0);<br/>
}</p>]]></excerpt:encoded>
		<wp:post_id>14</wp:post_id>
		<wp:post_date>2007-10-08 22:45:00</wp:post_date>
		<wp:post_date_gmt>2007-10-08 22:45:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%94%a8c%e8%af%ad%e8%a8%80%e6%94%b9%e5%86%99%e5%b9%b3%e9%9d%a2%e5%88%9a%e6%9e%b6%e9%9d%99%e5%8a%9b%e5%88%86%e6%9e%90%e7%a8%8b%e5%ba%8f%ef%bc%88%e4%ba%8c%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="cc"><![CDATA[C/C++]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%a8%8b%e5%ba%8f"><![CDATA[程序]]></category>
		<category domain="category" nicename="%e9%80%90%e6%b5%aa"><![CDATA[逐浪]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>用C语言改写平面刚架静力分析程序（一）</title>
		<link>http://hmgle.com/archives/15</link>
		<pubDate>Mon, 08 Oct 2007 22:41:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/15</guid>
		<description></description>
		<content:encoded><![CDATA[几乎用了整个国庆假期，用C改写了李鲲廉主编的结构力学（第4版）上册附录的pf程序，原pf程序是

用FORTRAN 77写的。期间参考了FORTRAN    90程序设计教程（刘卫国主编）、c程序设计（谭浩强著）、数

值计算方法与c语言工程函数库（杨华中 汪蕙编）p13~p17、结构矩阵分析与程序设计（温瑞监主编）等书

籍。本打算解方程组自己设计算法，难度大，故继续沿用原程序采用的变带宽LDLT法（改进平方根法）。

程序功能基本保持不变。不考虑异常处理功能，不考虑界面，必须按格式正确输入数据，数据输入错误时

可能不能运行。调试时出现了非常奇怪的问题，对于存在链杆支座的结构可能得出错误的答案，原因目前

不明，郁闷中。使用步骤和原来的一样，见李编的结构力学附录。下面是该书p357上的一个算例：杆件截

面为矩形，柱截面宽0.4m，高0.4m；梁截面宽0.4m，高0.7m（如图）：
<a href="http://hmgle.com/wp-content/uploads/2007/10/frame.jpg"><img class="alignnone size-full wp-image-301" title="frame" src="http://hmgle.com/wp-content/uploads/2007/10/frame.jpg" alt="" width="321" height="357" /></a>
<div></div>
选用弹性模量355e6gpa，求出各截面面积及二次矩，划分好节点和杆件号，输入数据文件内容：

*****************************************************

*                                                     *

*    算例 21:31 2007-10-8                               *

*                                                     *

*****************************************************

355e5 9 8 6 1

1 2 0.28 114333e-7

1 3 0.16 213333e-8

2 4 0.16 213333e-8

3 4 0.28 114333e-7

3 5 0.16 213333e-8

4 6 0.16 213333e-8

5 6 0.28 114333e-7

5 7 0.16 213333e-8

6 8 0.16 213333e-8

0 11

6 11

0 7.5

6 7.5

0 4

6 4

0 0

6 0

71 0

72 0

73 0

81 0

82 0

83 0

0

3

2 3 20 3.5

5 3 20 3.5

8 3 20 4

用我改写的程序算，输出结果文件为：

Input Data File Name:suanli.txt

Output File Name:suanliout.txt

*****************************************************

*                                                     *

*    算例 21:31 2007-10-8                               *

*                                                     *

*****************************************************

The Input Data

The General Information

E           NM       NJ       NS       NLC

3.550e+007        9        8        6        1

The Information of Members

member    start    end           A                 I

1         1       2     2.800000e-001     1.143330e-002

2         1       3     1.600000e-001     2.133330e-003

3         2       4     1.600000e-001     2.133330e-003

4         3       4     2.800000e-001     1.143330e-002

5         3       5     1.600000e-001     2.133330e-003

6         4       6     1.600000e-001     2.133330e-003

7         5       6     2.800000e-001     1.143330e-002

8         5       7     1.600000e-001     2.133330e-003

9         6       8     1.600000e-001     2.133330e-003

The joint Coordinates

joint          X                 Y

1          0.000000         11.000000

2          6.000000         11.000000

3          0.000000          7.500000

4          6.000000          7.500000

5          0.000000          4.000000

6          6.000000          4.000000

7          0.000000          0.000000

8          6.000000          0.000000

The Information of Supports

IS          VS

71         0.000000

72         0.000000

73         0.000000

81         0.000000

82         0.000000

83         0.000000

Loading Case    1

The Loadings at Joints

NLJ=     0

The Loadings at Members

NLM=     3

membet    type           VF                DST

2        3          20.000000          3.500000

5        3          20.000000          3.500000

8        3          20.000000          4.000000

The Results of Calculation

The Joint Displacements

joint          u                 v              rotation

1     1.340429e-002     5.846036e-005    -4.615768e-005

2     1.339457e-002    -1.297632e-004    -1.431599e-004

3     1.182718e-002     7.475106e-005    -3.457760e-004

4     1.180527e-002    -1.244870e-004    -3.307285e-004

5     7.634272e-003     6.561075e-005    -6.319532e-004

6     7.611849e-003    -9.377977e-005    -6.530693e-004

7     9.045905e-021     9.316727e-021    -1.928831e-020

8     8.954095e-021    -1.331673e-020    -1.914467e-020

The Terminal Forces

member                    FN                FS                  M

1    start     1         16.109058         -8.562519          -19.125643

end     2        -16.109058          8.562519          -32.249471

2    start     1         -8.562519        -16.109058           19.125643

end     3          8.562519        -53.890942           46.992656

3    start     2          8.562519         16.109058           32.249471

end     4         -8.562519        -16.109058           24.132231

4    start     3         36.283916        -41.270895         -124.830605

end     4        -36.283916         41.270895         -122.794767

5    start     3        -49.833414         17.607026           77.837950

end     5         49.833414        -87.607026          106.286642

6    start     4         49.833414         52.392974           98.662536

end     6        -49.833414        -52.392974           84.712873

7    start     5         37.147972        -83.333854         -248.573120

end     6        -37.147972         83.333854         -251.430004

8    start     5       -133.167268         50.459054          142.286478

end     7        133.167268       -130.459054          219.549737

9    start     6        133.167268         89.540946          166.717132

end     8       -133.167268        -89.540946          191.446653

(NA= 165)

这道题结果和答案有点出入，用原来的pf程序算的结果为：

*****************************************************

*                                                     *

*    算例 21:31 2007-10-8                               *

*                                                     *

*****************************************************

The Input Data

The General Information

E           NM       NJ       NS       NLC

3.550E+07        9        8        6        1

The Information of Members

member    start    end           A                 I

1         1       2      2.800000E-01      1.143330E-02

2         1       3      1.600000E-01      2.133330E-03

3         2       4      1.600000E-01      2.133330E-03

4         3       4      2.800000E-01      1.143330E-02

5         3       5      1.600000E-01      2.133330E-03

6         4       6      1.600000E-01      2.133330E-03

7         5       6      2.800000E-01      1.143330E-02

8         5       7      1.600000E-01      2.133330E-03

9         6       8      1.600000E-01      2.133330E-03

The Joint Coordinates

joint             X                   Y

1             .000000           11.000000

2            6.000000           11.000000

3             .000000            7.500000

4            6.000000            7.500000

5             .000000            4.000000

6            6.000000            4.000000

7             .000000             .000000

8            6.000000             .000000

The Information of Supports

IS           VS

71           .000000

72           .000000

73           .000000

81           .000000

82           .000000

83           .000000

( NA=     165 )

( NW=     610 )

Loading Case    1

The Loadings at Joints

NLJ=     0

The Loadings at Members

NLM=     3

ILM    ITL             PV              DST

2      3           20.0000          3.500000

5      3           20.0000          3.500000

8      3           20.0000          4.000000

The Results of Calculation

The Joint Displacements

joint          u                 v                phi

1      1.347116E-02      1.297112E-04     -5.784199E-05

2      1.346143E-02     -1.297112E-04     -1.548442E-04

3      1.185913E-02      1.244502E-04     -3.540431E-04

4      1.183723E-02     -1.244502E-04     -3.389956E-04

5      7.643597E-03      9.375904E-05     -6.366158E-04

6      7.621174E-03     -9.375904E-05     -6.577319E-04

7      9.045905E-21      1.331378E-20     -1.929713E-20

8      8.954095E-21     -1.331378E-20     -1.915349E-20

The Terminal Forces

member      N(st)        Q(st)         M(st)        N(en)        Q(en)         M(en)

1       16.109       -8.538       -19.052      -16.109        8.538       -32.176

2       -8.538      -16.109        19.052        8.538      -53.891        47.067

3        8.538       16.109        32.176       -8.538      -16.109        24.206

4       36.284      -41.270      -124.827      -36.284       41.270      -122.791

5      -49.807       17.607        77.760       49.807      -87.607       106.365

6       49.807       52.393        98.585      -49.807      -52.393        84.791

7       37.148      -83.330      -248.563      -37.148       83.330      -251.420

8     -133.138       50.459       142.198      133.138     -130.459       219.638

9      133.138       89.541       166.629     -133.138      -89.541       191.535

( NA=     165 )

( NW=     622 )

其中节点竖直位移相差比较大，其它数据还比较接近。改写的不算成功。正在找bug。

附源程序：

/*用c改写的平面刚架静力分析程序pf(A program for analysis of plane frame)

应该还有错误，慎用

完成时间:2007.10.7*/

#define NULL 0

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

#include &lt;math.h&gt;

float E;

int NM;

int NJ;

int NS;

int NLC;

int N;

int MAXBDW;

int NA;

int NLJ;

int NLM;

int *PN=&amp;N;

int *PNA=&amp;NA;

int *PMAXBDW=&amp;MAXBDW;

char CH;

FILE *IDFP,*OUTFP;

int W1[10000];

float W2[10000];

double W3[1000];


（未完待续）
<div class="tmpDiv"></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p>       几乎用了整个国庆假期，用C改写了李鲲廉主编的结构力学（第4版）上册附录的pf程序，原pf程序是</p>
<p>用FORTRAN 77写的。期间参考了FORTRAN    90程序设计教程（刘卫国主编）、c程序设计（谭浩强著）、数</p>
<p>值计算方法与c语言工程函数库（杨华中 汪蕙编）p13~p17、结构矩阵分析与程序设计（温瑞监主编）等书</p>
<p>籍。本打算解方程组自己设计算法，难度大，故继续沿用原程序采用的变带宽LDLT法（改进平方根法）。</p>
<p>程序功能基本保持不变。不考虑异常处理功能，不考虑界面，必须按格式正确输入数据，数据输入错误时</p>
<p>可能不能运行。调试时出现了非常奇怪的问题，对于存在链杆支座的结构可能得出错误的答案，原因目前</p>
<p>不明，郁闷中。使用步骤和原来的一样，见李编的结构力学附录。下面是该书p357上的一个算例：杆件截</p>
<p>面为矩形，柱截面宽0.4m，高0.4m；梁截面宽0.4m，高0.7m（如图）：</p>
<div forimg="1"><a href="http://hiphotos.baidu.com/hmgle/pic/item/85dc8331550c75a35fdf0e14.jpg" target="_blank"><img border="0" small="1" class="blogimg" src="http://hiphotos.baidu.com/hmgle/abpic/item/85dc8331550c75a35fdf0e14.jpg"/></a></div>
<p>      选用弹性模量355e6gpa，求出各截面面积及二次矩，划分好节点和杆件号，输入数据文件内容：<br/>
*****************************************************<br/>
*                                                     *<br/>
*    算例 21:31 2007-10-8                               *<br/>
*                                                     *<br/>
*****************************************************<br/>
355e5 9 8 6 1<br/>
1 2 0.28 114333e-7<br/>
1 3 0.16 213333e-8<br/>
2 4 0.16 213333e-8<br/>
3 4 0.28 114333e-7<br/>
3 5 0.16 213333e-8<br/>
4 6 0.16 213333e-8<br/>
5 6 0.28 114333e-7<br/>
5 7 0.16 213333e-8<br/>
6 8 0.16 213333e-8<br/>
0 11<br/>
6 11<br/>
0 7.5<br/>
6 7.5<br/>
0 4<br/>
6 4<br/>
0 0<br/>
6 0<br/>
71 0<br/>
72 0<br/>
73 0<br/>
81 0<br/>
82 0<br/>
83 0<br/>
0<br/>
3<br/>
2 3 20 3.5<br/>
5 3 20 3.5<br/>
8 3 20 4<br/>
      用我改写的程序算，输出结果文件为：<br/>
Input Data File Name:suanli.txt<br/>
Output File Name:suanliout.txt<br/>
*****************************************************<br/>
*                                                     *<br/>
*    算例 21:31 2007-10-8                               *<br/>
*                                                     *<br/>
*****************************************************<br/>
                  The Input Data<br/>
             The General Information<br/>
       E           NM       NJ       NS       NLC<br/>
3.550e+007        9        8        6        1<br/>
           The Information of Members<br/>
member    start    end           A                 I<br/>
     1         1       2     2.800000e-001     1.143330e-002<br/>
     2         1       3     1.600000e-001     2.133330e-003<br/>
     3         2       4     1.600000e-001     2.133330e-003<br/>
     4         3       4     2.800000e-001     1.143330e-002<br/>
     5         3       5     1.600000e-001     2.133330e-003<br/>
     6         4       6     1.600000e-001     2.133330e-003<br/>
     7         5       6     2.800000e-001     1.143330e-002<br/>
     8         5       7     1.600000e-001     2.133330e-003<br/>
     9         6       8     1.600000e-001     2.133330e-003<br/>
           The joint Coordinates<br/>
joint          X                 Y<br/>
      1          0.000000         11.000000<br/>
      2          6.000000         11.000000<br/>
      3          0.000000          7.500000<br/>
      4          6.000000          7.500000<br/>
      5          0.000000          4.000000<br/>
      6          6.000000          4.000000<br/>
      7          0.000000          0.000000<br/>
      8          6.000000          0.000000<br/>
           The Information of Supports<br/>
     IS          VS<br/>
     71         0.000000<br/>
     72         0.000000<br/>
     73         0.000000<br/>
     81         0.000000<br/>
     82         0.000000<br/>
     83         0.000000<br/>
                Loading Case    1<br/>
           The Loadings at Joints<br/>
                  NLJ=     0<br/>
           The Loadings at Members<br/>
                  NLM=     3<br/>
membet    type           VF                DST<br/>
     2        3          20.000000          3.500000<br/>
     5        3          20.000000          3.500000<br/>
     8        3          20.000000          4.000000<br/>
              The Results of Calculation<br/>
           The Joint Displacements<br/>
joint          u                 v              rotation<br/>
     1     1.340429e-002     5.846036e-005    -4.615768e-005<br/>
     2     1.339457e-002    -1.297632e-004    -1.431599e-004<br/>
     3     1.182718e-002     7.475106e-005    -3.457760e-004<br/>
     4     1.180527e-002    -1.244870e-004    -3.307285e-004<br/>
     5     7.634272e-003     6.561075e-005    -6.319532e-004<br/>
     6     7.611849e-003    -9.377977e-005    -6.530693e-004<br/>
     7     9.045905e-021     9.316727e-021    -1.928831e-020<br/>
     8     8.954095e-021    -1.331673e-020    -1.914467e-020<br/>
           The Terminal Forces<br/>
member                    FN                FS                  M<br/>
     1    start     1         16.109058         -8.562519          -19.125643<br/>
          end     2        -16.109058          8.562519          -32.249471<br/>
     2    start     1         -8.562519        -16.109058           19.125643<br/>
          end     3          8.562519        -53.890942           46.992656<br/>
     3    start     2          8.562519         16.109058           32.249471<br/>
          end     4         -8.562519        -16.109058           24.132231<br/>
     4    start     3         36.283916        -41.270895         -124.830605<br/>
          end     4        -36.283916         41.270895         -122.794767<br/>
     5    start     3        -49.833414         17.607026           77.837950<br/>
          end     5         49.833414        -87.607026          106.286642<br/>
     6    start     4         49.833414         52.392974           98.662536<br/>
          end     6        -49.833414        -52.392974           84.712873<br/>
     7    start     5         37.147972        -83.333854         -248.573120<br/>
          end     6        -37.147972         83.333854         -251.430004<br/>
     8    start     5       -133.167268         50.459054          142.286478<br/>
          end     7        133.167268       -130.459054          219.549737<br/>
     9    start     6        133.167268         89.540946          166.717132<br/>
          end     8       -133.167268        -89.540946          191.446653<br/>
              (NA= 165)<br/>
      这道题结果和答案有点出入，用原来的pf程序算的结果为：<br/>
*****************************************************<br/>
*                                                     *<br/>
*    算例 21:31 2007-10-8                               *<br/>
*                                                     *<br/>
*****************************************************<br/>
              The Input Data<br/>
           The General Information<br/>
       E           NM       NJ       NS       NLC<br/>
3.550E+07        9        8        6        1<br/>
           The Information of Members<br/>
member    start    end           A                 I<br/>
     1         1       2      2.800000E-01      1.143330E-02<br/>
     2         1       3      1.600000E-01      2.133330E-03<br/>
     3         2       4      1.600000E-01      2.133330E-03<br/>
     4         3       4      2.800000E-01      1.143330E-02<br/>
     5         3       5      1.600000E-01      2.133330E-03<br/>
     6         4       6      1.600000E-01      2.133330E-03<br/>
     7         5       6      2.800000E-01      1.143330E-02<br/>
     8         5       7      1.600000E-01      2.133330E-03<br/>
     9         6       8      1.600000E-01      2.133330E-03<br/>
           The Joint Coordinates<br/>
joint             X                   Y<br/>
     1             .000000           11.000000<br/>
     2            6.000000           11.000000<br/>
     3             .000000            7.500000<br/>
     4            6.000000            7.500000<br/>
     5             .000000            4.000000<br/>
     6            6.000000            4.000000<br/>
     7             .000000             .000000<br/>
     8            6.000000             .000000<br/>
           The Information of Supports<br/>
     IS           VS<br/>
     71           .000000<br/>
     72           .000000<br/>
     73           .000000<br/>
     81           .000000<br/>
     82           .000000<br/>
     83           .000000<br/>
                                         ( NA=     165 )<br/>
                                         ( NW=     610 )<br/>
                Loading Case    1<br/>
           The Loadings at Joints<br/>
                  NLJ=     0<br/>
           The Loadings at Members<br/>
                  NLM=     3<br/>
ILM    ITL             PV              DST<br/>
     2      3           20.0000          3.500000<br/>
     5      3           20.0000          3.500000<br/>
     8      3           20.0000          4.000000<br/>
              The Results of Calculation<br/>
           The Joint Displacements<br/>
joint          u                 v                phi<br/>
     1      1.347116E-02      1.297112E-04     -5.784199E-05<br/>
     2      1.346143E-02     -1.297112E-04     -1.548442E-04<br/>
     3      1.185913E-02      1.244502E-04     -3.540431E-04<br/>
     4      1.183723E-02     -1.244502E-04     -3.389956E-04<br/>
     5      7.643597E-03      9.375904E-05     -6.366158E-04<br/>
     6      7.621174E-03     -9.375904E-05     -6.577319E-04<br/>
     7      9.045905E-21      1.331378E-20     -1.929713E-20<br/>
     8      8.954095E-21     -1.331378E-20     -1.915349E-20<br/>
           The Terminal Forces<br/>
member      N(st)        Q(st)         M(st)        N(en)        Q(en)         M(en)<br/>
     1       16.109       -8.538       -19.052      -16.109        8.538       -32.176<br/>
     2       -8.538      -16.109        19.052        8.538      -53.891        47.067<br/>
     3        8.538       16.109        32.176       -8.538      -16.109        24.206<br/>
     4       36.284      -41.270      -124.827      -36.284       41.270      -122.791<br/>
     5      -49.807       17.607        77.760       49.807      -87.607       106.365<br/>
     6       49.807       52.393        98.585      -49.807      -52.393        84.791<br/>
     7       37.148      -83.330      -248.563      -37.148       83.330      -251.420<br/>
     8     -133.138       50.459       142.198      133.138     -130.459       219.638<br/>
     9      133.138       89.541       166.629     -133.138      -89.541       191.535<br/>
                                         ( NA=     165 )<br/>
                                         ( NW=     622 )</p>
<p>    其中节点竖直位移相差比较大，其它数据还比较接近。改写的不算成功。正在找bug。<br/>
附源程序：<br/>
/*用c改写的平面刚架静力分析程序pf(A program for analysis of plane frame)<br/>
应该还有错误，慎用<br/>
完成时间:2007.10.7*/<br/>
#define NULL 0<br/>
#include &lt;stdio.h&gt;<br/>
#include &lt;stdlib.h&gt;<br/>
#include &lt;math.h&gt;<br/>
float E;<br/>
int NM;<br/>
int NJ;<br/>
int NS;<br/>
int NLC;<br/>
int N;<br/>
int MAXBDW;<br/>
int NA;<br/>
int NLJ;<br/>
int NLM;<br/>
int *PN=&amp;N;<br/>
int *PNA=&amp;NA;<br/>
int *PMAXBDW=&amp;MAXBDW;<br/>
char CH;<br/>
FILE *IDFP,*OUTFP;<br/>
int W1[10000];<br/>
float W2[10000];<br/>
double W3[1000];<br/><br/>
（未完待续）</p>
<div class="tmpDiv"> </div>]]></excerpt:encoded>
		<wp:post_id>15</wp:post_id>
		<wp:post_date>2007-10-08 22:41:00</wp:post_date>
		<wp:post_date_gmt>2007-10-08 22:41:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%94%a8c%e8%af%ad%e8%a8%80%e6%94%b9%e5%86%99%e5%b9%b3%e9%9d%a2%e5%88%9a%e6%9e%b6%e9%9d%99%e5%8a%9b%e5%88%86%e6%9e%90%e7%a8%8b%e5%ba%8f%ef%bc%88%e4%b8%80%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="cc"><![CDATA[C/C++]]></category>
		<category domain="post_tag" nicename="fortran"><![CDATA[Fortran]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%a8%8b%e5%ba%8f"><![CDATA[程序]]></category>
		<category domain="category" nicename="%e9%80%90%e6%b5%aa"><![CDATA[逐浪]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>一、开头</title>
		<link>http://hmgle.com/archives/16</link>
		<pubDate>Mon, 08 Oct 2007 21:55:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/16</guid>
		<description></description>
		<content:encoded><![CDATA[<p>1、错误在所难免，欢迎批评指正；<br/>
2、任何人可自由转载、使用；<br/>
3、保持简朴，拒绝华丽。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p>1、错误在所难免，欢迎批评指正；<br/>
2、任何人可自由转载、使用；<br/>
3、保持简朴，拒绝华丽。</p>]]></excerpt:encoded>
		<wp:post_id>16</wp:post_id>
		<wp:post_date>2007-10-08 21:55:00</wp:post_date>
		<wp:post_date_gmt>2007-10-08 21:55:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%80%e3%80%81%e5%bc%80%e5%a4%b4</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>删除线</title>
		<link>http://hmgle.com/archives/27</link>
		<pubDate>Thu, 12 Jun 2008 23:07:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/27</guid>
		<description></description>
		<content:encoded><![CDATA[<p class="MsoNormal"><span>方法一：<s>可以在文字处理软件里编辑然后复制进来</s></span><s><span>,</span></s><s><span>这段文字就是这样的。</span></s></p>
<p class="MsoNormal"><s><span>
</span></s></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p class="MsoNormal"> </p>
<p class="MsoNormal"><span>方法一：<s>可以在文字处理软件里编辑然后复制进来</s></span><s><span>,</span></s><s><span>这段文字就是这样的。</span></s></p>
<p class="MsoNormal"><s><span><br/></span></s></p>]]></excerpt:encoded>
		<wp:post_id>27</wp:post_id>
		<wp:post_date>2008-06-12 23:07:00</wp:post_date>
		<wp:post_date_gmt>2008-06-12 23:07:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%88%a0%e9%99%a4%e7%ba%bf</wp:post_name>
		<wp:status>private</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%88%a0%e9%99%a4%e7%ba%bf"><![CDATA[删除线]]></category>
		<category domain="category" nicename="%e6%9c%aa%e5%88%86%e7%b1%bb"><![CDATA[未分类]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>晚上赴凤凰</title>
		<link>http://hmgle.com/archives/31</link>
		<pubDate>Sat, 31 May 2008 13:10:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/31</guid>
		<description></description>
		<content:encoded><![CDATA[rt，游玩，兼实习。]]></content:encoded>
		<excerpt:encoded><![CDATA[rt，游玩，兼实习。]]></excerpt:encoded>
		<wp:post_id>31</wp:post_id>
		<wp:post_date>2008-05-31 13:10:00</wp:post_date>
		<wp:post_date_gmt>2008-05-31 13:10:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%99%9a%e4%b8%8a%e8%b5%b4%e5%87%a4%e5%87%b0</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%b0%98%e5%b0%81"><![CDATA[尘封]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%90%90%e4%ba%8b"><![CDATA[琐事]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>5.12地震</title>
		<link>http://hmgle.com/archives/32</link>
		<pubDate>Fri, 16 May 2008 10:29:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/32</guid>
		<description></description>
		<content:encoded><![CDATA[人间灾难莫过于此。<br/>
默默地为人民祈祷，愿死者安息，生者平安。<br/>
大家有钱出钱，有力出力，帮助灾区人民重建家园吧！]]></content:encoded>
		<excerpt:encoded><![CDATA[人间灾难莫过于此。<br/>
默默地为人民祈祷，愿死者安息，生者平安。<br/>
大家有钱出钱，有力出力，帮助灾区人民重建家园吧！]]></excerpt:encoded>
		<wp:post_id>32</wp:post_id>
		<wp:post_date>2008-05-16 10:29:00</wp:post_date>
		<wp:post_date_gmt>2008-05-16 10:29:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>5-12%e5%9c%b0%e9%9c%87</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%8e%86%e5%8f%b2"><![CDATA[历史]]></category>
		<category domain="category" nicename="%e5%b0%98%e5%b0%81"><![CDATA[尘封]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>National Geographic shadow</title>
		<link>http://hmgle.com/archives/33</link>
		<pubDate>Sun, 04 May 2008 00:24:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/33</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="font-size: small;"><a href="http://www.moillusions.com/2008/05/national-geographics-shadow-zebras.html" target="_blank"><span style="font-family: 'Times New Roman';">来源：http://www.moillusions.com/2008/05/national-geographics-shadow-zebras.html   </span></a></span>
<a href="http://hmgle.com/wp-content/uploads/2008/05/zebras.jpg"><img class="alignnone size-full wp-image-276" title="zebras" src="http://hmgle.com/wp-content/uploads/2008/05/zebras.jpg" alt="" width="500" height="323" /></a>
<span><a href="http://www.moillusions.com/2008/05/national-geographics-shadow-zebras.html" target="_blank"><span style="font-family: 'Times New Roman'; font-size: small;">National Geographic's Shadow Zebras Illusion</span></a></span> <a href="http://i207.photobucket.com/albums/bb234/vurdlak8/illusions/zebras.jpg" target="_blank">高空拍摄。影子很清晰。
</a>
<h3></h3>
来源：<span><span style="font-size: small;"><a href="http://www.moillusions.com/2008/05/national-geographics-shadow-zebras.html" target="_blank"><span style="font-family: 'Times New Roman';">http://www.moillusions.com/2006/09/national-geographics-shadow-camels.html</span></a></span></span>
<a href="http://hmgle.com/wp-content/uploads/2008/05/camels.jpg"><img class="alignnone size-full wp-image-277" title="camels" src="http://hmgle.com/wp-content/uploads/2008/05/camels.jpg" alt="" width="796" height="525" /></a>
<div></div>
<span style="font-family: 'Times New Roman'; font-size: small;"><a href="http://www.moillusions.com/2006/09/national-geographics-shadow-camels.html" target="_blank">National Geographic's Shadow Camels</a></span><span style="font-family: 宋体; font-size: small;">黑色的是影子。哪匹骑有人？

查看更多：<a href="http://www.moillusions.com/" target="_blank">http://www.moillusions.com/</a>
</span>]]></content:encoded>
		<excerpt:encoded><![CDATA[<font size="3"><a href="http://www.moillusions.com/2008/05/national-geographics-shadow-zebras.html" target="_blank"><font face="Times New Roman">来源：http://www.moillusions.com/2008/05/national-geographics-shadow-zebras.html    </font></a></font><br/><a href="http://i207.photobucket.com/albums/bb234/vurdlak8/illusions/zebras.jpg" target="_blank"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/6f749677979dba08b151b9f8.jpg"/></a><br/><font><a href="http://www.moillusions.com/2008/05/national-geographics-shadow-zebras.html" target="_blank"><font size="3" face="Times New Roman">National Geographic's Shadow Zebras Illusion</font></a></font> <a target="_blank" href="http://i207.photobucket.com/albums/bb234/vurdlak8/illusions/zebras.jpg">高空拍摄。影子很清晰。<br/></a>
<h3> </h3>
来源：<font><font size="3"><a href="http://www.moillusions.com/2008/05/national-geographics-shadow-zebras.html" target="_blank"><font face="Times New Roman">http://www.moillusions.com/2006/09/national-geographics-shadow-camels.html</font></a></font></font><br/><h3>
<div forimg="1"><a target="_blank" href="http://photos1.blogger.com/photoInclude/blogger/5639/2020/1600/camels.jpg"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/6c3604c7f8aaf1cfd00060c7.jpg"/></a></div>
<font size="3" face="Times New Roman"><a target="_blank" href="http://www.moillusions.com/2006/09/national-geographics-shadow-camels.html">National Geographic's Shadow Camels</a></font><font size="3" face="宋体">黑色的是影子。哪匹骑有人？<br/>
查看更多：<a target="_blank" href="http://www.moillusions.com/">http://www.moillusions.com/</a><br/></font></h3>]]></excerpt:encoded>
		<wp:post_id>33</wp:post_id>
		<wp:post_date>2008-05-04 00:24:00</wp:post_date>
		<wp:post_date_gmt>2008-05-04 00:24:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>national-geographic-shadow</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%be"><![CDATA[图]]></category>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>C++  + Blitz++  vs FORTRAN</title>
		<link>http://hmgle.com/archives/34</link>
		<pubDate>Thu, 17 Apr 2008 15:38:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/34</guid>
		<description></description>
		<content:encoded><![CDATA[<font size="3" face="宋体">FORTRAN，历史上第一个出现的高级语言，从它诞生之日起，就一直占据着科学计算的首要位置。在数值计算速度方面，无出其右者，包括C/C++。50年代还出现过一个专注于数值计算的语言ALGOL，它的设计目标是面向算法描述的，不幸已沦为古董。目前绝大部分的数值计算函数有FORTRAN现成的源程序。<br/><br/>
今天看到一个令C++ fans高兴的<a target="_blank" href="http://ubiety.uwaterloo.ca/~tveldhui/papers/iscope97/index.html">页面</a>，使用Blitz++库的C++程序速度可以达到甚至超过Fortran。令GNU fans可喜的是Blitz++是自由的，遵从GPL协议，任何人都可以自由的下载、使用、散布、修改它（参见GPL协议）。<br/><br/>
Blitz++可在<a target="_blank" href="http://www.oonumerics.org/blitz/download/">http://www.oonumerics.org/blitz/download/</a>页面得到。<br/>
Blitz++的帮助文档页面是：<a target="_blank" href="http://www.oonumerics.org/blitz/docs/">http://www.oonumerics.org/blitz/docs/</a><br/><a target="_blank" href="http://www.oonumerics.org/blitz/docs/blitz.pdf">pdf</a>格式</font>]]></content:encoded>
		<excerpt:encoded><![CDATA[<font size="3" face="宋体">FORTRAN，历史上第一个出现的高级语言，从它诞生之日起，就一直占据着科学计算的首要位置。在数值计算速度方面，无出其右者，包括C/C++。50年代还出现过一个专注于数值计算的语言ALGOL，它的设计目标是面向算法描述的，不幸已沦为古董。目前绝大部分的数值计算函数有FORTRAN现成的源程序。<br/><br/>
今天看到一个令C++ fans高兴的<a target="_blank" href="http://ubiety.uwaterloo.ca/~tveldhui/papers/iscope97/index.html">页面</a>，使用Blitz++库的C++程序速度可以达到甚至超过Fortran。令GNU fans可喜的是Blitz++是自由的，遵从GPL协议，任何人都可以自由的下载、使用、散布、修改它（参见GPL协议）。<br/><br/>
Blitz++可在<a target="_blank" href="http://www.oonumerics.org/blitz/download/">http://www.oonumerics.org/blitz/download/</a>页面得到。<br/>
Blitz++的帮助文档页面是：<a target="_blank" href="http://www.oonumerics.org/blitz/docs/">http://www.oonumerics.org/blitz/docs/</a><br/><a target="_blank" href="http://www.oonumerics.org/blitz/docs/blitz.pdf">pdf</a>格式</font>]]></excerpt:encoded>
		<wp:post_id>34</wp:post_id>
		<wp:post_date>2008-04-17 15:38:00</wp:post_date>
		<wp:post_date_gmt>2008-04-17 15:38:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>c-blitz-vs-fortran</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
		<category domain="post_tag" nicename="%e5%ba%93"><![CDATA[库]]></category>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[Angry Birds online]]></wp:comment_author>
			<wp:comment_author_email>Mallett2743@aol.com</wp:comment_author_email>
			<wp:comment_author_url>http://angry-birds-online.com</wp:comment_author_url>
			<wp:comment_author_IP>173.234.56.94</wp:comment_author_IP>
			<wp:comment_date>2011-02-21 01:57:30</wp:comment_date>
			<wp:comment_date_gmt>2011-02-21 01:57:30</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'd  incessantly want to be update on new  articles  on this  web site ,  saved to favorites ! .]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[Seo Company]]></wp:comment_author>
			<wp:comment_author_email>Clearwater@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.seocompanyworldwide.com/</wp:comment_author_url>
			<wp:comment_author_IP>173.234.177.192</wp:comment_author_IP>
			<wp:comment_date>2011-03-01 08:22:43</wp:comment_date>
			<wp:comment_date_gmt>2011-03-01 08:22:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thats interesting article. This is my first time coming here and I think it has been very helpful. You are doing a good job. Great keep it up.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[hmgle]]></wp:comment_author>
			<wp:comment_author_email>dustgle@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>58.253.82.73</wp:comment_author_IP>
			<wp:comment_date>2011-03-06 11:58:00</wp:comment_date>
			<wp:comment_date_gmt>2011-03-06 11:58:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[robot!Are you human?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>3</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5</wp:comment_id>
			<wp:comment_author><![CDATA[hmgle]]></wp:comment_author>
			<wp:comment_author_email>dustgle@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>58.253.82.73</wp:comment_author_IP>
			<wp:comment_date>2011-03-06 12:02:04</wp:comment_date>
			<wp:comment_date_gmt>2011-03-06 12:02:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[robot! Are you human?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>比萨饼定理</title>
		<link>http://hmgle.com/archives/35</link>
		<pubDate>Sun, 06 Apr 2008 00:15:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/35</guid>
		<description></description>
		<content:encoded><![CDATA[<font size="3">      比萨饼（PIZZA）是一种由特殊的饼底、乳酪、酱汁和馅料做成的具有意大利风味的食品，在本文中你只要认识到它是圆的，薄的，均匀的就可以了，而不必关心它的味道如何。有些爱吃比萨饼的人发现并证明了一些定理，并把它们命名为比萨饼定理（PIZZA Theorem）。现介绍如下：<br/>
      先说可爱的比萨饼第二定理：The volume of a circular pizza of thickness a and radius z is, of course, pizza. 即：一个厚度为a，半径为z的圆的比萨饼的体积是Pi*z*z*a,也就是Pizza。<br/><br/>
      比萨饼第一定理，也叫比萨饼定理，它提供了一个为n个人平分一块比萨饼的方法：在比萨饼上找一随机点P，用通过这个随机点的2*n刀把饼分成角度相同的4*n份，按顺序编号。第k (k = 1..n) 个人取编号为k，n+k,2*n+k,3*n+k的分块。那么每个人得到同样多的比萨饼。<br/>
简单证明如下：令alpha = Pi/(2*n),r(theta) 表示极坐标中随机点P到边缘的长度。那么第k个人得到的面积有：<br/>
       int( (1/2)*(r(theta)^2 + r(theta + Pi/2)^2 + r(theta + Pi)^2 + r(theta + 3*Pi/2)^2 ), theta = (k -1)*alpha..k*alpha );<br/>
下面将证明积分的部分(1/2)*(r(theta)^2 + r(theta + Pi/2)^2 + r(theta + Pi)^2 + r(theta + 3*Pi/2)^2 )等于 2*R^2;<br/>
       令 r(theta) = a, r(theta + Pi/2) = b, r(theta + Pi) = c, r(theta + 3*Pi/2) = d, 它们边缘上的点分别为A，B，C，D。PA = a, PB = b, PC = c, PD = d.作OM垂直BD于M，ON垂直AC于N，则<br/>
       R^2 = OD^2 = OM^2 + MD^2 = NP^2 + MD^2 = ((a - c)/2)^2 + ((b + d)/2)^2;<br/>
       R^2 = OC^2 = ON^2 + NC^2 = MP^2 + NC^2 = ((b - d)/2)^2 + ((a + c)/2)^2;<br/>
两式相加得<br/>
       2*R^2 = (1/2)*(a^2 + b^2 + c^2 + d^2);<br/>
于是第k个人得到的面积为<br/>
       int(2*R^2, theta = (k -1)*alpha..k*alpha ) = Pi*R^2/n;<br/>
证毕。<br/>
所以每个人分的的面积相同。<br/>
参考：<a href="http://mathworld.wolfram.com/PizzaTheorem.html" target="_blank">http://mathworld.wolfram.com/PizzaTheorem.html</a><br/><a href="http://www.maths.unsw.edu.au/~mikeh/webpapers/paper57.pdf" target="_blank">http://www.maths.unsw.edu.au/~mikeh/webpapers/paper57.pdf</a><br/></font>]]></content:encoded>
		<excerpt:encoded><![CDATA[<font size="3">      比萨饼（PIZZA）是一种由特殊的饼底、乳酪、酱汁和馅料做成的具有意大利风味的食品，在本文中你只要认识到它是圆的，薄的，均匀的就可以了，而不必关心它的味道如何。有些爱吃比萨饼的人发现并证明了一些定理，并把它们命名为比萨饼定理（PIZZA Theorem）。现介绍如下：<br/>
      先说可爱的比萨饼第二定理：The volume of a circular pizza of thickness a and radius z is, of course, pizza. 即：一个厚度为a，半径为z的圆的比萨饼的体积是Pi*z*z*a,也就是Pizza。<br/><br/>
      比萨饼第一定理，也叫比萨饼定理，它提供了一个为n个人平分一块比萨饼的方法：在比萨饼上找一随机点P，用通过这个随机点的2*n刀把饼分成角度相同的4*n份，按顺序编号。第k (k = 1..n) 个人取编号为k，n+k,2*n+k,3*n+k的分块。那么每个人得到同样多的比萨饼。<br/>
简单证明如下：令alpha = Pi/(2*n),r(theta) 表示极坐标中随机点P到边缘的长度。那么第k个人得到的面积有：<br/>
       int( (1/2)*(r(theta)^2 + r(theta + Pi/2)^2 + r(theta + Pi)^2 + r(theta + 3*Pi/2)^2 ), theta = (k -1)*alpha..k*alpha );<br/>
下面将证明积分的部分(1/2)*(r(theta)^2 + r(theta + Pi/2)^2 + r(theta + Pi)^2 + r(theta + 3*Pi/2)^2 )等于 2*R^2;<br/>
       令 r(theta) = a, r(theta + Pi/2) = b, r(theta + Pi) = c, r(theta + 3*Pi/2) = d, 它们边缘上的点分别为A，B，C，D。PA = a, PB = b, PC = c, PD = d.作OM垂直BD于M，ON垂直AC于N，则<br/>
       R^2 = OD^2 = OM^2 + MD^2 = NP^2 + MD^2 = ((a - c)/2)^2 + ((b + d)/2)^2;<br/>
       R^2 = OC^2 = ON^2 + NC^2 = MP^2 + NC^2 = ((b - d)/2)^2 + ((a + c)/2)^2;<br/>
两式相加得<br/>
       2*R^2 = (1/2)*(a^2 + b^2 + c^2 + d^2);<br/>
于是第k个人得到的面积为<br/>
       int(2*R^2, theta = (k -1)*alpha..k*alpha ) = Pi*R^2/n;<br/>
证毕。<br/>
所以每个人分的的面积相同。<br/>
参考：<a href="http://mathworld.wolfram.com/PizzaTheorem.html" target="_blank">http://mathworld.wolfram.com/PizzaTheorem.html</a><br/><a href="http://www.maths.unsw.edu.au/~mikeh/webpapers/paper57.pdf" target="_blank">http://www.maths.unsw.edu.au/~mikeh/webpapers/paper57.pdf</a><br/></font>]]></excerpt:encoded>
		<wp:post_id>35</wp:post_id>
		<wp:post_date>2008-04-06 00:15:00</wp:post_date>
		<wp:post_date_gmt>2008-04-06 00:15:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%af%94%e8%90%a8%e9%a5%bc%e5%ae%9a%e7%90%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%ae%9a%e7%90%86"><![CDATA[定理]]></category>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="post_tag" nicename="%e6%9c%89%e8%b6%a3"><![CDATA[有趣]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e8%87%aa%e6%88%91%e6%8c%87%e6%b6%89"><![CDATA[自我指涉]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>随机车辙里隐藏的方向</title>
		<link>http://hmgle.com/archives/36</link>
		<pubDate>Thu, 03 Apr 2008 17:06:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/36</guid>
		<description></description>
		<content:encoded><![CDATA[<div><a href="http://hmgle.com/wp-content/uploads/2008/04/track1.jpg"><img class="alignnone size-full wp-image-280" title="track1" src="http://hmgle.com/wp-content/uploads/2008/04/track1.jpg" alt="" width="365" height="289" /></a>
有时候某些人不得不费尽心思地从一些被常人所忽略的迹象里寻找出过去隐藏的真相，例如从路面车子留下的踪迹来判断车行驶的方向，神奇的Holmes就遇到过。在<a href="http://en.wikipedia.org/wiki/The_Adventure_of_the_Priory_School" target="_blank">The Adventure of the Priory School</a>中，Homle在处理这件事时稀奇地犯下错误，引用维基里的评论:“There is a rare example of Sherlock Holmes being illogical in this short story: When he finds the bicycle tracks in the moor, he states that it is possible to tell the direction the bicycle was going from the fact that the rear tire track is crossing (and covering) the track of the front tire. In fact, this is always so, no matter which direction the bicycle is going, unless it is being pulled backwards.”

仅从自行车留在路上的踪迹分析，你可以确定哪个方向是车行驶的方向吗？</div>
只要认识到两点：

1、任何时候自行车的两轮在地面的接触点距离d保持不变；

2、后轮与地面的接触点的绝对速度总是指向当时前轮与地面接触点的，也就是说后轮轨迹曲线上每一点与该点切线与前轮轨迹曲线的附近的某一个交点对应同一个时刻。

可以证明后轮轨迹曲线总是穿过前轮轨迹曲线的，基于这点很容易区分前轮轨迹曲线和后轮轨迹曲线（区分不出也没关系）。在一轨迹曲线上随机取两点A、C作两切线，交另一轮轨迹曲线于附近的B、D、E、F。若线段AB长度等于线段CD长度，则自行车当时行驶的方向为从A到B；若AE长度等于CF，则方向为A到E。第一条为后轮轨迹曲线。若都不相等，则第二条为后轮轨迹曲线，再按以上方法重新作切线就可以得出方向了。
<div><a href="http://hmgle.com/wp-content/uploads/2008/04/cross2.jpg"><img class="alignnone size-full wp-image-281" title="cross2" src="http://hmgle.com/wp-content/uploads/2008/04/cross2.jpg" alt="" width="447" height="299" /></a>

<a href="http://library.wolfram.com/explorations/explorer/Bicycle.html" target="_blank">http://library.wolfram.com/explorations/explorer/Bicycle.html</a></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/02eeb58244b4ff81f703a6a5.jpg"/><br/>
      有时候某些人不得不费尽心思地从一些被常人所忽略的迹象里寻找出过去隐藏的真相，例如从路面车子留下的踪迹来判断车行驶的方向，神奇的Holmes就遇到过。在<a target="_blank" href="http://en.wikipedia.org/wiki/The_Adventure_of_the_Priory_School">The Adventure of the Priory School</a>中，Homle在处理这件事时稀奇地犯下错误，引用维基里的评论:“There is a rare example of Sherlock Holmes being illogical in this short story: When he finds the bicycle tracks in the moor, he states that it is possible to tell the direction the bicycle was going from the fact that the rear tire track is crossing (and covering) the track of the front tire. In fact, this is always so, no matter which direction the bicycle is going, unless it is being pulled backwards.”<br/>
      仅从自行车留在路上的踪迹分析，你可以确定哪个方向是车行驶的方向吗？</div>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
只要认识到两点：<br/>
      1、任何时候自行车的两轮在地面的接触点距离d保持不变；<br/>
      2、后轮与地面的接触点的绝对速度总是指向当时前轮与地面接触点的，也就是说后轮轨迹曲线上每一点与该点切线与前轮轨迹曲线的附近的某一个交点对应同一个时刻。<br/>
      可以证明后轮轨迹曲线总是穿过前轮轨迹曲线的，基于这点很容易区分前轮轨迹曲线和后轮轨迹曲线（区分不出也没关系）。在一轨迹曲线上随机取两点A、C作两切线，交另一轮轨迹曲线于附近的B、D、E、F。若线段AB长度等于线段CD长度，则自行车当时行驶的方向为从A到B；若AE长度等于CF，则方向为A到E。第一条为后轮轨迹曲线。若都不相等，则第二条为后轮轨迹曲线，再按以上方法重新作切线就可以得出方向了。
<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/aa046d6607debc35aa184cb7.jpg"/><br/><br/><a href="http://library.wolfram.com/explorations/explorer/Bicycle.html" target="_blank">http://library.wolfram.com/explorations/explorer/Bicycle.html</a></div>]]></excerpt:encoded>
		<wp:post_id>36</wp:post_id>
		<wp:post_date>2008-04-03 17:06:00</wp:post_date>
		<wp:post_date_gmt>2008-04-03 17:06:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e9%9a%8f%e6%9c%ba%e8%bd%a6%e8%be%99%e9%87%8c%e9%9a%90%e8%97%8f%e7%9a%84%e6%96%b9%e5%90%91</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e8%b6%a3%e9%a2%98"><![CDATA[趣题]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>不相容——上一篇之纠正</title>
		<link>http://hmgle.com/archives/37</link>
		<pubDate>Sun, 30 Mar 2008 23:48:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/37</guid>
		<description></description>
		<content:encoded><![CDATA[<font size="3">  出自Zbigniew Michalewicz与David B. Fogel合著的《如何求解问题——现代启发式方法》的“绳子有多长”的问题（<a href="http://hi.baidu.com/hmgle/blog/item/3a6e66ee960f6dffb3fb9504.html" target="_blank">见上一篇</a>），经重做得出是题目有误的结论。在此对之前的武断感到惭愧：我根本没有计算就根据作者得出唯一解的这个错误事实和而得出“它的系数矩阵和增广矩阵的秩相等且等于9”的结论。<br/><br/>
  这道题不知是翻译有误还是原来就有问题（如第二段“当处于猴妈妈的过去年龄时，猴妈妈的年龄是前一段中猴子的年龄的3倍”和第三段“当处于猴妈妈的过去年龄时，猴妈妈的年龄是第一段中猴子年龄的3倍”明显重复。而且，如果按照书中的解法：<br/>
     变量：<br/>
          x —— 猴子的年龄<br/>
          y —— 猴哥哥的年龄<br/>
          z —— 猴妈妈的年龄<br/>
          W —— 重物的重量<br/>
          r —— 绳子的长度<br/>
          A，B，C，D —— 某年龄间隔<br/>
     方程：<br/>
          z - y = y - x<br/>
          z - A = 2 * (x - A)<br/>
          z - A = 0.5 * (x + B)<br/>
          x + B = 3 * (z - C)<br/>
          z - C = 3 * x<br/>
          W - r/4 = x - A<br/>
          z - A = 2 * (y - A)<br/>
          z - B = 0.5 * (y + C)<br/>
          y + C = 3 * (z - D)<br/>
          z - D = 3 * x<br/>
          x + z = 4<br/>
          W + r/4 = 3 * z/2<br/>
     得到齐次线性方程组系数矩阵为<br/>
          [-3 ,  0 ,  1 ,  0 ,  0 ,  0 , -1 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [1 ,  0 ,  1 ,  0 ,  0 ,  0 ,  0 ,  0 , 0]<br/>
                 [                                         ]<br/>
                 [1 ,  -2 ,  1 ,  0 ,  0 ,  0 ,  0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [0 ,  1 ,  -3 ,  0 ,  0 ,  1 ,  3 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [-2 ,  0 ,  1 ,  1 ,  0 ,  0 ,  0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [-0.5 , 0 , 1 , -1 , -0.5 , 0 , 0 , 0 , 0]<br/>
             A = [                                         ]<br/>
                 [-3 ,  0 ,  1 ,  0 ,  0 ,  -1 , 0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [-1 ,  0 ,  0 ,  1 , 0 , 0 , 0 , 1 , -1/4]<br/>
                 [                                         ]<br/>
                 [0 ,  -2 ,  1 ,  -1 ,  2 ,  0 , 0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [0 , -0.5 , 1 , 0 , -1 , -0.5 , 0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [1 ,  0 ,  -3 ,  0 ,  1 ,  3 ,  0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [0 ,  0 ,  -3/2 , 0 , 0 , 0 , 0 , 1 , 1/4]<br/>
     它的秩为 rank(A) = 9,<br/>
     增广矩阵为<br/>
          [-3 ,  0 ,  1 ,  0 ,  0 ,  0 ,  -1 ,  0 , 0 , 0]<br/>
          [                                               ]<br/>
          [1 ,  0 ,  1 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  4]<br/>
          [                                               ]<br/>
          [1 ,  -2 ,  1 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , 0]<br/>
          [                                               ]<br/>
          [0 ,  1 ,  -3 ,  0 ,  0 ,  1 ,  3 ,  0 ,  0 , 0]<br/>
          [                                               ]<br/>
          [-2 ,  0 ,  1 ,  1 ,  0 ,  0 ,  0 ,  0 ,  0 , 0]<br/>
          [                                               ]<br/>
          [-0.5 , 0 , 1 , -1 , -0.5 , 0 , 0 , 0 , 0 , -0.]<br/>
          B = [                                               ]<br/>
          [-3 ,  0 ,  1 ,  0 ,  0 ,  -1 ,  0 ,  0 , 0 , 0]<br/>
          [                                               ]<br/>
          [-1 ,  0 ,  0 ,  1 ,  0 ,  0 , 0 , 1 , -1/4 , 0]<br/>
          [                                               ]<br/>
          [0 ,  -2 ,  1 ,  -1 ,  2 ,  0 ,  0 ,  0 , 0 , 0]<br/>
          [                                               ]<br/>
          [0 , -0.5 , 1 , 0 , -1 , -0.5 , 0 , 0 , 0 , -0.]<br/>
          [                                               ]<br/>
          [1 ,  0 ,  -3 ,  0 ,  1 ,  3 ,  0 ,  0 ,  0 , 0]<br/>
          [                                               ]<br/>
          [0 ,  0 ,  -3/2 ,  0 ,  0 , 0 , 0 , 1 , 1/4 , 0]<br/>
     增广矩阵的秩为 rank(B) = 10。<br/>
     方程组不相容，无解。<br/>
     另：当方程组不相容时，用Maple求最小二乘解x，即使得向量Ax - b的模的值最小，为          <br/><br/>
          leastsqrs(A, b,'optimize')<br/>
          A —— matrix<br/>
          b —— vector<br/><br/></font>]]></content:encoded>
		<excerpt:encoded><![CDATA[<font size="3">  出自Zbigniew Michalewicz与David B. Fogel合著的《如何求解问题——现代启发式方法》的“绳子有多长”的问题（<a href="http://hi.baidu.com/hmgle/blog/item/3a6e66ee960f6dffb3fb9504.html" target="_blank">见上一篇</a>），经重做得出是题目有误的结论。在此对之前的武断感到惭愧：我根本没有计算就根据作者得出唯一解的这个错误事实和而得出“它的系数矩阵和增广矩阵的秩相等且等于9”的结论。<br/><br/>
  这道题不知是翻译有误还是原来就有问题（如第二段“当处于猴妈妈的过去年龄时，猴妈妈的年龄是前一段中猴子的年龄的3倍”和第三段“当处于猴妈妈的过去年龄时，猴妈妈的年龄是第一段中猴子年龄的3倍”明显重复。而且，如果按照书中的解法：<br/>
     变量：<br/>
          x —— 猴子的年龄<br/>
          y —— 猴哥哥的年龄<br/>
          z —— 猴妈妈的年龄<br/>
          W —— 重物的重量<br/>
          r —— 绳子的长度<br/>
          A，B，C，D —— 某年龄间隔<br/>
     方程：<br/>
          z - y = y - x<br/>
          z - A = 2 * (x - A)<br/>
          z - A = 0.5 * (x + B)<br/>
          x + B = 3 * (z - C)<br/>
          z - C = 3 * x<br/>
          W - r/4 = x - A<br/>
          z - A = 2 * (y - A)<br/>
          z - B = 0.5 * (y + C)<br/>
          y + C = 3 * (z - D)<br/>
          z - D = 3 * x<br/>
          x + z = 4<br/>
          W + r/4 = 3 * z/2<br/>
     得到齐次线性方程组系数矩阵为<br/>
          [-3 ,  0 ,  1 ,  0 ,  0 ,  0 , -1 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [1 ,  0 ,  1 ,  0 ,  0 ,  0 ,  0 ,  0 , 0]<br/>
                 [                                         ]<br/>
                 [1 ,  -2 ,  1 ,  0 ,  0 ,  0 ,  0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [0 ,  1 ,  -3 ,  0 ,  0 ,  1 ,  3 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [-2 ,  0 ,  1 ,  1 ,  0 ,  0 ,  0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [-0.5 , 0 , 1 , -1 , -0.5 , 0 , 0 , 0 , 0]<br/>
             A = [                                         ]<br/>
                 [-3 ,  0 ,  1 ,  0 ,  0 ,  -1 , 0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [-1 ,  0 ,  0 ,  1 , 0 , 0 , 0 , 1 , -1/4]<br/>
                 [                                         ]<br/>
                 [0 ,  -2 ,  1 ,  -1 ,  2 ,  0 , 0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [0 , -0.5 , 1 , 0 , -1 , -0.5 , 0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [1 ,  0 ,  -3 ,  0 ,  1 ,  3 ,  0 , 0 , 0]<br/>
                 [                                         ]<br/>
                 [0 ,  0 ,  -3/2 , 0 , 0 , 0 , 0 , 1 , 1/4]<br/>
     它的秩为 rank(A) = 9,<br/>
     增广矩阵为<br/>
          [-3 ,  0 ,  1 ,  0 ,  0 ,  0 ,  -1 ,  0 , 0 , 0]<br/>
          [                                               ]<br/>
          [1 ,  0 ,  1 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  4]<br/>
          [                                               ]<br/>
          [1 ,  -2 ,  1 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , 0]<br/>
          [                                               ]<br/>
          [0 ,  1 ,  -3 ,  0 ,  0 ,  1 ,  3 ,  0 ,  0 , 0]<br/>
          [                                               ]<br/>
          [-2 ,  0 ,  1 ,  1 ,  0 ,  0 ,  0 ,  0 ,  0 , 0]<br/>
          [                                               ]<br/>
          [-0.5 , 0 , 1 , -1 , -0.5 , 0 , 0 , 0 , 0 , -0.]<br/>
          B = [                                               ]<br/>
          [-3 ,  0 ,  1 ,  0 ,  0 ,  -1 ,  0 ,  0 , 0 , 0]<br/>
          [                                               ]<br/>
          [-1 ,  0 ,  0 ,  1 ,  0 ,  0 , 0 , 1 , -1/4 , 0]<br/>
          [                                               ]<br/>
          [0 ,  -2 ,  1 ,  -1 ,  2 ,  0 ,  0 ,  0 , 0 , 0]<br/>
          [                                               ]<br/>
          [0 , -0.5 , 1 , 0 , -1 , -0.5 , 0 , 0 , 0 , -0.]<br/>
          [                                               ]<br/>
          [1 ,  0 ,  -3 ,  0 ,  1 ,  3 ,  0 ,  0 ,  0 , 0]<br/>
          [                                               ]<br/>
          [0 ,  0 ,  -3/2 ,  0 ,  0 , 0 , 0 , 1 , 1/4 , 0]<br/>
     增广矩阵的秩为 rank(B) = 10。<br/>
     方程组不相容，无解。<br/>
     另：当方程组不相容时，用Maple求最小二乘解x，即使得向量Ax - b的模的值最小，为          <br/><br/>
          leastsqrs(A, b,'optimize')<br/>
          A —— matrix<br/>
          b —— vector<br/><br/></font>]]></excerpt:encoded>
		<wp:post_id>37</wp:post_id>
		<wp:post_date>2008-03-30 23:48:00</wp:post_date>
		<wp:post_date_gmt>2008-03-30 23:48:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%8d%e7%9b%b8%e5%ae%b9%e2%80%94%e2%80%94%e4%b8%8a%e4%b8%80%e7%af%87%e4%b9%8b%e7%ba%a0%e6%ad%a3</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e8%b6%a3%e9%a2%98"><![CDATA[趣题]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>再来一道有关猴子、绳子的趣题</title>
		<link>http://hmgle.com/archives/38</link>
		<pubDate>Fri, 11 Jan 2008 23:31:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/38</guid>
		<description></description>
		<content:encoded><![CDATA[<font size="3">       在Zbigniew Michalewicz与David B. Fogel合著的《如何求解问题--现代启发式方法》（中译本）里看到的一道趣题：<br/>
       一根绳子绕过滑轮，一端是一只猴子，另一端是一个重物，绳子的两端保持平衡。绳子的重量是每英尺四分之一磅，猴子与猴妈妈的年龄之和为4，猴子的重量加上绳子的重量等于猴妈妈的1.5倍。<br/>
       重物的重量超过绳子的重量的磅数等于猴子的过去年龄：当处于猴子的过去年龄时，猴妈妈的年龄等于猴哥哥的过去年龄的两倍；当处于猴哥哥的过去年龄时，猴妈妈的年龄是猴哥哥的将来年龄的1/2；当处于猴哥哥的将来年龄时，猴哥哥的年龄是猴妈妈的过去年龄的3倍；当处于猴妈妈的过去年龄时，猴妈妈的年龄是前一段中猴子的年龄的3倍。<br/>
       （你明白了我们所说的“事情并非总是直接了当的”这句话的含义了吧？）<br/>
       猴妈妈的过去年龄是猴子的过去年龄的2倍；当处于猴子的过去年龄时，猴妈妈的年龄是猴子的将来年龄的1/2；当处于猴子的将来年龄时，猴子的年龄是猴妈妈的过去年龄的3倍；当处于猴妈妈的过去年龄时，猴妈妈的年龄是第一段中猴子年龄的3倍。<br/>
       猴妈妈超过猴哥哥的年龄数等于猴哥哥超过猴子的年龄数。<br/>
       问题是：这根绳子有多长？</font><font size="3">（这个问题中的未知数可以不必为整数，猴子的年龄可能如10/3之类的分数）<br/>
       条件很多，需要足够耐心。<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
其实没什么技巧这题，将所有的信息翻译成等式就是了，引入9个变量，得到包含12个方程的非齐次线性方程组，它的系数矩阵和增广矩阵的秩相等且等于9，所以有唯一解。不过不能直接用Maple等数学符号软件求解，我用maple（d版）、maxima试过都不行，mathematica没试过,不知道为什么。所以只好手算了。最后答案为绳长12/17英尺。<br/>
另外发现该书第34页的解答是错误的（我看的是第一版）。<br/></font><font size="3"><br/></font>]]></content:encoded>
		<excerpt:encoded><![CDATA[<font size="3">       在Zbigniew Michalewicz与David B. Fogel合著的《如何求解问题--现代启发式方法》（中译本）里看到的一道趣题：<br/>
       一根绳子绕过滑轮，一端是一只猴子，另一端是一个重物，绳子的两端保持平衡。绳子的重量是每英尺四分之一磅，猴子与猴妈妈的年龄之和为4，猴子的重量加上绳子的重量等于猴妈妈的1.5倍。<br/>
       重物的重量超过绳子的重量的磅数等于猴子的过去年龄：当处于猴子的过去年龄时，猴妈妈的年龄等于猴哥哥的过去年龄的两倍；当处于猴哥哥的过去年龄时，猴妈妈的年龄是猴哥哥的将来年龄的1/2；当处于猴哥哥的将来年龄时，猴哥哥的年龄是猴妈妈的过去年龄的3倍；当处于猴妈妈的过去年龄时，猴妈妈的年龄是前一段中猴子的年龄的3倍。<br/>
       （你明白了我们所说的“事情并非总是直接了当的”这句话的含义了吧？）<br/>
       猴妈妈的过去年龄是猴子的过去年龄的2倍；当处于猴子的过去年龄时，猴妈妈的年龄是猴子的将来年龄的1/2；当处于猴子的将来年龄时，猴子的年龄是猴妈妈的过去年龄的3倍；当处于猴妈妈的过去年龄时，猴妈妈的年龄是第一段中猴子年龄的3倍。<br/>
       猴妈妈超过猴哥哥的年龄数等于猴哥哥超过猴子的年龄数。<br/>
       问题是：这根绳子有多长？</font><font size="3">（这个问题中的未知数可以不必为整数，猴子的年龄可能如10/3之类的分数）<br/>
       条件很多，需要足够耐心。<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
其实没什么技巧这题，将所有的信息翻译成等式就是了，引入9个变量，得到包含12个方程的非齐次线性方程组，它的系数矩阵和增广矩阵的秩相等且等于9，所以有唯一解。不过不能直接用Maple等数学符号软件求解，我用maple（d版）、maxima试过都不行，mathematica没试过,不知道为什么。所以只好手算了。最后答案为绳长12/17英尺。<br/>
另外发现该书第34页的解答是错误的（我看的是第一版）。<br/></font><font size="3"><br/></font>]]></excerpt:encoded>
		<wp:post_id>38</wp:post_id>
		<wp:post_date>2008-01-11 23:31:00</wp:post_date>
		<wp:post_date_gmt>2008-01-11 23:31:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%86%8d%e6%9d%a5%e4%b8%80%e9%81%93%e6%9c%89%e5%85%b3%e7%8c%b4%e5%ad%90%e3%80%81%e7%bb%b3%e5%ad%90%e7%9a%84%e8%b6%a3%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e8%b6%a3%e9%a2%98"><![CDATA[趣题]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>另一种方式思考猴子爬绳趣题</title>
		<link>http://hmgle.com/archives/39</link>
		<pubDate>Mon, 07 Jan 2008 23:09:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/39</guid>
		<description></description>
		<content:encoded><![CDATA[<div>
<div></div>
<span style="font-size: small;"><a href="http://www.szkp.org.cn/shuxueshijie/funquestion/1-22-1.htm"><img class="alignnone size-full wp-image-284" title="monkey" src="http://hmgle.com/wp-content/uploads/2008/01/monkey.jpg" alt="" width="200" height="181" /></a></span>

</div>
<span style="font-size: small;">据说是写《爱丽丝漫游奇境记》的牛津大学数学家刘易斯·卡罗尔提出的趣题：设一绳子挂在一个无摩擦力的滑轮上，绳的一端悬挂一砝码，它正好与紧抓在绳子另一端的猴子相平衡。假设这猴子开始向上爬，将有什么结果？

下面的话是否真实已无从考证：</span>
<div align="left"><span style="font-size: x-small;"><em><span style="font-family: 楷体_GB2312; font-size: small;">"真奇怪，"卡罗尔写道，"许多优秀的数学家给出了截然不同的答案。普赖斯认为砝码将向上升，而且速度越来越快。克利夫顿(还有哈考特)则认为，砝码将以与猴子一样的速度向上升起，然而桑普森却说，砝码将会向下降!"

一位杰出的机械工程师说"这不会比苍蝇在绳子上爬更起作用"，而一位科学家却认为"砝码的上升或下降将取决于猴子 吃苹果速度的倒数"，然而还得从中求出猴子尾巴的平方根。严肃地说，这道题目非常有趣，值得认真推敲。它很能说明趣题与力学问题之间的紧密联系。</span>

</em><span style="font-size: small;">但是在经典力学普及的今天如果忽略滑轮与绳子的重量应该是很容易得出答案的。

作用于猴子的向上的合力是T-W，W是猴子的重量，T是猴子那端的绳子张力，作用于砝码上的向上的合力是T'-W'，T'是平衡物那边的那部分绳子的张力，W'是砝码的重量，T=T'，由题干可知W=W',作用在猴子上的向上的合力等于砝码上向上的合力，这两个物体的加速度在任意时刻都是相等的。假设两物体从停在一水平线上开始运动，则它们始终保持在一水平线上，这是由绳子张力处处相等决定的。


我们可以用另一种方式思考：把滑轮转化为光滑的水平面，问题等价于在光滑水平面上通过绳子或轻质杆连接的两个相同质量的小球，由动量守恒定律很容易得出两小球任意时刻的位移相反。因为整体质心守恒。

如果记入滑轮的重量（仍省略绳子的重量），将要用到转动方程，结果是砝码上升的距离等于猴子上升的距离的一半。
</span></span></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[<div forimg="1">
<div forimg="1"><a href="http://www.szkp.org.cn/shuxueshijie/funquestion/1-22-1.htm" target="_blank"><img border="0" src="http://hiphotos.baidu.com/hmgle/abpic/item/14036e3d7851dae03c6d97aa.jpg" small="1" class="blogimg"/></a></div>
<font size="3"><br/></font></div>
<font size="3">据说是写《爱丽丝漫游奇境记》的牛津大学数学家刘易斯·卡罗尔提出的趣题：设一绳子挂在一个无摩擦力的滑轮上，绳的一端悬挂一砝码，它正好与紧抓在绳子另一端的猴子相平衡。假设这猴子开始向上爬，将有什么结果？<br/>
下面的话是否真实已无从考证：</font><br/><div align="left"><font size="2"><em><font size="3" face="楷体_GB2312">"真奇怪，"卡罗尔写道，"许多优秀的数学家给出了截然不同的答案。普赖斯认为砝码将向上升，而且速度越来越快。克利夫顿(还有哈考特)则认为，砝码将以与猴子一样的速度向上升起，然而桑普森却说，砝码将会向下降!"<br/>
一位杰出的机械工程师说"这不会比苍蝇在绳子上爬更起作用"，而一位科学家却认为"砝码的上升或下降将取决于猴子 吃苹果速度的倒数"，然而还得从中求出猴子尾巴的平方根。严肃地说，这道题目非常有趣，值得认真推敲。它很能说明趣题与力学问题之间的紧密联系。</font><br/><br/></em><font size="3">但是在经典力学普及的今天如果忽略滑轮与绳子的重量应该是很容易得出答案的。<br/>
作用于猴子的向上的合力是T-W，W是猴子的重量，T是猴子那端的绳子张力，作用于砝码上的向上的合力是T'-W'，T'是平衡物那边的那部分绳子的张力，W'是砝码的重量，T=T'，由题干可知W=W',作用在猴子上的向上的合力等于砝码上向上的合力，这两个物体的加速度在任意时刻都是相等的。假设两物体从停在一水平线上开始运动，则它们始终保持在一水平线上，这是由绳子张力处处相等决定的。<br/><br/>
我们可以用另一种方式思考：把滑轮转化为光滑的水平面，问题等价于在光滑水平面上通过绳子或轻质杆连接的两个相同质量的小球，由动量守恒定律很容易得出两小球任意时刻的位移相反。因为整体质心守恒。<br/>
如果记入滑轮的重量（仍省略绳子的重量），将要用到转动方程，结果是砝码上升的距离等于猴子上升的距离的一半。<br/></font></font></div>]]></excerpt:encoded>
		<wp:post_id>39</wp:post_id>
		<wp:post_date>2008-01-07 23:09:00</wp:post_date>
		<wp:post_date_gmt>2008-01-07 23:09:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%8f%a6%e4%b8%80%e7%a7%8d%e6%96%b9%e5%bc%8f%e6%80%9d%e8%80%83%e7%8c%b4%e5%ad%90%e7%88%ac%e7%bb%b3%e8%b6%a3%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e8%b6%a3%e9%a2%98"><![CDATA[趣题]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>hmgle可能是不可调和的右脑活跃分子</title>
		<link>http://hmgle.com/archives/40</link>
		<pubDate>Mon, 31 Dec 2007 21:38:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/40</guid>
		<description></description>
		<content:encoded><![CDATA[<div>
<div></div>
<a href="http://hmgle.com/wp-content/uploads/2007/12/woman_spin.gif"><img class="alignnone size-full wp-image-286" title="woman_spin" src="http://hmgle.com/wp-content/uploads/2007/12/woman_spin.gif" alt="" width="300" height="400" /></a>
看到上面的图出自<a href="http://www.news.com.au/perthnow/story/0,21598,22492511-5005375,00.html">http://www.news.com.au/perthnow/story/0,21598,22492511-5005375,00.html</a>

图片地址:http://www.news.com.au/common/imagedata/0,,5675247,00.gif

你看到mm是顺时针旋转还是逆时针旋转？如果顺时针，你的右脑可能更活跃，逆时针的话你的左脑可能更活跃。大部分的人看到的是逆时针旋转尽管下意识地试图强迫自己向顺时针方向看。

左脑功能（特点）          右脑特点（功能）

逻辑的                    直觉的

把握事物细节的            看事物整体的

现实的                    想象的

掌管文字和语言能力        掌管图像和想象能力

向过去看的                向未来看的

数学和科学                哲学和宗教

可理解的(can comprehend) can "get it" (i.e. meaning)

知识                      信仰

稳健的                    冒险的

实际的                    冲动的

制定策略                  幻想的

对着mm盯半天怎么看都是顺时针转，理所当然属于右脑活跃分子了。不过令人奇怪的是我知道你可以把自己的影子看成是正面对向你的也可以把它看成是背向你的（来源于小时候停电时点蜡烛的顿悟），如果把mm头向右偏时的状态看成是mm背向你的话你看到的是顺时针，看成是面向你的话看到的是逆时针，我在mm静止时完全可以在面对我还是背向我两种情况间转换，但mm一旋转我就不行了，只能看到顺时针了。少部分人看旋转的mm也能在顺逆转动间自由转换，这种境界是我等凡人望尘莫及的。

更新: 科学控告诉我们: 这跟左右脑完全没有联系. 见<a href="http://mindhacks.cn/">刘未鹏</a>的<a title="逃出你的肖申克（二）：仁者见仁智者见智？从视觉错觉到偏见" href="http://mindhacks.cn/2009/03/15/preconception-explained/">逃出你的肖申克（二）：仁者见仁智者见智？从视觉错觉到偏见</a>.

</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p> </p>
<div forimg="1">
<p> </p>
<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/c8fe0afa3d55cc989f5146c7.jpg" small="0" class="blogimg"/></div>
<br/>
看到上面的图出自<a href="http://www.news.com.au/perthnow/story/0,21598,22492511-5005375,00.html">http://www.news.com.au/perthnow/story/0,21598,22492511-5005375,00.html</a><br/>
图片地址:http://www.news.com.au/common/imagedata/0,,5675247,00.gif<br/>
你看到mm是顺时针旋转还是逆时针旋转？如果顺时针，你的右脑可能更活跃，逆时针的话你的左脑可能更活跃。大部分的人看到的是逆时针旋转尽管下意识地试图强迫自己向顺时针方向看。
<p> </p>
<p>左脑功能（特点）            右脑特点（功能）<br/>
逻辑的                      直觉的<br/>
把握事物细节的              看事物整体的<br/>
现实的                      想象的<br/>
掌管文字和语言能力          掌管图像和想象能力<br/>
向过去看的                  向未来看的<br/>
数学和科学                  哲学和宗教<br/>
可理解的(can comprehend)  can "get it" (i.e. meaning)<br/>
知识                        信仰<br/>
稳健的                      冒险的<br/>
实际的                      冲动的<br/>
制定策略                    幻想的</p>
<p>对着mm盯半天怎么看都是顺时针转，理所当然属于右脑活跃分子了。不过令人奇怪的是我知道你可以把自己的影子看成是正面对向你的也可以把它看成是背向你的（来源于小时候停电时点蜡烛的顿悟），如果把mm头向右偏时的状态看成是mm背向你的话你看到的是顺时针，看成是面向你的话看到的是逆时针，我在mm静止时完全可以在面对我还是背向我两种情况间转换，但mm一旋转我就不行了，只能看到顺时针了。少部分人看旋转的mm也能在顺逆转动间自由转换，这种境界是我等凡人望尘莫及的。</p>
</div>]]></excerpt:encoded>
		<wp:post_id>40</wp:post_id>
		<wp:post_date>2007-12-31 21:38:00</wp:post_date>
		<wp:post_date_gmt>2007-12-31 21:38:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hmgle%e5%8f%af%e8%83%bd%e6%98%af%e4%b8%8d%e5%8f%af%e8%b0%83%e5%92%8c%e7%9a%84%e5%8f%b3%e8%84%91%e6%b4%bb%e8%b7%83%e5%88%86%e5%ad%90</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%bc%aa%e7%a7%91%e5%ad%a6"><![CDATA[伪科学]]></category>
		<category domain="post_tag" nicename="%e5%a8%b1%e4%b9%90"><![CDATA[娱乐]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e6%b5%81%e8%a8%80"><![CDATA[流言]]></category>
		<category domain="category" nicename="%e9%80%90%e6%b5%aa"><![CDATA[逐浪]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>极限叠木块</title>
		<link>http://hmgle.com/archives/41</link>
		<pubDate>Tue, 18 Dec 2007 23:55:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/41</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="margin-bottom: 0cm;">    先来看一道中学物理题：把<span style="font-family: 'Times New Roman', serif;"><em>n</em></span>块完全相同的光滑的均质木块叠放在桌子边缘，要木块伸出桌子边缘最多，木块应如何叠放？木块伸出桌子边缘的最大水平距离是多少（设木块最长边为<span style="font-family: 'Times New Roman', serif;">1</span>，不考虑斜着放）？

传统的解法是从最顶端考虑，要使最顶端木块刚好不倒，最顶端的木块的重心必须位于次顶端的木块的边缘延长线上，己顶端伸出次顶端木块的最大长度为<span style="font-family: 'Times New Roman', serif;">1/2</span>。依次类推，次顶端离下面的木块最大长度为<span style="font-family: 'Times New Roman', serif;">1/4</span>。以后的依次为<span style="font-family: 'Times New Roman', serif;">1/6</span>，<span style="font-family: 'Times New Roman', serif;">1/8</span>，…，<span style="font-family: 'Times New Roman', serif;">1/<em>n</em></span>。求和约为<span style="font-family: 'Times New Roman', serif;">(1/2)<span style="font-style: normal;"><strong>ln </strong></span><em><span>n.</span></em></span><span style="font-style: normal;"><span>一个结论是只要给定足够的木块，可以达到任意长度，因为调和级数是发散的。图中给出了</span></span><span style="font-family: 'Times New Roman', serif;"><em><span>n</span></em></span><em><span>＝</span></em><span style="font-family: 'Times New Roman', serif;"><span style="font-style: normal;"><span>10</span></span></span><span style="font-style: normal;"><span>的情况。
<a href="http://hmgle.com/wp-content/uploads/2007/12/block_0.jpg"><img class="alignnone size-full wp-image-290" title="block_0" src="http://hmgle.com/wp-content/uploads/2007/12/block_0.jpg" alt="" width="407" height="294" /></a></span></span></p>
<p style="margin-bottom: 0cm; font-style: normal;">    这类求叠放物体伸长的最大长度的题的历史可以追溯到<span style="font-family: 'Times New Roman', serif;">19</span>世纪中期，之后被许多人津津乐道，频繁地出现在各种娱乐杂志、报刊等，一般叫做<span style="font-family: 'Times New Roman', serif;">overhang</span>问题。题目或者限定了木块（书本，砖块等）叠放形式，或者暗示了一层只放一块木块（书本，砖块等），几乎所有人都对这个最佳摆放形式深信不疑，直到<span style="font-family: 'Times New Roman', serif;">20</span>世纪五十年代陆续有<span style="font-family: 'Times New Roman', serif;">Sutton [1], Drive [2], Ainley [3] </span>等突破一层放一块<span style="font-family: 'Times New Roman', serif;">(one-on-one)</span>模式并考虑了几种只有少量木块的情况下的最佳解。图中给出了<span style="font-family: 'Times New Roman', serif;">3</span>和<span style="font-family: 'Times New Roman', serif;">4</span>块时的摆放位置以及和传统式的对比。
<a href="http://hmgle.com/wp-content/uploads/2007/12/block_1.jpg"><img class="alignnone size-full wp-image-291" title="block_1" src="http://hmgle.com/wp-content/uploads/2007/12/block_1.jpg" alt="" width="644" height="340" /></a></p>

<div align="left"></div>
<p style="margin-bottom: 0cm;"><span style="font-style: normal;"><span>    最近，</span></span><span style="font-family: 'Times New Roman', serif;"><span style="font-style: normal;"><span>Hall [4] </span></span></span><span style="font-style: normal;"><span>用所谓的</span></span><span style="font-family: 'Times New Roman', serif;">multiwide stacks</span>模式将问题提高到一个层次，并给出了一系列未经证明的但被作者声称的最佳解。遗憾的是当<span style="font-family: 'Times New Roman', serif;">n</span>大于十九时他的解答被<span style="font-family: 'Times New Roman', serif;">Mike Paterson</span>和<span style="font-family: 'Times New Roman', serif;">Uri Zwick</span>等牛人否定了<span style="font-family: 'Times New Roman', serif;">[5]</span>。<span style="font-family: 'Times New Roman', serif;">Mike Paterson</span>等人引入了一些定义：将所有的木块分为支柱部分<span style="font-family: 'Times New Roman', serif;">(support set)</span>（<span>图中用浅色表示）</span>和平衡部分<span style="font-family: 'Times New Roman', serif;">(balancing set)</span><span>（图中用深色表示）</span>。支柱部分递归地定义为：<span style="font-family: 'Times New Roman', serif;">1</span>、伸出最外边缘的那个木块属于支柱部分；<span style="font-family: 'Times New Roman', serif;">2</span>、如果一个木块属于支柱部分，那么在它下面与它直接接触的木块也属于支柱部分。除支柱部分外余下的木块都属于平衡部分。如果达到最外边缘的木块及以下的每一层都只有一个木块属于支柱部分，就称该结构为凸起的<span style="font-family: 'Times New Roman', serif;">(spinal)</span>。从图中可以看到当<span style="font-family: 'Times New Roman', serif;">n</span>小于<span style="font-family: 'Times New Roman', serif;">20</span>时垒起的木块都是凸起<span style="font-family: 'Times New Roman', serif;">(spinal)</span>的，但令人惊讶的是当<span style="font-family: 'Times New Roman', serif;">n</span>大于等于<span style="font-family: 'Times New Roman', serif;">20</span>时最佳摆放位置不再是凸起<span style="font-family: 'Times New Roman', serif;">(spinal)</span>了，这也正是<span style="font-family: 'Times New Roman', serif;">Hall</span>错误的根源。图中给出了<span style="font-family: 'Times New Roman', serif;">n</span>＝<span style="font-family: 'Times New Roman', serif;">20</span>及<span style="font-family: 'Times New Roman', serif;">n</span>＝<span style="font-family: 'Times New Roman', serif;">30</span>时的摆放位置。但同样地，<span style="font-family: 'Times New Roman', serif;">Mike Paterson</span>和<span style="font-family: 'Times New Roman', serif;">Uri Zwick</span>给出的解答也是未能证明的，但作者确信不会有更好的结果了（也许你还能更牛地再次推翻他们的结论）。
<a href="http://hmgle.com/wp-content/uploads/2007/12/block_2.jpg"><img class="alignnone size-full wp-image-292" title="block_2" src="http://hmgle.com/wp-content/uploads/2007/12/block_2.jpg" alt="" width="954" height="517" /></a></p>

<div align="center"></div>
<div align="center"></div>
<p align="center"></p>
<p style="margin-bottom: 0cm;" align="left">    <a href="http://hmgle.com/wp-content/uploads/2007/12/block_3.jpg"><img class="alignnone size-full wp-image-294" title="block_3" src="http://hmgle.com/wp-content/uploads/2007/12/block_3.jpg" alt="" width="892" height="607" /></a>
<a href="http://hmgle.com/wp-content/uploads/2007/12/block_4.jpg"><img class="alignnone size-full wp-image-295" title="block_4" src="http://hmgle.com/wp-content/uploads/2007/12/block_4.jpg" alt="" width="803" height="356" /></a>
我们还可以让木块竖起来放，但这又依赖于木块比例了，问题将变得更加复杂。</p>
<p style="margin-bottom: 0cm;" align="left">来源：</p>
<p style="margin-bottom: 0cm;"><span style="font-family: 'Times New Roman', serif;">[1] <span style="font-family: CMR10;"><span style="font-size: x-small;">R. Sutton, A problem of balancing, </span></span><span style="font-family: CMTI10;"><span style="font-size: x-small;">Amer. J. Phys. </span></span><span style="font-family: CMBX10;"><span style="font-size: x-small;">23 </span></span><span style="font-family: CMR10;"><span style="font-size: x-small;">(1955) 547.
<span style="font-family: CMR10;"><span style="font-size: x-small;">[2]J. E. Hearnshaw and M. S. Paterson, Problems drive, <span style="font-family: CMTI10;">Eureka </span><span style="font-family: CMBX10;">27 </span>(1964) 6{8 and 39{40. Avail-</span></span><span style="font-family: CMR10;"><span style="font-size: x-small;">able at<span style="font-family: CMTT10;">     <a href="http://archim.org.uk/eureka/27/problems.html">http://archim.org.uk/eureka/27/problems.html</a> </span>and <span style="font-family: CMTT10;">.../27/solutions.html.
<span style="font-family: 'Times New Roman', serif;">[3]<span style="font-family: CMR10;"><span style="font-size: x-small;">S. Ainley, Finely balanced, </span></span><span style="font-family: CMTI10;"><span style="font-size: x-small;">Mathematical Gazette </span></span><span style="font-family: CMBX10;"><span style="font-size: x-small;">63 </span></span><span style="font-family: CMR10;"><span style="font-size: x-small;">(1979) 272.

[4]J. F. Hall, Fun with stacking blocks, Amer. J. Phys. 73 (2005) 1107{1116.

[5]<span style="font-family: CMR10;"><span style="font-size: x-small;">M. Paterson, Y. Peres, M. Thorup, P. Winkler, and U. Zwick, Maximum overhang, available </span></span><span style="font-family: CMR10;"><span style="font-size: x-small;">at <span style="font-family: CMTT10;">http://arXiv.org/pdf/0707.0093</span>. An extended abstract is to appear in <span style="font-family: CMTI10;">Proceedings of </span></span></span><span style="font-family: CMR10;"><span style="font-size: x-small;"><span style="font-family: CMTI10;">the 19th Annual ACM-SIAM Symposium on Discrete Algorithm (SODA'08)</span>.</span></span></span></span></span></span></span></span></span></span></span></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p style="margin-bottom: 0cm">     先来看一道中学物理题：把<font face="Times New Roman, serif"><em>n</em></font>块完全相同的光滑的均质木块叠放在桌子边缘，要木块伸出桌子边缘最多，木块应如何叠放？木块伸出桌子边缘的最大水平距离是多少（设木块最长边为<font face="Times New Roman, serif">1</font>，不考虑斜着放）？<br/>
     传统的解法是从最顶端考虑，要使最顶端木块刚好不倒，最顶端的木块的重心必须位于次顶端的木块的边缘延长线上，己顶端伸出次顶端木块的最大长度为<font face="Times New Roman, serif">1/2</font>。依次类推，次顶端离下面的木块最大长度为<font face="Times New Roman, serif">1/4</font>。以后的依次为<font face="Times New Roman, serif">1/6</font>，<font face="Times New Roman, serif">1/8</font>，…，<font face="Times New Roman, serif">1/<em>n</em></font>。求和约为<font face="Times New Roman, serif">(1/2)<span style="font-style: normal"><strong>ln </strong></span><em><span>n.</span></em></font><span style="font-style: normal"><span>一个结论是只要给定足够的木块，可以达到任意长度，因为调和级数是发散的。图中给出了</span></span><font face="Times New Roman, serif"><em><span>n</span></em></font><em><span>＝</span></em><font face="Times New Roman, serif"><span style="font-style: normal"><span>10</span></span></font><span style="font-style: normal"><span>的情况。<br/></span></span></p>
<p align="center" forimg="1"><img class="blogimg" style="width: 279px; height: 241px" height="216" width="257" border="0" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/c64d75eddd7147d9b21cb16e.jpg"/></p>
<p align="left" forimg="1"> </p>
<p style="margin-bottom: 0cm; font-style: normal">     这类求叠放物体伸长的最大长度的题的历史可以追溯到<font face="Times New Roman, serif">19</font>世纪中期，之后被许多人津津乐道，频繁地出现在各种娱乐杂志、报刊等，一般叫做<font face="Times New Roman, serif">overhang</font>问题。题目或者限定了木块（书本，砖块等）叠放形式，或者暗示了一层只放一块木块（书本，砖块等），几乎所有人都对这个最佳摆放形式深信不疑，直到<font face="Times New Roman, serif">20</font>世纪五十年代陆续有<font face="Times New Roman, serif">Sutton [1], Drive [2], Ainley [3] </font>等突破一层放一块<font face="Times New Roman, serif">(one-on-one)</font>模式并考虑了几种只有少量木块的情况下的最佳解。图中给出了<font face="Times New Roman, serif">3</font>和<font face="Times New Roman, serif">4</font>块时的摆放位置以及和传统式的对比。</p>
<div forimg="1" align="left">
<p><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/3a6e66ee2a6699f6b3fb9576.jpg"/></p>
<p> </p>
<p style="margin-bottom: 0cm"><span style="font-style: normal"><span>     最近，</span></span><font face="Times New Roman, serif"><span style="font-style: normal"><span>Hall [4] </span></span></font><span style="font-style: normal"><span>用所谓的</span></span><font face="Times New Roman, serif">multiwide stacks</font>模式将问题提高到一个层次，并给出了一系列未经证明的但被作者声称的最佳解。遗憾的是当<font face="Times New Roman, serif">n</font>大于十九时他的解答被<font face="Times New Roman, serif">Mike Paterson</font>和<font face="Times New Roman, serif">Uri Zwick</font>等牛人否定了<font face="Times New Roman, serif">[5]</font>。<font face="Times New Roman, serif">Mike Paterson</font>等人引入了一些定义：将所有的木块分为支柱部分<font face="Times New Roman, serif">(support set)</font>（<span>图中用浅色表示）</span>和平衡部分<font face="Times New Roman, serif">(balancing set)</font><span>（图中用深色表示）</span>。支柱部分递归地定义为：<font face="Times New Roman, serif">1</font>、伸出最外边缘的那个木块属于支柱部分；<font face="Times New Roman, serif">2</font>、如果一个木块属于支柱部分，那么在它下面与它直接接触的木块也属于支柱部分。除支柱部分外余下的木块都属于平衡部分。如果达到最外边缘的木块及以下的每一层都只有一个木块属于支柱部分，就称该结构为凸起的<font face="Times New Roman, serif">(spinal)</font>。从图中可以看到当<font face="Times New Roman, serif">n</font>小于<font face="Times New Roman, serif">20</font>时垒起的木块都是凸起<font face="Times New Roman, serif">(spinal)</font>的，但令人惊讶的是当<font face="Times New Roman, serif">n</font>大于等于<font face="Times New Roman, serif">20</font>时最佳摆放位置不再是凸起<font face="Times New Roman, serif">(spinal)</font>了，这也正是<font face="Times New Roman, serif">Hall</font>错误的根源。图中给出了<font face="Times New Roman, serif">n</font>＝<font face="Times New Roman, serif">20</font>及<font face="Times New Roman, serif">n</font>＝<font face="Times New Roman, serif">30</font>时的摆放位置。但同样地，<font face="Times New Roman, serif">Mike Paterson</font>和<font face="Times New Roman, serif">Uri Zwick</font>给出的解答也是未能证明的，但作者确信不会有更好的结果了（也许你还能更牛地再次推翻他们的结论）。</p>
<div forimg="1" align="center"><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/ae027c167633834721a4e97c.jpg"/></div>
<div forimg="1" align="center"><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/e0faad45679018328694737b.jpg"/></div>
<p align="center" forimg="1"><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/8b249e44fd28958fb3b7dc47.jpg"/></p>
<p align="left" forimg="1"> </p>
<p style="margin-bottom: 0cm" align="left" forimg="1">     我们还可以让木块竖起来放，但这又依赖于木块比例了，问题将变得更加复杂。</p>
<p style="margin-bottom: 0cm" align="left" forimg="1">来源：</p>
<p style="margin-bottom: 0cm"><font face="Times New Roman, serif">[1] <font face="CMR10"><font style="font-size: 11pt" size="2">R. Sutton, A problem of balancing, </font></font><font face="CMTI10"><font style="font-size: 11pt" size="2">Amer. J. Phys. </font></font><font face="CMBX10"><font style="font-size: 11pt" size="2">23 </font></font><font face="CMR10"><font style="font-size: 11pt" size="2">(1955) 547.<br/><font face="CMR10"><font style="font-size: 11pt" size="2">[2]J. E. Hearnshaw and M. S. Paterson, Problems drive, <font face="CMTI10">Eureka </font><font face="CMBX10">27 </font>(1964) 6{8 and 39{40. Avail-</font></font><font face="CMR10"><font style="font-size: 11pt" size="2">able at<font face="CMTT10">      <a href="http://archim.org.uk/eureka/27/problems.html">http://archim.org.uk/eureka/27/problems.html</a> </font>and <font face="CMTT10">.../27/solutions.html.<br/><font face="Times New Roman, serif">[3]<font face="CMR10"><font style="font-size: 11pt" size="2">S. Ainley, Finely balanced, </font></font><font face="CMTI10"><font style="font-size: 11pt" size="2">Mathematical Gazette </font></font><font face="CMBX10"><font style="font-size: 11pt" size="2">63 </font></font><font face="CMR10"><font style="font-size: 11pt" size="2">(1979) 272.<br/>
[4]J. F. Hall, Fun with stacking blocks, Amer. J. Phys. 73 (2005) 1107{1116.<br/>
[5]<font face="CMR10"><font style="font-size: 11pt" size="2">M. Paterson, Y. Peres, M. Thorup, P. Winkler, and U. Zwick, Maximum overhang, available </font></font><font face="CMR10"><font style="font-size: 11pt" size="2">at <font face="CMTT10">http://arXiv.org/pdf/0707.0093</font>. An extended abstract is to appear in <font face="CMTI10">Proceedings of </font></font></font><font face="CMR10"><font style="font-size: 11pt" size="2"><font face="CMTI10">the 19th Annual ACM-SIAM Symposium on Discrete Algorithm (SODA'08)</font>.</font></font></font></font></font></font></font></font></font></font></font></p>
</div>]]></excerpt:encoded>
		<wp:post_id>41</wp:post_id>
		<wp:post_date>2007-12-18 23:55:00</wp:post_date>
		<wp:post_date_gmt>2007-12-18 23:55:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%9e%81%e9%99%90%e5%8f%a0%e6%9c%a8%e5%9d%97</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%8a%9b%e5%ad%a6"><![CDATA[力学]]></category>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="post_tag" nicename="%e6%9c%89%e8%b6%a3"><![CDATA[有趣]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>test</title>
		<link>http://hmgle.com/?p=105</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=105</guid>
		<description></description>
		<content:encoded><![CDATA[<pre lang="c" line="1">
#include <stdio.h>
#include <stdlib.h>
#define DwHashType 2
unsigned long cryptTable[0x700];

void prepareCryptTable()
{
	int index1 = 0, index2 = 0, i;
	unsigned long seed = 0x00100007; 
	
	for (index1 = 0; index1 < 0x100; index1++)
	{
		for (index2 = index1, i = 0; i < 7; i++,index2 += 0x100)
		{
			unsigned long temp1, temp2;
		
			seed = (seed << 7 + 3) % 0x2AABD7;
			temp1 = (seed & 0xFFFF) << 0x10;
		
			seed = (seed << 7 + 3) % 0x2AABD7;
			temp2 = (seed & 0xFFFF);
		
			cryptTable[index2] = (temp1 | temp2);
		}
	}
}

unsigned long HashString (char *lpszFileName, unsigned long dwHashType)
{
	unsigned char *key = (unsigned char *)lpszFileName;
	unsigned long seed1 = 0x7FED7FED;
	unsigned long seed2 = 0xEEEEEEEE;
	int ch;

	while (*key != 0)
	{
		ch = toupper (*key++);
		seed1 = cryptTable[(dwHashType << 8) + ch] ^ (seed1 + seed2);
		seed2 = ch + seed1 + seed2 + (seed2 << 5) + 3;
	}
	return seed1;
}



int main( int argc, char **argv )
{
    unsigned long ulHashValue;
    int i = 0;

    if ( argc != 2 )
    {
        printf("please input two arguments\n");
        return -1;
    }

     /*初始化数组：crytTable[0x500]*/
     prepareCryptTable();
     
          ulHashValue = HashString( argv[1] ,0);
     printf("\n----%X ----\n", ulHashValue );

     ulHashValue = HashString( argv[1],1);
     printf("----%X ----\n", ulHashValue );

     ulHashValue = HashString( argv[1],2 );
     printf("----%X ----\n", ulHashValue );
	 ulHashValue = HashString( argv[1],0);
     printf("\n----%lu ----\n", ulHashValue );

     ulHashValue = HashString( argv[1],1);
     printf("----%lu ----\n", ulHashValue );

     ulHashValue = HashString( argv[1],2);
     printf("----%lu ----\n", ulHashValue );

     system("pause");
	 return 0;
}
</pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>105</wp:post_id>
		<wp:post_date>2011-02-17 13:44:11</wp:post_date>
		<wp:post_date_gmt>0000-00-00 00:00:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name></wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%9c%aa%e5%88%86%e7%b1%bb"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Hello world！</title>
		<link>http://hmgle.com/archives/1</link>
		<pubDate>Tue, 15 Feb 2011 11:58:26 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=1</guid>
		<description></description>
		<content:encoded><![CDATA[这是导入之前在<a href="http://hi.baidu.com/hmgle" target="_blank">百度空间</a>的博文后在这里写的第一篇文章。之前的文章其实是先将百度空间的内容搬到<a href="http://hmgle.blogbus.com/" target="_blank">blogbus</a>后再从blogbus内导出xml文件然后再在wordpress里安个修正blogbus的不规范的xml文件的导入插件后最后才导进来的，不过图片什么的都没有了。像百度空间之类的连数据导出这个blog必备的基本功能都没有，令人匪夷所思。

其实我基本不写什么blog，人太懒，而且也不太喜欢回忆，它太沉重了。思考过的东西只在脑子里流过，记下来也没有啥价值的，权当为我百无聊赖的生活抹上胡乱的一笔。大家不要在这里逗留太久，这里可没有什么闪烁的光芒，尽管它的名字叫调和的微光，如果是学生应该多上点图书馆，要上也要关注些优秀的blog，比如国内的<a href="http://www.ruanyifeng.com/blog/" target="_blank">阮一峰的网志</a>。要玩的话应该玩些消耗体力培养竞争意识的运动，例如足球篮球之类的，千万别沉迷于滑板魔方之类的伪geek游戏。跑题了，关于这个blog的未来我还是希望它能闪烁些火光出来。我关注人文、科学、哲学及艺术，远离<strong><a href="http://en.wikipedia.org/wiki/Politics">politics</a>。</strong>

关于火光，ukim在他的Heroes in my heart的帖子里引用过一个很好的事迹：在一次采访当中，作为数学家的Thom同两位古人类学家讨论问题。谈到远古的人们为什么要保存火种时，一个人类学家说，因为保存火种可以取暖御寒；另外一个人类学家说，因为保存火种可以烧出鲜美的肉食。而Thom说，因为夜幕来临之际，火光摇曳妩媚，灿烂多姿，是最美最美的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1</wp:post_id>
		<wp:post_date>2011-02-15 11:58:26</wp:post_date>
		<wp:post_date_gmt>2011-02-15 11:58:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hello-world</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%bb%ba%e7%ab%99"><![CDATA[建站]]></category>
		<category domain="category" nicename="%e6%b5%ae%e7%94%9f"><![CDATA[浮生]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>一次考研</title>
		<link>http://hmgle.com/archives/17</link>
		<pubDate>Mon, 17 Jan 2011 22:43:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/17</guid>
		<description></description>
		<content:encoded><![CDATA[<p>昨天考完后，就像玩完了一个游戏，回味无穷。花一百六的入场费参与这场游戏真的很值，无论是抱着玩的态度还是以被玩的态度参加。我把它当成一场战斗，对于渴望战斗的人来说这是难得的一次体验，我喜欢硝烟的气氛，只恨它火药味还是太淡了点，时间太短了，转眼我现在又沦入了平淡无奇的生活。<br/>这是第二次考。去年没参加是个意外。这次早早来到考场静候。开考时人到了16个，本来是30个考生的。“真傻呀，如此有意义的活动竟然错过！”我暗地替14位缺考的考生惋惜半天。政治题目对我挺有挑战性，这正是它的魅力所在了，要没挑战性的活动我还来这鼓捣干嘛？今年的分析题很有趣呀，例如有道题问你怎样理解“温暖别人就是幸福自己”的。我的答案仅供参考：显然题目中温暖是个动词。先论证人的温暖别人这种的社会活动具有传递性、对称性和自反性。传递性：如果A温暖B，B温暖C，那么A温暖C是成立的。对称性：如果B接收到来至A的温暖，那么当A感到冷时B肯定会温暖A的，这叫知恩图报嘛，否则不合伦理之道。即A温暖B等价B温暖A。自反性：自己是温暖自己的，应该是生物的基本属性之一吧，就像植物吸收养分养活自己一样。温暖具有自反性。学过离散数学的都知道，具有这三性的就是一个等价关系。温暖是个等价关系，所以温暖关系定义了一个等价类，这个等价类集合的元素是社会上的人。接下来我们大概要阐述一下等价类的性质了，当然书上是找不到的，是我自己创造出来的一个性质：等价类里面的任意元素作用其他元素，会引起自身同样的效果。那么我们就可以理直气壮的说：温暖他人就是温暖自己。然后再加个条件：如果接受到温暖蕴含着感受到幸福的话，那么温暖他人就是幸福自己成立。哈哈，阅卷老师是不甘心入吾彀中的。老师告诫过我们：人生价值在于贡献，你得从这个角度回答。<br/>下午考英语，我盘算着除了作文之外供我发挥的方面太少了，就不去了。我躺在床上想着明年报什么专业。一年只能报一个专业太少了，我恨不得把所有喜欢的都报了。我是个务虚不务实的人，除了工科之外的我都很喜欢，这当然是受G·H·哈代那本《一个数学家的辩白》的毒害了，到现在我也坚信越优美的东西越没有实用性，庸俗实用的工科当然不在我的考虑范围之内了。后来迷迷糊糊就睡了一个下午了。<br/>第二天考专业课，上午数学分析，下午高等代数。广州大学的，由于之前我搜索过整个互联网也没有得到过这个学校的这两门试题，这次能一睹真容实在太激动了。数分果然很给力，比高数之类的深邃多了。我感激地先把所有题目抄下，等考完就带出去，然后再战战兢兢地答题。不过下午的高代就有点失望了，竟然还有填空题，明显浅了很多，于是就只抄了部分回去。有需要的尽管问我好了，不过是我自己手抄的，懒得输入电脑了，而且我又不会用Lex之类的排版。<br/>明年还考，想学哲学之类的，数理逻辑就很吸引我，当然不是讨厌的马毛邓之类的。<br/></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p>昨天考完后，就像玩完了一个游戏，回味无穷。花一百六的入场费参与这场游戏真的很值，无论是抱着玩的态度还是以被玩的态度参加。我把它当成一场战斗，对于渴望战斗的人来说这是难得的一次体验，我喜欢硝烟的气氛，只恨它火药味还是太淡了点，时间太短了，转眼我现在又沦入了平淡无奇的生活。<br/>这是第二次考。去年没参加是个意外。这次早早来到考场静候。开考时人到了16个，本来是30个考生的。“真傻呀，如此有意义的活动竟然错过！”我暗地替14位缺考的考生惋惜半天。政治题目对我挺有挑战性，这正是它的魅力所在了，要没挑战性的活动我还来这鼓捣干嘛？今年的分析题很有趣呀，例如有道题问你怎样理解“温暖别人就是幸福自己”的。我的答案仅供参考：显然题目中温暖是个动词。先论证人的温暖别人这种的社会活动具有传递性、对称性和自反性。传递性：如果A温暖B，B温暖C，那么A温暖C是成立的。对称性：如果B接收到来至A的温暖，那么当A感到冷时B肯定会温暖A的，这叫知恩图报嘛，否则不合伦理之道。即A温暖B等价B温暖A。自反性：自己是温暖自己的，应该是生物的基本属性之一吧，就像植物吸收养分养活自己一样。温暖具有自反性。学过离散数学的都知道，具有这三性的就是一个等价关系。温暖是个等价关系，所以温暖关系定义了一个等价类，这个等价类集合的元素是社会上的人。接下来我们大概要阐述一下等价类的性质了，当然书上是找不到的，是我自己创造出来的一个性质：等价类里面的任意元素作用其他元素，会引起自身同样的效果。那么我们就可以理直气壮的说：温暖他人就是温暖自己。然后再加个条件：如果接受到温暖蕴含着感受到幸福的话，那么温暖他人就是幸福自己成立。哈哈，阅卷老师是不甘心入吾彀中的。老师告诫过我们：人生价值在于贡献，你得从这个角度回答。<br/>下午考英语，我盘算着除了作文之外供我发挥的方面太少了，就不去了。我躺在床上想着明年报什么专业。一年只能报一个专业太少了，我恨不得把所有喜欢的都报了。我是个务虚不务实的人，除了工科之外的我都很喜欢，这当然是受G·H·哈代那本《一个数学家的辩白》的毒害了，到现在我也坚信越优美的东西越没有实用性，庸俗实用的工科当然不在我的考虑范围之内了。后来迷迷糊糊就睡了一个下午了。<br/>第二天考专业课，上午数学分析，下午高等代数。广州大学的，由于之前我搜索过整个互联网也没有得到过这个学校的这两门试题，这次能一睹真容实在太激动了。数分果然很给力，比高数之类的深邃多了。我感激地先把所有题目抄下，等考完就带出去，然后再战战兢兢地答题。不过下午的高代就有点失望了，竟然还有填空题，明显浅了很多，于是就只抄了部分回去。有需要的尽管问我好了，不过是我自己手抄的，懒得输入电脑了，而且我又不会用Lex之类的排版。<br/>明年还考，想学哲学之类的，数理逻辑就很吸引我，当然不是讨厌的马毛邓之类的。<br/></p>]]></excerpt:encoded>
		<wp:post_id>17</wp:post_id>
		<wp:post_date>2011-01-17 22:43:00</wp:post_date>
		<wp:post_date_gmt>2011-01-17 22:43:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%80%e6%ac%a1%e8%80%83%e7%a0%94</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e6%b8%b8%e6%88%8f"><![CDATA[游戏]]></category>
		<category domain="post_tag" nicename="%e7%ad%89%e4%bb%b7%e7%b1%bb"><![CDATA[等价类]]></category>
		<category domain="post_tag" nicename="%e8%80%83%e7%a0%94"><![CDATA[考研]]></category>
		<category domain="category" nicename="%e9%80%90%e6%b5%aa"><![CDATA[逐浪]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>入手Kindle 3</title>
		<link>http://hmgle.com/archives/18</link>
		<pubDate>Thu, 13 Jan 2011 22:05:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/18</guid>
		<description></description>
		<content:encoded><![CDATA[<p>淘宝买来Kindle 3。这玩意儿太合我胃口了，干净简洁利落。<br/>这两天一直下适合6英寸屏的电子书，已经下了百来本，加上之前电脑上的，按正常速度看的话，要几十年才能看完。当然按趋势来看，下载书的速度远远超过看书的速度，再过一阵下载回来的书我几辈子也看不完。我看书也就图个当时痛快，能记住的不多。<br/>发现有些txt格式和mobi格式的书每隔一定距离就添加换行，这在kindle上看起来就是画蛇添足。本来到屏幕边缘就自动换行了，现在多了许多难看的无意义的换行符，很影响阅读的。对于那些段落之间有空格分隔的文本还是有救的，解决方法：用<a target="_blank" href="http://man.chinaunix.net/newsoft/vi/doc/pattern.html">vim</a>的替换，输入:%s/\n\S\@=//g就搞定了。别的编辑器没试，<a target="_blank" href="http://hi.baidu.com/hmgle/blog/item/2f03bd8beef6b0c1fc1f1097.html">上次</a>也发现很多以前以为很牛逼的编辑器例如UE、Notepad++、emeditor等对正则表达式的查找和替换支持都不是很好，因此要用到正则表达式的时候我无视其它，直接用vim。vim是最牛逼的。对于所有段落都连在一起的一坨的文本是没救的。<br/>对于mobi格式，我还不知道用什么软件编辑它，txt转换mobi容易，mobi怎么转换成txt？</p><p> </p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p>淘宝买来Kindle 3。这玩意儿太合我胃口了，干净简洁利落。<br/>这两天一直下适合6英寸屏的电子书，已经下了百来本，加上之前电脑上的，按正常速度看的话，要几十年才能看完。当然按趋势来看，下载书的速度远远超过看书的速度，再过一阵下载回来的书我几辈子也看不完。我看书也就图个当时痛快，能记住的不多。<br/>发现有些txt格式和mobi格式的书每隔一定距离就添加换行，这在kindle上看起来就是画蛇添足。本来到屏幕边缘就自动换行了，现在多了许多难看的无意义的换行符，很影响阅读的。对于那些段落之间有空格分隔的文本还是有救的，解决方法：用<a target="_blank" href="http://man.chinaunix.net/newsoft/vi/doc/pattern.html">vim</a>的替换，输入:%s/\n\S\@=//g就搞定了。别的编辑器没试，<a target="_blank" href="http://hi.baidu.com/hmgle/blog/item/2f03bd8beef6b0c1fc1f1097.html">上次</a>也发现很多以前以为很牛逼的编辑器例如UE、Notepad++、emeditor等对正则表达式的查找和替换支持都不是很好，因此要用到正则表达式的时候我无视其它，直接用vim。vim是最牛逼的。对于所有段落都连在一起的一坨的文本是没救的。<br/>对于mobi格式，我还不知道用什么软件编辑它，txt转换mobi容易，mobi怎么转换成txt？</p><p> </p>]]></excerpt:encoded>
		<wp:post_id>18</wp:post_id>
		<wp:post_date>2011-01-13 22:05:00</wp:post_date>
		<wp:post_date_gmt>2011-01-13 22:05:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%85%a5%e6%89%8bkindle-3</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="kindle-3"><![CDATA[kindle 3]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>28</wp:comment_id>
			<wp:comment_author><![CDATA[tianfeng]]></wp:comment_author>
			<wp:comment_author_email>ztfljy@163.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>124.98.52.200</wp:comment_author_IP>
			<wp:comment_date>2011-07-04 10:12:16</wp:comment_date>
			<wp:comment_date_gmt>2011-07-04 10:12:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[求下载电子书的网站.
我也有一个艾利和的电子书,苦于没地方下载新出版的电子书.
全是些老掉牙的书,敢问阁下都在什么地方下载?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>42</wp:comment_id>
			<wp:comment_author><![CDATA[hmgle]]></wp:comment_author>
			<wp:comment_author_email>dustgle@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>116.24.89.168</wp:comment_author_IP>
			<wp:comment_date>2011-09-25 07:32:01</wp:comment_date>
			<wp:comment_date_gmt>2011-09-25 07:32:01</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[可以看看http://www.douban.com/group/ereading/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>28</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>跳过灵格斯词霸强制升级</title>
		<link>http://hmgle.com/archives/19</link>
		<pubDate>Mon, 03 Jan 2011 21:12:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/19</guid>
		<description></description>
		<content:encoded><![CDATA[<p>by:hmgle</p><p>灵格斯词霸是我用的比较频繁的一个软件。虽说词典软件还有星际译王，而且星际译王还是开源的，但它在Windows平台下运行有点慢，不知道是不是GTK的缘故，那个gedit在Windows下也是奇慢无比。</p>2011年刚来，灵格斯给我们带来了新年礼物，就是那个讨厌的强制旧版本升级啦。不升级就自动退出。这样对灵格斯的某些用户来说是很扫兴的。<br/>当然，对灵格斯进行逆向分析，修改它的代码，是可以达到不升级继续使用的目的的，这活儿<a target="_blank" href="http://bbs.pediy.com/">看雪</a>的人在行。但这样做是违反<a target="_blank" href="http://www.lingoes.cn/zh/translator/license.htm">『灵格斯翻译家』最终用户许可协议</a>的（协议里面有一条：禁止反向工程、反向编译和反向汇编等等），而且别人写的补丁自己用起来的话心里也不踏实啊。那我们还是合法地在自己系统上做文章吧。灵格斯启动的时候应该是会先取得系统日期，然后和某个时间进行比较，超过这个时间的话它就强制升级（这只是我的猜测，绝对没有反向工程）。那我们就先把我们自己的系统日期改成一个较早的日子吧，早到灵格斯都还没出生的日子，等灵格斯启动之后再把系统日期改回来。可以用批处理这样做：<br/>
<pre lang="dos" line="1">
@echo off
set oldyear=2004
set oldmonth=01
set oldday=01
rem 上面是要改成的时间，早到能启动就行了
set fileflag=0
if exist getcurrentdate.nul (set fileflag=1
copy getcurrentdate.nul /Y getcurrentdate.backup)
date /t > getcurrentdate.nul
for /F “tokens=1,2,3 delims=- ” %%i in (getcurrentdate.nul) do (set currentyear=%%i
set currentmonth=%%j
set currentday=%%k)
date %oldyear%-%oldmonth%-%oldday%
if NOT errorlevel 0  (echo 设置时间时出错
pause
exit)
date /t
start “” /D”D:\Program Files\lingoes_portable_2.6.3_zh” Lingoes.exe
rem  上面一行是运行灵格斯，D:\Program Files\lingoes_portable_2.6.3_zh是我电脑上的灵格斯安装目录路径，根据你自己的情况更改
if NOT errorlevel 0 (echo 启动时出错
pause
gote end)
ping 127.1 -n 7 >nul
rem 上面是为了延时，因为灵格斯启动时取得系统日期是要一定时间的，一般ping个三四次就够了，如果嫌慢自己改小点吧
:end
del getcurrentdate.nul
if %fileflag% EQU 1 rename getcurrentdate.backup getcurrentdate.nul
date %currentyear%-%currentmonth%-%currentday%
exit
</pre>
<p> </p>明白的话下面部分就没必要看了，就是：<br/>1.先看你的灵格斯是放在哪个目录，把这个目录路径记下，比如我的就是D:\Program Files\lingoes_portable_2.6.3_zh；<br/>2.新建一个文本文件，用文本编辑器打开，把上面批处理的内容复制进去，把start "" /D"D:\Program Files\lingoes_portable_2.6.3_zh" Lingoes.exe那一行（就是红色字体那一行）里面的目录路径（蓝色背景那部分）改成步骤1记下的目录路径，保存后把文件名改成bat结尾的形式，例如：lgs.bat;<br/>3.双击这个批处理文件就直接运行灵格斯词霸了。<br/><p>你可以把lgs.bat放在任意位置，也可以为它创建桌面快捷方式（这样可以改图标和用快捷键运行）。对常用的软件，我喜欢建个目录，然后为这个目录设置环境变量，在这个目录下创建启动常用软件的批处理，例如把上面那个lgs.bat放进来，这样用快捷键win+r后输入lgs就运行了。当然每个人操作习惯是不同的。</p><p>这个批处理是有个bug的，就是如果你刚好在系统更换日期前的瞬间运行的话，例如在23点59分59秒运行这个批处理，运行后你的系统日期会后退一天。不过你应该也像我一样，不可能在那个时刻做这样的事情的。</p><p>update:开机后第一次运行ping 127.1四五次是不够的，因为灵格斯会加载很多数据到内存。非第一次运行的话ping个三四次就够了，现在我把它改成7次。改了个错字（原来的@echo off写成@echo 0ff）。</p><br/><br/>附：<a target="_blank" href="http://www.lingoes.cn/zh/translator/license.htm">『灵格斯翻译家』最终用户许可协议</a>（见http://www.lingoes.cn/zh/translator/license.htm）<br/>『灵格斯翻译家』最终用户许可协议<br/>Lingoes Translator End-User License Agreenent<br/>在使用本软件的同时，你已经默认接受了此协议。<br/>请仔细阅读以下使用许可，如果您不同意以下任何一点，请立即停止使用此软件。<br/><br/>Kevin Yau 将本软件程序的最终使用许可权授予您，但您必须向 Kevin Yau 作以下保证：<br/><br/>本《最终用户许可协议》(以下称《协议》)是您(个人或机构团体)与上述软件(以下称“软件”或“软件产品”)版权所有人 Kevin Yau 之间的法律协议。 在您使用本软件产品之前,请务必阅读此《协议》，任何与《协议》有关的软件、电子文档等都应是按本协议的条款而授予您的，同时本《协议》亦适用于任何有关本软件产品的后期发行和升级。 您一旦安装、复制、下载、访问或以其它方式使用本软件产品，即表示您同意接受本《协议》各项条款的约束。 如您不同意本《协议》的条款，那么，版权所有人 Kevin Yau 则不予将本软件产品的使用权授予您。 在这种情况下，您不得使用、复制或传播本软件产品。 <br/><br/>本《协议》中，将软件使用用途分为“个人非商业用途”和“商业用途”：个人用途指个人在非团体机构中使用本软件并用于非商业目的；商业用途指个人用于任何商业目的或团体机构出于任何目的使用本软件。本《协议》中对于个人非商业用途和商业用途将采用不同的授权范围和使用方式。<br/><br/>本软件产品受著作权法及国际著作权条约和其它知识产权法及条约的保护。<br/>1. 许可证的授予. 本《协议》授予您下列权利<br/>安装和使用: <br/>对于个人非商业用途，即仅供个人用户用于非商业环境及非盈利活动，您可安装无限制数量的本软件产品来使用。 对于商业用途，你必须预先获得版权人授权许可后才能安装和使用本软件产品。 <br/><br/>复制、分发和传播: <br/>您可以复制、分发和传播无限制数量的软件产品, 但您必须保证每一份复制、分发和传播都必须是完整和真实的, 包括所有有关本软件产品的软件、电子文档, 版权和商标宣言, 亦包括本协议. <br/><br/>本软件可以独立分发亦可随同其他软件一起分发, 但如因此而引起任何问题, 版权人将不予承担任何责任.<br/><br/>2. 其它权利和限制说明<br/>禁止反向工程、反向编译和反向汇编：<br/>您不得对本软件产品进行反向工程、反向编译和反向汇编，同时不得改动编译在程序文件内部的任何资源。 除非适用法律明文允许上述活动，否则您必须遵守此协议限制。 <br/><br/>组件的分隔：<br/>本软件产品是被当成一个单一产品而被授予许可使用，不得将各个部分分开用于任何目的行动。 <br/><br/>软件产品转让：<br/>您可以在不保留任何副本的情况下，将本“软件产品”(包括所有组成部分、媒体内容和印刷材料、任何更新版本、本《协议》等)全部转让，并且受让人接受本《协议》的各项条件下，您可永久转让您在本《协议》下的所有权利。 如果本“软件产品”为更新版本，转让时必须包括本“软件产品”所有前版本。 <br/><br/>终止：<br/>如您未遵守本《协议》的各项条件，在不损害其它权利的情况下，版权人可将本《协议》终止。 如发生此种情况，则您必须销毁“软件产品”及其各部分的所有副本。 <br/><br/>商标：<br/>本《协议》不授予您由版权人 Kevin Yau 所拥有的任何商标或服务商标有关的任何权利。 <br/><br/>使用方式：<br/>对于个人非商业用途，本软件产品准许个人用户免费使用。凡用于商业用途，均须得到版权人授权许可。<br/><br/>本软件产品不能用于销售或随同旨在获益的软件产品或产品包一起分发，但本软件可包含在任何免费或非赢利性的软件产品或产品包里. 同时您必须保证所分发的软件包含全部文件, 并且未作任何修改。<br/><br/>个别授权: <br/>如有任何组织或个人利用本软件以任何方式为公众服务并同时满足其自身特定目的而分发、复制和传播本软件产品, 均须得到版权人授权同意后方可进行, 否则视为侵权.<br/><br/>3. 版权<br/>本软件产品（包括但不限于本软件产品中所含的任何图象、照片、动画、文字和附加程序，不包含本软件可访问的词典及其内容）、随附的印刷材料、及本软件产品的任何副本的一切所有权和知识产权，均由版权人 Kevin Yau 拥有。<br/><br/>通过使用本“软件产品”可访问的词典及其内容的一切所有权和知识产权，均属于各自内容的所有者拥有，并可能受适用著作权或其它知识产权法律和条约的保护，本《协议》不授予您使用这些内容的权利。如果您需要使用，应当另外取得词典及其内容所有者的同意和授权。<br/><br/>4. 有限保证<br/>无保证：<br/>本软件版权人 Kevin Yau 特此申明对本软件产品之使用不提供任何保证。 版权人将不对任何用户保证本软件产品的适用性，不保证无故障产生；亦不对任何用户使用此软件所遭遇到的任何理论上的或实际上的损失承担负责。<br/><br/>对造成损失无责任：<br/>本软件版权人对本软件产品可能或已知问题造成的意外，连续，直接或间接损失不承担任何责任(包括利益损失，商业中断，信息丢失或其他任何经济上的损失)。<br/><br/>5. 其它<br/>本软件版权人 Kevin Yau 对本协议拥有最终解释权。<br/><br/> 2006-2007 Kevin Yau 版权所有，保留所有权利。]]></content:encoded>
		<excerpt:encoded><![CDATA[<p> </p>明白的话下面部分就没必要看了，就是：<br/>1.先看你的灵格斯是放在哪个目录，把这个目录路径记下，比如我的就是D:\Program Files\lingoes_portable_2.6.3_zh；<br/>2.新建一个文本文件，用文本编辑器打开，把上面批处理的内容复制进去，把start "" /D"D:\Program Files\lingoes_portable_2.6.3_zh" Lingoes.exe那一行（就是红色字体那一行）里面的目录路径（蓝色背景那部分）改成步骤1记下的目录路径，保存后把文件名改成bat结尾的形式，例如：lgs.bat;<br/>3.双击这个批处理文件就直接运行灵格斯词霸了。<br/><p>你可以把lgs.bat放在任意位置，也可以为它创建桌面快捷方式（这样可以改图标和用快捷键运行）。对常用的软件，我喜欢建个目录，然后为这个目录设置环境变量，在这个目录下创建启动常用软件的批处理，例如把上面那个lgs.bat放进来，这样用快捷键win+r后输入lgs就运行了。当然每个人操作习惯是不同的。</p><p>这个批处理是有个bug的，就是如果你刚好在系统更换日期前的瞬间运行的话，例如在23点59分59秒运行这个批处理，运行后你的系统日期会后退一天。不过你应该也像我一样，不可能在那个时刻做这样的事情的。</p><p>update:开机后第一次运行ping 127.1四五次是不够的，因为灵格斯会加载很多数据到内存。非第一次运行的话ping个三四次就够了，现在我把它改成7次。改了个错字（原来的@echo off写成@echo 0ff）。</p><br/><br/>附：<a target="_blank" href="http://www.lingoes.cn/zh/translator/license.htm">『灵格斯翻译家』最终用户许可协议</a>（见http://www.lingoes.cn/zh/translator/license.htm）<br/>『灵格斯翻译家』最终用户许可协议<br/>Lingoes Translator End-User License Agreenent<br/>在使用本软件的同时，你已经默认接受了此协议。<br/>请仔细阅读以下使用许可，如果您不同意以下任何一点，请立即停止使用此软件。<br/><br/>Kevin Yau 将本软件程序的最终使用许可权授予您，但您必须向 Kevin Yau 作以下保证：<br/><br/>本《最终用户许可协议》(以下称《协议》)是您(个人或机构团体)与上述软件(以下称“软件”或“软件产品”)版权所有人 Kevin Yau 之间的法律协议。 在您使用本软件产品之前,请务必阅读此《协议》，任何与《协议》有关的软件、电子文档等都应是按本协议的条款而授予您的，同时本《协议》亦适用于任何有关本软件产品的后期发行和升级。 您一旦安装、复制、下载、访问或以其它方式使用本软件产品，即表示您同意接受本《协议》各项条款的约束。 如您不同意本《协议》的条款，那么，版权所有人 Kevin Yau 则不予将本软件产品的使用权授予您。 在这种情况下，您不得使用、复制或传播本软件产品。 <br/><br/>本《协议》中，将软件使用用途分为“个人非商业用途”和“商业用途”：个人用途指个人在非团体机构中使用本软件并用于非商业目的；商业用途指个人用于任何商业目的或团体机构出于任何目的使用本软件。本《协议》中对于个人非商业用途和商业用途将采用不同的授权范围和使用方式。<br/><br/>本软件产品受著作权法及国际著作权条约和其它知识产权法及条约的保护。<br/>1. 许可证的授予. 本《协议》授予您下列权利<br/>安装和使用: <br/>对于个人非商业用途，即仅供个人用户用于非商业环境及非盈利活动，您可安装无限制数量的本软件产品来使用。 对于商业用途，你必须预先获得版权人授权许可后才能安装和使用本软件产品。 <br/><br/>复制、分发和传播: <br/>您可以复制、分发和传播无限制数量的软件产品, 但您必须保证每一份复制、分发和传播都必须是完整和真实的, 包括所有有关本软件产品的软件、电子文档, 版权和商标宣言, 亦包括本协议. <br/><br/>本软件可以独立分发亦可随同其他软件一起分发, 但如因此而引起任何问题, 版权人将不予承担任何责任.<br/><br/>2. 其它权利和限制说明<br/>禁止反向工程、反向编译和反向汇编：<br/>您不得对本软件产品进行反向工程、反向编译和反向汇编，同时不得改动编译在程序文件内部的任何资源。 除非适用法律明文允许上述活动，否则您必须遵守此协议限制。 <br/><br/>组件的分隔：<br/>本软件产品是被当成一个单一产品而被授予许可使用，不得将各个部分分开用于任何目的行动。 <br/><br/>软件产品转让：<br/>您可以在不保留任何副本的情况下，将本“软件产品”(包括所有组成部分、媒体内容和印刷材料、任何更新版本、本《协议》等)全部转让，并且受让人接受本《协议》的各项条件下，您可永久转让您在本《协议》下的所有权利。 如果本“软件产品”为更新版本，转让时必须包括本“软件产品”所有前版本。 <br/><br/>终止：<br/>如您未遵守本《协议》的各项条件，在不损害其它权利的情况下，版权人可将本《协议》终止。 如发生此种情况，则您必须销毁“软件产品”及其各部分的所有副本。 <br/><br/>商标：<br/>本《协议》不授予您由版权人 Kevin Yau 所拥有的任何商标或服务商标有关的任何权利。 <br/><br/>使用方式：<br/>对于个人非商业用途，本软件产品准许个人用户免费使用。凡用于商业用途，均须得到版权人授权许可。<br/><br/>本软件产品不能用于销售或随同旨在获益的软件产品或产品包一起分发，但本软件可包含在任何免费或非赢利性的软件产品或产品包里. 同时您必须保证所分发的软件包含全部文件, 并且未作任何修改。<br/><br/>个别授权: <br/>如有任何组织或个人利用本软件以任何方式为公众服务并同时满足其自身特定目的而分发、复制和传播本软件产品, 均须得到版权人授权同意后方可进行, 否则视为侵权.<br/><br/>3. 版权<br/>本软件产品（包括但不限于本软件产品中所含的任何图象、照片、动画、文字和附加程序，不包含本软件可访问的词典及其内容）、随附的印刷材料、及本软件产品的任何副本的一切所有权和知识产权，均由版权人 Kevin Yau 拥有。<br/><br/>通过使用本“软件产品”可访问的词典及其内容的一切所有权和知识产权，均属于各自内容的所有者拥有，并可能受适用著作权或其它知识产权法律和条约的保护，本《协议》不授予您使用这些内容的权利。如果您需要使用，应当另外取得词典及其内容所有者的同意和授权。<br/><br/>4. 有限保证<br/>无保证：<br/>本软件版权人 Kevin Yau 特此申明对本软件产品之使用不提供任何保证。 版权人将不对任何用户保证本软件产品的适用性，不保证无故障产生；亦不对任何用户使用此软件所遭遇到的任何理论上的或实际上的损失承担负责。<br/><br/>对造成损失无责任：<br/>本软件版权人对本软件产品可能或已知问题造成的意外，连续，直接或间接损失不承担任何责任(包括利益损失，商业中断，信息丢失或其他任何经济上的损失)。<br/><br/>5. 其它<br/>本软件版权人 Kevin Yau 对本协议拥有最终解释权。<br/><br/> 2006-2007 Kevin Yau 版权所有，保留所有权利。]]></excerpt:encoded>
		<wp:post_id>19</wp:post_id>
		<wp:post_date>2011-01-03 21:12:00</wp:post_date>
		<wp:post_date_gmt>2011-01-03 21:12:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%b7%b3%e8%bf%87%e7%81%b5%e6%a0%bc%e6%96%af%e8%af%8d%e9%9c%b8%e5%bc%ba%e5%88%b6%e5%8d%87%e7%ba%a7</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%89%b9%e5%a4%84%e7%90%86"><![CDATA[批处理]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%81%b5%e6%a0%bc%e6%96%af"><![CDATA[灵格斯]]></category>
		<category domain="post_tag" nicename="%e8%bd%af%e4%bb%b6"><![CDATA[软件]]></category>
		<category domain="category" nicename="%e9%80%90%e6%b5%aa"><![CDATA[逐浪]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>26</wp:comment_id>
			<wp:comment_author><![CDATA[tianfeng]]></wp:comment_author>
			<wp:comment_author_email>ztfljy@163.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>219.122.38.121</wp:comment_author_IP>
			<wp:comment_date>2011-07-04 00:58:20</wp:comment_date>
			<wp:comment_date_gmt>2011-07-04 00:58:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[呵呵,受教了,根据你的启发,我把你的bat文件改的更简单了.
在我的日文机器上,运行你的那个bat不知道为什么老出错,把导出跟遍历都删掉之后好用了.
另外中文字符在我的日文机器上也没法运行,所以乱改你的文件别介意呵呵.
现在灵格斯再也不用升级了.这应该算一个BUG,提示我升级但是去官网看一下根本就没发布新版本.
所以这个问题应该引起灵格斯作者的注意.
以下是我改完的Bat.谢谢启发
---------------------------------------
@echo off
set currentDate=%date%
date 2004/01/01
if NOT errorlevel 0  (echo Setting Location Time Error! exit)
date /t
start /D "C:\Program Files\Lingoes\Translator2" Lingoes.exe
if NOT errorlevel 0 (echo Starting Error
pause
gote end)
ping 127.1 -n 3
:end
date %currentDate%
exit
---------------------------------------]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>27</wp:comment_id>
			<wp:comment_author><![CDATA[tianfeng]]></wp:comment_author>
			<wp:comment_author_email>ztfljy@163.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>124.98.52.200</wp:comment_author_IP>
			<wp:comment_date>2011-07-04 10:07:57</wp:comment_date>
			<wp:comment_date_gmt>2011-07-04 10:07:57</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你好,谢谢你的bat,运行了一下貌似在我的日文机器上由于中文字符的原因总出错,
根据你的原理改成更简单的,现在灵格斯可以正常启动并且不用升级.
以下是改完的Bat,谢谢启发
----------------------------------
@echo off
set currentDate=%date%
date 2004/01/01
if NOT errorlevel 0  (echo Setting Location Time Error! exit)
date /t
start /D "C:\Program Files\Lingoes\Translator2" Lingoes.exe
if NOT errorlevel 0 (echo Starting Error
pause
gote end)
ping 127.1 -n 3
:end
date %currentDate%
exit
----------------------------------]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>文本编辑器的正则表达式</title>
		<link>http://hmgle.com/archives/20</link>
		<pubDate>Sat, 25 Dec 2010 22:46:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/20</guid>
		<description></description>
		<content:encoded><![CDATA[我之前主要用gedit和Notepad++。现在发现在编辑器里搜索像<span style="font-size:18px">(?&lt;!\d)\d{3}</span>这样的模式，试了很多文本编辑器都有问题，例如emeditor,MadEdit,UltraEdi都是同样的问题：零宽度断言部分和后面部分同样类型的时候就不行了，而notepad++好像不支持零宽度断言。另外MadEdit v0.2.9.1版使用正则表达式搜索<span style="font-size: 20px; ">^</span>的话，计算次数时会直接死掉。VIM倒是可以做到，用<span style="font-size:18px">/\(\d\)\@&lt;!\d\{3}</span>，但VIM不好上手。问在Windows下，除了Vim和Emacs外，还有别的文本编辑器（不用插件）可以匹配到这种模式吗？<p/>]]></content:encoded>
		<excerpt:encoded><![CDATA[我之前主要用gedit和Notepad++。现在发现在编辑器里搜索像<span style="font-size:18px">(?&lt;!\d)\d{3}</span>这样的模式，试了很多文本编辑器都有问题，例如emeditor,MadEdit,UltraEdi都是同样的问题：零宽度断言部分和后面部分同样类型的时候就不行了，而notepad++好像不支持零宽度断言。另外MadEdit v0.2.9.1版使用正则表达式搜索<span style="font-size: 20px; ">^</span>的话，计算次数时会直接死掉。VIM倒是可以做到，用<span style="font-size:18px">/\(\d\)\@&lt;!\d\{3}</span>，但VIM不好上手。问在Windows下，除了Vim和Emacs外，还有别的文本编辑器（不用插件）可以匹配到这种模式吗？<p/>]]></excerpt:encoded>
		<wp:post_id>20</wp:post_id>
		<wp:post_date>2010-12-25 22:46:00</wp:post_date>
		<wp:post_date_gmt>2010-12-25 22:46:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%96%87%e6%9c%ac%e7%bc%96%e8%be%91%e5%99%a8%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="post_tag" nicename="%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><![CDATA[正则表达式]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>39</wp:comment_id>
			<wp:comment_author><![CDATA[面条]]></wp:comment_author>
			<wp:comment_author_email>softbug.wang@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>221.205.110.10</wp:comment_author_IP>
			<wp:comment_date>2011-09-16 11:29:39</wp:comment_date>
			<wp:comment_date_gmt>2011-09-16 11:29:39</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我也在找一个对正则表达式支持比较好的文本编辑器，到现在还没找到一个理想的。目前发现对正则表达式支持比较好的要算PSPad Editor了。不过它对\n的支持似乎有些问题。]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>40</wp:comment_id>
			<wp:comment_author><![CDATA[hmgle]]></wp:comment_author>
			<wp:comment_author_email>dustgle@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>116.24.38.189</wp:comment_author_IP>
			<wp:comment_date>2011-09-17 01:39:00</wp:comment_date>
			<wp:comment_date_gmt>2011-09-17 01:39:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我没有用过PSPad Editor. 现在用vim. vim很有趣, 而且很科学,比如你要在括号里面输入些内容, 用vim的人都是先敲完整一对括号后再往里面插入内容的. 我很少见过有用除了vim和Emacs之外的编辑器的人这么干的, 他们一般按顺序敲,括号嵌套多了经常把他们搞得头大.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>39</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>手机号码更换</title>
		<link>http://hmgle.com/archives/21</link>
		<pubDate>Tue, 07 Sep 2010 18:41:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/21</guid>
		<description></description>
		<content:encoded><![CDATA[上个月我换了个手机号码。事情是这样的：换了台Palm手机，换SIM卡的时候需要输入Pin码（我自己设置的，对于一个对信息极度敏感的人设置Pin口令是正常的），前两次输错，在明知道我已经找不到PUK码的情况下我还是贸然地将宝贵的最后一次Pin码输错了。这事坏就坏在我知道我的Keepass里是保存有Pin码的，回去打开Keepass一看发现PIN码原来只有四位数，而我全都输了六位数，前面四位是对的！造成这个悲剧的根本原因是对自己记忆力的错误估计。号码是找不回了，教训还当记着。花代价所换来的一点才智，抵过别人传授的数倍不止（富兰克林语）。我将记得截止到2010年SIM卡的PIN码只能是四位的。悲痛之余换了现在的新号码。<br/>
我的大部分联系人的号码都存储在原来的SIM卡内，本人才疏学浅未能破解SIM卡密码体系，无法把你们一一挖出来。因此写了个程序让大伙找到我。假如你有我原来的手机号码，或者即使没有原来的号码但掌握了我一些个人信息，都可以通过该程序得到我的新的手机号码。<br/>
基于安全考虑，当然不能采用下面的方法来获得新的号码：<br/>
1.验证问题答案;<br/>
2.if (Answer is correct) then<br/>
output new_num<br/>
3.else then<br/>
output "you fail";<br/>
4.return.<br/>
因为上面的代码运行时其实计算机已经把新号码存储在内存了，计算机知道的任何秘密，我们有办法是她告诉我们。通过逆向分析，使用几个跳转指令就是号码显示出来了。大概也没有人愿意吧秘密藏在程序里吧。我们可以构造一个具有以下性质的函数f：<br/>
f(待验证的信息) = 新号码 当且仅当待验证的信息等于旧号码。<br/><br/>
对于从验证信息途径获取新号码的原理就是密码学中的秘密共享协议。组合数学有道常见的题目，大概意思是有个强盗把宝藏藏在一个其他人都不知道的山洞里，只有通过藏宝图才能找到。这个强盗有7个继承人，为避免宝藏被独吞，他打算这样分配藏宝图给7个继承人：任意4人所持的藏宝图部分都能拼凑成一幅完整的藏宝图，不足4人在场的情况下没有办法拼出完整的藏宝图。问他应该怎样实现他的设想。密码学把这叫做(4,7)门限秘密共享方案。我的程序参考了Mignotte门限方案，只不过随意修改了权重：有的需要回答两个问题就能解出新号码，有的要回答三个。Mignotte方案的核心是中国剩余定理，程序里只需写个解同余式组的函数就可以了。<br/><br/>
为了保持我的熵不过多流失，将信息隔离使它们单向通信是必须的。比如你通过正确回答问题A和问题B获得我的手机新号码，但你不能通过求出的新号码逆向得到其它问题的答案，也不能通过任何信息逆向获取我的原来的号码和其他任何你之前不知道的信息。这只要用单向函数就能实现了。因为你输入的任何信息都要散列成整数以便下一步运算，所以我只要选用一个单向的Hash函数就行了。简单的Hash函数有很多，比如elfhash、P.J.weinberger  Hash等，但大多数单向性不好，而MD5、SHA-1算法又过于复杂，用在这里显得大材小用了，最后选用了Blizzard在MPQ中的Hash算法，据说是One-way Hash，较简单，只是版权协议未知。我将其修改几个参数后挪来作为非商业目的使用，也不知有没有侵权，若侵权了我马上移除这个Hash部分并愿意赔偿甚至赔偿10块钱。为了减少被暴力破解出新号码的可能，我对Hash值再取某个较小的整数的模，相当于减少了Hash函数的值域，这样就造成了更多的碰撞，在大多数情况下碰撞是有害的。<br/><br/>
这个程序上传在我的<a href="http://cid-a062cb69b403730a.office.live.com/self.aspx/.Documents/GetMyNum.zip" target="_blank">SkyDrive</a>(地址:http://cid-a062cb69b403730a.office.live.com/self.aspx/.Documents/GetMyNum.zip 或<a href="http://goo.gl/ulcB" target="_blank">http://goo.gl/ulcB</a>)上（Google文件共享网站疑被墙，故新注册了Windows live帐号），压缩包md5值：78EF060E16269272DACF1733882206ED     。包括交互式的C版本和用Delphi写的有界面的版本。那个用Delphi写的是很难看的。程序没有自定义功能，只适用于我自己的号码，不支持设置成求解别人号码和自定义问题的功能，有时间的人可以扩展这个功能。除了暴雪那个Hash函数外，其他部分copyleft。<br/><br/>
如果你觉得这是个繁琐的过程或你确定是我的朋友但无法通过它找回我的号码，或有其它的疑问，可以发邮件到我的邮箱netsharec at gmail.com。]]></content:encoded>
		<excerpt:encoded><![CDATA[上个月我换了个手机号码。事情是这样的：换了台Palm手机，换SIM卡的时候需要输入Pin码（我自己设置的，对于一个对信息极度敏感的人设置Pin口令是正常的），前两次输错，在明知道我已经找不到PUK码的情况下我还是贸然地将宝贵的最后一次Pin码输错了。这事坏就坏在我知道我的Keepass里是保存有Pin码的，回去打开Keepass一看发现PIN码原来只有四位数，而我全都输了六位数，前面四位是对的！造成这个悲剧的根本原因是对自己记忆力的错误估计。号码是找不回了，教训还当记着。花代价所换来的一点才智，抵过别人传授的数倍不止（富兰克林语）。我将记得截止到2010年SIM卡的PIN码只能是四位的。悲痛之余换了现在的新号码。<br/>
我的大部分联系人的号码都存储在原来的SIM卡内，本人才疏学浅未能破解SIM卡密码体系，无法把你们一一挖出来。因此写了个程序让大伙找到我。假如你有我原来的手机号码，或者即使没有原来的号码但掌握了我一些个人信息，都可以通过该程序得到我的新的手机号码。<br/>
基于安全考虑，当然不能采用下面的方法来获得新的号码：<br/>
1.验证问题答案;<br/>
2.if (Answer is correct) then<br/>
output new_num<br/>
3.else then<br/>
output "you fail";<br/>
4.return.<br/>
因为上面的代码运行时其实计算机已经把新号码存储在内存了，计算机知道的任何秘密，我们有办法是她告诉我们。通过逆向分析，使用几个跳转指令就是号码显示出来了。大概也没有人愿意吧秘密藏在程序里吧。我们可以构造一个具有以下性质的函数f：<br/>
f(待验证的信息) = 新号码 当且仅当待验证的信息等于旧号码。<br/><br/>
对于从验证信息途径获取新号码的原理就是密码学中的秘密共享协议。组合数学有道常见的题目，大概意思是有个强盗把宝藏藏在一个其他人都不知道的山洞里，只有通过藏宝图才能找到。这个强盗有7个继承人，为避免宝藏被独吞，他打算这样分配藏宝图给7个继承人：任意4人所持的藏宝图部分都能拼凑成一幅完整的藏宝图，不足4人在场的情况下没有办法拼出完整的藏宝图。问他应该怎样实现他的设想。密码学把这叫做(4,7)门限秘密共享方案。我的程序参考了Mignotte门限方案，只不过随意修改了权重：有的需要回答两个问题就能解出新号码，有的要回答三个。Mignotte方案的核心是中国剩余定理，程序里只需写个解同余式组的函数就可以了。<br/><br/>
为了保持我的熵不过多流失，将信息隔离使它们单向通信是必须的。比如你通过正确回答问题A和问题B获得我的手机新号码，但你不能通过求出的新号码逆向得到其它问题的答案，也不能通过任何信息逆向获取我的原来的号码和其他任何你之前不知道的信息。这只要用单向函数就能实现了。因为你输入的任何信息都要散列成整数以便下一步运算，所以我只要选用一个单向的Hash函数就行了。简单的Hash函数有很多，比如elfhash、P.J.weinberger  Hash等，但大多数单向性不好，而MD5、SHA-1算法又过于复杂，用在这里显得大材小用了，最后选用了Blizzard在MPQ中的Hash算法，据说是One-way Hash，较简单，只是版权协议未知。我将其修改几个参数后挪来作为非商业目的使用，也不知有没有侵权，若侵权了我马上移除这个Hash部分并愿意赔偿甚至赔偿10块钱。为了减少被暴力破解出新号码的可能，我对Hash值再取某个较小的整数的模，相当于减少了Hash函数的值域，这样就造成了更多的碰撞，在大多数情况下碰撞是有害的。<br/><br/>
这个程序上传在我的<a href="http://cid-a062cb69b403730a.office.live.com/self.aspx/.Documents/GetMyNum.zip" target="_blank">SkyDrive</a>(地址:http://cid-a062cb69b403730a.office.live.com/self.aspx/.Documents/GetMyNum.zip 或<a href="http://goo.gl/ulcB" target="_blank">http://goo.gl/ulcB</a>)上（Google文件共享网站疑被墙，故新注册了Windows live帐号），压缩包md5值：78EF060E16269272DACF1733882206ED     。包括交互式的C版本和用Delphi写的有界面的版本。那个用Delphi写的是很难看的。程序没有自定义功能，只适用于我自己的号码，不支持设置成求解别人号码和自定义问题的功能，有时间的人可以扩展这个功能。除了暴雪那个Hash函数外，其他部分copyleft。<br/><br/>
如果你觉得这是个繁琐的过程或你确定是我的朋友但无法通过它找回我的号码，或有其它的疑问，可以发邮件到我的邮箱netsharec at gmail.com。]]></excerpt:encoded>
		<wp:post_id>21</wp:post_id>
		<wp:post_date>2010-09-07 18:41:00</wp:post_date>
		<wp:post_date_gmt>2010-09-07 18:41:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%89%8b%e6%9c%ba%e5%8f%b7%e7%a0%81%e6%9b%b4%e6%8d%a2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%b8%ad%e5%9b%bd%e5%89%a9%e4%bd%99%e5%ae%9a%e7%90%86"><![CDATA[中国剩余定理]]></category>
		<category domain="post_tag" nicename="%e5%af%86%e7%a0%81%e5%ad%a6"><![CDATA[密码学]]></category>
		<category domain="category" nicename="%e5%b0%98%e5%b0%81"><![CDATA[尘封]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%a8%8b%e5%ba%8f"><![CDATA[程序]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>一维随机行走的距离期望</title>
		<link>http://hmgle.com/archives/22</link>
		<pubDate>Sat, 10 Jul 2010 22:05:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/22</guid>
		<description></description>
		<content:encoded><![CDATA[<div align="left"><font size="2">本文遵从<a target="_blank" href="http://creativecommons.org/licenses/by/2.5/cn/">CC版权协议</a> | by:<a href="http://sites.google.com/site/shangdang2917" target="_blank">hmgle</a></font></div>
<br/><font size="3">一 问题描述    <br/>
随机行走(Random walk)问题是许多现象的模型。下面是一个二维随机行走问题的描述：一个醉汉在空旷的广场游走。他走的每一步方向都是随机的，步长为L。经过n步之后，这个醉汉会在哪里？在《从一到无穷大》里，G.盖莫夫给出了离出发点可能的距离是L*sqrt(n)。<br/><br/>
对于一维随机行走的情况，我们考虑某个质点从数轴原点出发，每步以p=1/2的概率向正方向行走1个单位长度，同样以1/2的概率向负方向行走1个单位长度。这和抛一枚硬币出现正、反面事件的Bernoulli试验是一样的。以X表示行走n步后其中正方向的步数，由概率论的知识我们知道随机变量X服从参数为n,1/2的二项分布，即X~b(n,1/2),以K表示走了n步之后质点的位置坐标，则K := X - ( n - X )，即X := ( n + K )/2。 下面我们来求n步之后离原点的距离的数学期望E(abs(K))。<br/><br/>
二 问题分析<br/>
n步之后处于坐标k处的走法有binomial(n,(n+i)/2)种，这可以从二项式分布的性质直接得到，这里不再赘述。由对称性知道走到坐标i和到坐标-i的走法是一样多的，再由数学期望的定义我们列出E(abs(K))的表达式<br/>
E(abs(K)) = 1/2^n * sum(binomial(n,(n+i)/2)*abs(i),i=-n..n) = 1/2^(n-1) *sum(binomial(n,(n+i)/2)*i,i=1..n)<br/><br/>
引理2.1 sum(binomial(n,(n+i)/2)*i,i=1..n) = ceil(n/2)*binomial(n,ceil(n/2)),n∈Z+.<br/><br/>
证明:分别讨论n为偶数和n为奇数的情况：<br/>
a.偶数时，考虑sum((binomial(2*n,(2*n+i)/2)*i,i=1..2*n),n∈Z+。<br/>
sum((binomial(2*n,(2*n+i)/2)*i,i=1..2*n) = binomial(2*n,n+1)*2 + binomial(2*n,n+2)*4 + ... + binomial(2*n,n+n)*2*n = 2*(binomial(2*n,n+1)*1 + binomial(2*n,n+2)*2 + ... + binomial(2*n,n+n)*n)<br/>
我们要用到牛顿二项式定理的一个推论：<br/>
binomial(2*n,0)*0 + binomial(2*n,1)*1 + ... + binomial(2*n,2*n)*2*n = n*2^(2*n)<br/>
把上式左边分成两部分：<br/>
binomial(2*n,0)*0 + binomial(2*n,1)*1 + ... + binomial(2*n,2*n)*2*n = {binomial(2*n,1)*1 + binomial(2*n,2)*2 + ... + binomial(2*n,n)*n} + {binomial(2*n,n+1)*(n+1) + binomial(2*n,n+2)*(n+2) + ... + binomial(2*n,n+n)*(n+n)}<br/>
可以证明被花括号分开的两部分是相等的：我们先证明一个恒等式：binomial(2*n,i)*i = binomial(2*n,2*n-i+1)*(2*n-i+1)。<br/>
因为上式左边binomial(2*n,i)*i = (2*n)!/((i!)*(2*n-i)!)*i = (2*n)!/((i-1)!*(2*n-i)!),<br/>
右边binomial(2*n,2*n-i+1)*(2*n-i+1) = (2*n)!/((2*n-i+1)!*(i-1)!)*(2*n-i+1) = (2*n)!/((i-1)!*(2*n-i)!),<br/>
左边 = 右边，得证。<br/>
于是binomial(2*n,1)*1 = binomial(2*n,n+n)*(n+n),binomial(2*n,2)*2 = binomial(2*n,n+n-1)*(2*n-1),...,binomial(2*n,n)*n = binomial(2*n,n+1)*(n+1),因此：binomial(2*n,1)*1 + binomial(2*n,2)*2 + ... + binomial(2*n,n)*n = binomial(2*n,n+1)*(n+1) + binomial(2*n,n+2)*(n+2) + ... + binomial(2*n,n+n)*(n+n)，<br/>
这样我们得到这个等式：2*(binomial(2*n,n+1)*(n+1) + binomial(2*n,n+2)*(n+2) + ... + binomial(2*n,n+n)*(n+n)) = binomial(2*n,0)*0 + binomial(2*n,1)*1 + ... + binomial(2*n,2*n)*2*n = n*2^(2*n)<br/>
为达到求解sum((binomial(2*n,(2*n+i)/2)*i,i=1..2*n)的目标，进一步分离，得<br/>
2*(binomial(2*n,n+1)*(n+1) + binomial(2*n,n+2)*(n+2) + ... + binomial(2*n,n+n)*(n+n)) = 2*(binomial(2*n,n+1)*1 +binomial(2*n,n+2)*2 + ... + binomial(2*n,n+n)*n) + 2*n*(binomial(2*n,n+1) + binomial(2*n,n+2) + ... + (2*n,n+n)) = n*2^(2*n)    (1)<br/>
由二项式定理我们知道<br/>
sum(binomial(2*n,i),i=0..2*n) = binomial(2*n,0) + binomial(2*n,1) + ... + binomial(2*n,2*n) = 2^(2*n)<br/>
即<br/>
{binomial(2*n,0) + binomial(2*n,1) + ... + binomial(2*n,n-1)} + binomial(2*n,n) + {binomial(2*n,n+1) + binomial(2*n,n+2) + ... + binomial(2*n,n+n)} = binomial(2*n,n) + 2*{binomial(2*n,n+1) + binomial(2*n,n+2) + ... + binomial(2*n,n+n)} = 2^(2*n)<br/>
从而<br/>
2*{binomial(2*n,n+1) + binomial(2*n,n+2) + ... + binomial(2*n,n+n)} = 2^(2*n) - binomial(2*n,n)    (2)<br/>
(2)式代入(1)式，得<br/>
2*(binomial(2*n,n+1)*1 +binomial(2*n,n+2)*2 + ... + binomial(2*n,n+n)*n) + n*(2^(2*n) - binomial(2*n,n)) = n*2^(2*n)    (3)<br/>
由(3)式，得到<br/>
2*(binomial(2*n,n+1)*1 + binomial(2*n,n+2)*2 + ... + binomial(2*n,n+n)*n) = n*binomial(2*n,n)<br/>
于是<br/>
sum((binomial(2*n,(2*n+i)/2)*i,i=1..2*n) = n*binomial(2*n,n)<br/><br/>
b.奇数时也一样。考虑sum(binomial(2*n+1,(2*n+1+i)/2)*i,i=1..(2*n+1)),n∈{0,1,2,3,...}。<br/>
sum(binomial(2*n+1,(2*n+1+i)/2)*i,i=1..(2*n+1)) = binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*3 + binomial(2*n+1,n+3)*5 + ... + binomial(2*n+1,2*n+1)*(2*n+1)<br/>
由二项式定理<br/>
{binomial(2*n+1,0) + binomial(2*n+1,1) + ... +binomial(2*n+1,n)} + {binomial(2*n+1,n+1) + binomial(2*n+1,n+2) + ... + binomial(2*n+1,2*n+1)} = 2^(2*n+1)<br/>
花括号分成的两部分相等，于是<br/>
{binomial(2*n+1,n+1) + binomial(2*n+1,n+2) + ... + binomial(2*n+1,2*n+1)} = 2^(2*n)<br/>
所以<br/>
binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*3 + binomial(2*n+1,n+3)*5 + ... + binomial(2*n+1,2*n+1)*(2*n+1) = (binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*2 + ... + binomial(2*n+1,2*n+1)*(n+1))*2 - sum(binomial(2*n+1,n+i),i=1..n+1) = (binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*2 + ... + binomial(2*n+1,2*n+1)*(n+1))*2 - 2^(2*n)<br/>
下面我们求(binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*2 + ... + binomial(2*n+1,2*n+1)*(n+1))这部分：<br/>
我们知道<br/>
sum(binomial(2*n+1,i)*i,i=0..2*n+1) = (2*n+1)*2^(2*n)<br/>
上式左边可化为相等的两部分与中间项binomial(2*n+1,n+1)*(n+1)之和<br/>
sum(binomial(2*n+1,i)*i,i=0..2*n+1) = 2*(sum(binomial(2*n+1,n+i)*(n+i),i=2..n+1)) + binomial(2*n+1,n+1)*(n+1) = (2*n+1)*2^(2*n)<br/>
我们就得到了<br/>
sum(binomial(2*n+1,n+i)*i,i=1..n+1) = (2^(2*n)+binomial(2*n+1,n+1)*(n+1))/2<br/>
最后有<br/>
sum(binomial(2*n+1,n+i)*(2*i-1),i=1..n+1) = binomial(2*n+1,n+1)*(n+1)<br/>
综合a,b两种情况，就证明了sum(binomial(n,(n+i)/2)*i,i=1..n) = ceil(n/2)*binomial(n,ceil(n/2)),n∈Z+.    (QED)<br/><br/>
根据引理2.1，我们得到<br/>
E(abs(K)) = 1/2^n * sum(binomial(n,(n+i)/2)*abs(i),i=-n..n) = 1/2^(n-1) *sum(binomial(n,(n+i)/2)*i,i=1..n) = ceil(n/2)*binomial(n,ceil(n/2))/2^(n-1).<br/>
当n趋向于无穷大时，由<a target="_blank" href=":http://zh.wikipedia.org/zh-cn/%E6%96%AF%E7%89%B9%E9%9D%88%E5%85%AC%E5%BC%8F">Stirling公式</a>(link:http://zh.wikipedia.org/zh-cn/%E6%96%AF%E7%89%B9%E9%9D%88%E5%85%AC%E5%BC%8F)我们又得到<br/>
limit(E(abs(K)),n=infinity) = sqrt(2/pi)*sqrt(n)。</font>]]></content:encoded>
		<excerpt:encoded><![CDATA[<div align="left"><font size="2">本文遵从<a target="_blank" href="http://creativecommons.org/licenses/by/2.5/cn/">CC版权协议</a> | by:<a href="http://sites.google.com/site/shangdang2917" target="_blank">hmgle</a></font></div>
<br/><font size="3">一 问题描述    <br/>
随机行走(Random walk)问题是许多现象的模型。下面是一个二维随机行走问题的描述：一个醉汉在空旷的广场游走。他走的每一步方向都是随机的，步长为L。经过n步之后，这个醉汉会在哪里？在《从一到无穷大》里，G.盖莫夫给出了离出发点可能的距离是L*sqrt(n)。<br/><br/>
对于一维随机行走的情况，我们考虑某个质点从数轴原点出发，每步以p=1/2的概率向正方向行走1个单位长度，同样以1/2的概率向负方向行走1个单位长度。这和抛一枚硬币出现正、反面事件的Bernoulli试验是一样的。以X表示行走n步后其中正方向的步数，由概率论的知识我们知道随机变量X服从参数为n,1/2的二项分布，即X~b(n,1/2),以K表示走了n步之后质点的位置坐标，则K := X - ( n - X )，即X := ( n + K )/2。 下面我们来求n步之后离原点的距离的数学期望E(abs(K))。<br/><br/>
二 问题分析<br/>
n步之后处于坐标k处的走法有binomial(n,(n+i)/2)种，这可以从二项式分布的性质直接得到，这里不再赘述。由对称性知道走到坐标i和到坐标-i的走法是一样多的，再由数学期望的定义我们列出E(abs(K))的表达式<br/>
E(abs(K)) = 1/2^n * sum(binomial(n,(n+i)/2)*abs(i),i=-n..n) = 1/2^(n-1) *sum(binomial(n,(n+i)/2)*i,i=1..n)<br/><br/>
引理2.1 sum(binomial(n,(n+i)/2)*i,i=1..n) = ceil(n/2)*binomial(n,ceil(n/2)),n∈Z+.<br/><br/>
证明:分别讨论n为偶数和n为奇数的情况：<br/>
a.偶数时，考虑sum((binomial(2*n,(2*n+i)/2)*i,i=1..2*n),n∈Z+。<br/>
sum((binomial(2*n,(2*n+i)/2)*i,i=1..2*n) = binomial(2*n,n+1)*2 + binomial(2*n,n+2)*4 + ... + binomial(2*n,n+n)*2*n = 2*(binomial(2*n,n+1)*1 + binomial(2*n,n+2)*2 + ... + binomial(2*n,n+n)*n)<br/>
我们要用到牛顿二项式定理的一个推论：<br/>
binomial(2*n,0)*0 + binomial(2*n,1)*1 + ... + binomial(2*n,2*n)*2*n = n*2^(2*n)<br/>
把上式左边分成两部分：<br/>
binomial(2*n,0)*0 + binomial(2*n,1)*1 + ... + binomial(2*n,2*n)*2*n = {binomial(2*n,1)*1 + binomial(2*n,2)*2 + ... + binomial(2*n,n)*n} + {binomial(2*n,n+1)*(n+1) + binomial(2*n,n+2)*(n+2) + ... + binomial(2*n,n+n)*(n+n)}<br/>
可以证明被花括号分开的两部分是相等的：我们先证明一个恒等式：binomial(2*n,i)*i = binomial(2*n,2*n-i+1)*(2*n-i+1)。<br/>
因为上式左边binomial(2*n,i)*i = (2*n)!/((i!)*(2*n-i)!)*i = (2*n)!/((i-1)!*(2*n-i)!),<br/>
右边binomial(2*n,2*n-i+1)*(2*n-i+1) = (2*n)!/((2*n-i+1)!*(i-1)!)*(2*n-i+1) = (2*n)!/((i-1)!*(2*n-i)!),<br/>
左边 = 右边，得证。<br/>
于是binomial(2*n,1)*1 = binomial(2*n,n+n)*(n+n),binomial(2*n,2)*2 = binomial(2*n,n+n-1)*(2*n-1),...,binomial(2*n,n)*n = binomial(2*n,n+1)*(n+1),因此：binomial(2*n,1)*1 + binomial(2*n,2)*2 + ... + binomial(2*n,n)*n = binomial(2*n,n+1)*(n+1) + binomial(2*n,n+2)*(n+2) + ... + binomial(2*n,n+n)*(n+n)，<br/>
这样我们得到这个等式：2*(binomial(2*n,n+1)*(n+1) + binomial(2*n,n+2)*(n+2) + ... + binomial(2*n,n+n)*(n+n)) = binomial(2*n,0)*0 + binomial(2*n,1)*1 + ... + binomial(2*n,2*n)*2*n = n*2^(2*n)<br/>
为达到求解sum((binomial(2*n,(2*n+i)/2)*i,i=1..2*n)的目标，进一步分离，得<br/>
2*(binomial(2*n,n+1)*(n+1) + binomial(2*n,n+2)*(n+2) + ... + binomial(2*n,n+n)*(n+n)) = 2*(binomial(2*n,n+1)*1 +binomial(2*n,n+2)*2 + ... + binomial(2*n,n+n)*n) + 2*n*(binomial(2*n,n+1) + binomial(2*n,n+2) + ... + (2*n,n+n)) = n*2^(2*n)    (1)<br/>
由二项式定理我们知道<br/>
sum(binomial(2*n,i),i=0..2*n) = binomial(2*n,0) + binomial(2*n,1) + ... + binomial(2*n,2*n) = 2^(2*n)<br/>
即<br/>
{binomial(2*n,0) + binomial(2*n,1) + ... + binomial(2*n,n-1)} + binomial(2*n,n) + {binomial(2*n,n+1) + binomial(2*n,n+2) + ... + binomial(2*n,n+n)} = binomial(2*n,n) + 2*{binomial(2*n,n+1) + binomial(2*n,n+2) + ... + binomial(2*n,n+n)} = 2^(2*n)<br/>
从而<br/>
2*{binomial(2*n,n+1) + binomial(2*n,n+2) + ... + binomial(2*n,n+n)} = 2^(2*n) - binomial(2*n,n)    (2)<br/>
(2)式代入(1)式，得<br/>
2*(binomial(2*n,n+1)*1 +binomial(2*n,n+2)*2 + ... + binomial(2*n,n+n)*n) + n*(2^(2*n) - binomial(2*n,n)) = n*2^(2*n)    (3)<br/>
由(3)式，得到<br/>
2*(binomial(2*n,n+1)*1 + binomial(2*n,n+2)*2 + ... + binomial(2*n,n+n)*n) = n*binomial(2*n,n)<br/>
于是<br/>
sum((binomial(2*n,(2*n+i)/2)*i,i=1..2*n) = n*binomial(2*n,n)<br/><br/>
b.奇数时也一样。考虑sum(binomial(2*n+1,(2*n+1+i)/2)*i,i=1..(2*n+1)),n∈{0,1,2,3,...}。<br/>
sum(binomial(2*n+1,(2*n+1+i)/2)*i,i=1..(2*n+1)) = binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*3 + binomial(2*n+1,n+3)*5 + ... + binomial(2*n+1,2*n+1)*(2*n+1)<br/>
由二项式定理<br/>
{binomial(2*n+1,0) + binomial(2*n+1,1) + ... +binomial(2*n+1,n)} + {binomial(2*n+1,n+1) + binomial(2*n+1,n+2) + ... + binomial(2*n+1,2*n+1)} = 2^(2*n+1)<br/>
花括号分成的两部分相等，于是<br/>
{binomial(2*n+1,n+1) + binomial(2*n+1,n+2) + ... + binomial(2*n+1,2*n+1)} = 2^(2*n)<br/>
所以<br/>
binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*3 + binomial(2*n+1,n+3)*5 + ... + binomial(2*n+1,2*n+1)*(2*n+1) = (binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*2 + ... + binomial(2*n+1,2*n+1)*(n+1))*2 - sum(binomial(2*n+1,n+i),i=1..n+1) = (binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*2 + ... + binomial(2*n+1,2*n+1)*(n+1))*2 - 2^(2*n)<br/>
下面我们求(binomial(2*n+1,n+1)*1 + binomial(2*n+1,n+2)*2 + ... + binomial(2*n+1,2*n+1)*(n+1))这部分：<br/>
我们知道<br/>
sum(binomial(2*n+1,i)*i,i=0..2*n+1) = (2*n+1)*2^(2*n)<br/>
上式左边可化为相等的两部分与中间项binomial(2*n+1,n+1)*(n+1)之和<br/>
sum(binomial(2*n+1,i)*i,i=0..2*n+1) = 2*(sum(binomial(2*n+1,n+i)*(n+i),i=2..n+1)) + binomial(2*n+1,n+1)*(n+1) = (2*n+1)*2^(2*n)<br/>
我们就得到了<br/>
sum(binomial(2*n+1,n+i)*i,i=1..n+1) = (2^(2*n)+binomial(2*n+1,n+1)*(n+1))/2<br/>
最后有<br/>
sum(binomial(2*n+1,n+i)*(2*i-1),i=1..n+1) = binomial(2*n+1,n+1)*(n+1)<br/>
综合a,b两种情况，就证明了sum(binomial(n,(n+i)/2)*i,i=1..n) = ceil(n/2)*binomial(n,ceil(n/2)),n∈Z+.    (QED)<br/><br/>
根据引理2.1，我们得到<br/>
E(abs(K)) = 1/2^n * sum(binomial(n,(n+i)/2)*abs(i),i=-n..n) = 1/2^(n-1) *sum(binomial(n,(n+i)/2)*i,i=1..n) = ceil(n/2)*binomial(n,ceil(n/2))/2^(n-1).<br/>
当n趋向于无穷大时，由<a target="_blank" href=":http://zh.wikipedia.org/zh-cn/%E6%96%AF%E7%89%B9%E9%9D%88%E5%85%AC%E5%BC%8F">Stirling公式</a>(link:http://zh.wikipedia.org/zh-cn/%E6%96%AF%E7%89%B9%E9%9D%88%E5%85%AC%E5%BC%8F)我们又得到<br/>
limit(E(abs(K)),n=infinity) = sqrt(2/pi)*sqrt(n)。</font>]]></excerpt:encoded>
		<wp:post_id>22</wp:post_id>
		<wp:post_date>2010-07-10 22:05:00</wp:post_date>
		<wp:post_date_gmt>2010-07-10 22:05:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%80%e7%bb%b4%e9%9a%8f%e6%9c%ba%e8%a1%8c%e8%b5%b0%e7%9a%84%e8%b7%9d%e7%a6%bb%e6%9c%9f%e6%9c%9b</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e9%9a%8f%e6%9c%ba%e6%b8%b8%e8%b5%b0"><![CDATA[随机游走]]></category>
		<category domain="category" nicename="%e9%9d%a2%e5%a3%81"><![CDATA[面壁]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>求大数阶乘的最后一个非零数字</title>
		<link>http://hmgle.com/archives/23</link>
		<pubDate>Sat, 31 Oct 2009 22:04:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/23</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://www.mathpages.com/home/kmath489.htm">http://www.mathpages.com/home/kmath489.htm</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[<a href="http://www.mathpages.com/home/kmath489.htm">http://www.mathpages.com/home/kmath489.htm</a>]]></excerpt:encoded>
		<wp:post_id>23</wp:post_id>
		<wp:post_date>2009-10-31 22:04:00</wp:post_date>
		<wp:post_date_gmt>2009-10-31 22:04:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%b1%82%e5%a4%a7%e6%95%b0%e9%98%b6%e4%b9%98%e7%9a%84%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e9%9d%9e%e9%9b%b6%e6%95%b0%e5%ad%97</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mathematics"><![CDATA[mathematics]]></category>
		<category domain="post_tag" nicename="%e6%8a%80%e5%b7%a7"><![CDATA[技巧]]></category>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Kiwi</title>
		<link>http://hmgle.com/archives/24</link>
		<pubDate>Sun, 15 Mar 2009 17:27:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/24</guid>
		<description></description>
		<content:encoded><![CDATA[<embed height="390" width="450" pluginspage="http://www.macromedia.com/go/getflashplayer" src="http://www.youtube.com/v/sdUUx5FdySs" wmode="window" play="true" loop="false" menu="false"/><br/>
来源：http://www.youtube.com/watch?v=sdUUx5FdySs]]></content:encoded>
		<excerpt:encoded><![CDATA[<embed height="390" width="450" pluginspage="http://www.macromedia.com/go/getflashplayer" src="http://www.youtube.com/v/sdUUx5FdySs" wmode="window" play="true" loop="false" menu="false"/><br/>
来源：http://www.youtube.com/watch?v=sdUUx5FdySs]]></excerpt:encoded>
		<wp:post_id>24</wp:post_id>
		<wp:post_date>2009-03-15 17:27:00</wp:post_date>
		<wp:post_date_gmt>2009-03-15 17:27:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>kiwi</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%a2%99"><![CDATA[墙]]></category>
		<category domain="post_tag" nicename="%e6%84%9f%e4%ba%ba"><![CDATA[感人]]></category>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e8%a7%86%e9%a2%91"><![CDATA[视频]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>象棋排局：将Nim游戏策略应用其中</title>
		<link>http://hmgle.com/archives/25</link>
		<pubDate>Tue, 05 Aug 2008 21:45:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/25</guid>
		<description></description>
		<content:encoded><![CDATA[<div></div>
<a href="http://hmgle.com/wp-content/uploads/2008/08/nim_0.jpg"><img class="alignnone size-full wp-image-263" title="nim_0" src="http://hmgle.com/wp-content/uploads/2008/08/nim_0.jpg" alt="" width="363" height="402" /></a>

<span style="font-size: small;">上面的这局对称的排局不知来源于古谱还是现代排局，曾经在一本国内科普读物（</span>
<p class="MsoNormal"><s><span>现在忘记叫什么了，电子版的，在我的硬盘上有，可惜晾在家里了</span></s> <span>是谈祥柏的《趣味对策论》，蒋声的《趣味代数》也有,最早可能是古谱《竹香斋》</span><s></s></p>
<span style="font-size: small;">）看过，如果是出自古谱那原作者就相当不简单了，要知道Nim游戏理论建立到现在不过100多年时间。象棋不属于Nim游戏，因为Nim游戏的一个必要条件是对于游戏的任一种局面，可移动的集合只取决于当前局面而与游戏者无关，但这个局面的确可用Nim游戏策略来解决。</span>

从棋局中我们看到，每方可移动棋子只有三种：两个炮，边兵（卒），对应的位于同一纵线上，且不能离开当前的纵线。我们把可移动棋子所在的三条线分成三组，炮所在的组中，我们j记下对应棋子的间隔数，兵（卒）所在的组中，因为间隔一格后就不能再前进了，所以把间隔数减一。考虑棋子后退（把间隔数增大，相当于Nim游戏中放入石块到堆中）是有限的，再想想Nim游戏的模型，这不正好是3-堆Nim取物游戏吗？各堆大小分别是1，4，4。表示成二进制为001，100，100，是非平衡的Nim游戏，即N-position，先手有必胜策略，可以炮七退一变成101、100，001或挺兵变成000，100，100这样的P-position局面，以下无论后手方如何走都将把局面导向N-position位置。

这是一局少见的排局，可能因为存在数学策略的缘故，基于计算局势分经过优化而选择棋步的棋软很难得出正解。用奇兵测试，即使不限制搜索时间和搜索层数也是临败几步前才算到结果，而对于大多数的充满陷阱的江湖棋局，是比较容易可以得到正解的：例如下面的对称的排局，大家可以试试，它叫五鼠闹东京；
<div><a href="http://hmgle.com/wp-content/uploads/2008/08/five_mice.jpg"><img class="alignnone size-full wp-image-264" title="five_mice" src="http://hmgle.com/wp-content/uploads/2008/08/five_mice.jpg" alt="" width="359" height="399" />
</a>几个介绍Nim游戏的链接：<a href="http://en.wikipedia.org/wiki/Nim" target="_blank">http://en.wikipedia.org/wiki/Nim</a>
<a href="http://www.cut-the-knot.org/ctk/May2001.shtml" target="_blank">http://www.cut-the-knot.org/ctk/May2001.shtml</a>
<a href="http://mathworld.wolfram.com/Nim.html" target="_blank">http://mathworld.wolfram.com/Nim.html</a>

</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/8b249e44ddd1f595b3b7dc92.jpg" small="0" class="blogimg"/></div>
<font size="3">上面的这局对称的排局不知来源于古谱还是现代排局，曾经在一本国内科普读物（</font>
 
 
 
 
 
<p class="MsoNormal"><s><span>现在忘记叫什么了，电子版的，在我的硬盘上有，可惜晾在家里了</span></s> <span>是谈祥柏的《趣味对策论》，蒋声的《趣味代数》也有,最早可能是古谱《竹香斋》</span><s><span/></s></p>
<font size="3">）看过，如果是出自古谱那原作者就相当不简单了，要知道Nim游戏理论建立到现在不过100多年时间。象棋不属于Nim游戏，因为Nim游戏的一个必要条件是对于游戏的任一种局面，可移动的集合只取决于当前局面而与游戏者无关，但这个局面的确可用Nim游戏策略来解决。<br/>
从棋局中我们看到，每方可移动棋子只有三种：两个炮，边兵（卒），对应的位于同一纵线上，且不能离开当前的纵线。我们把可移动棋子所在的三条线分成三组，炮所在的组中，我们j记下对应棋子的间隔数，兵（卒）所在的组中，因为间隔一格后就不能再前进了，所以把间隔数减一。考虑棋子后退（把间隔数增大，相当于Nim游戏中放入石块到堆中）是有限的，再想想Nim游戏的模型，这不正好是3-堆Nim取物游戏吗？各堆大小分别是1，4，4。表示成二进制为001，100，100，是非平衡的Nim游戏，即N-position，先手有必胜策略，可以炮七退一变成101、100，001或挺兵变成000，100，100这样的P-position局面，以下无论后手方如何走都将把局面导向N-position位置。<br/>
这是一局少见的排局，可能因为存在数学策略的缘故，基于计算局势分经过优化而选择棋步的棋软很难得出正解。用奇兵测试，即使不限制搜索时间和搜索层数也是临败几步前才算到结果，而对于大多数的充满陷阱的江湖棋局，是比较容易可以得到正解的：例如下面的对称的排局，大家可以试试，它叫五鼠闹东京；</font><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/3dc6870ef91cf8f034d12265.jpg" small="0" class="blogimg"/><br/>
几个介绍Nim游戏的链接：<a target="_blank" href="http://en.wikipedia.org/wiki/Nim">http://en.wikipedia.org/wiki/Nim</a><br/><a target="_blank" href="http://www.cut-the-knot.org/ctk/May2001.shtml">http://www.cut-the-knot.org/ctk/May2001.shtml</a><br/><a target="_blank" href="http://mathworld.wolfram.com/Nim.html">http://mathworld.wolfram.com/Nim.html</a></div>]]></excerpt:encoded>
		<wp:post_id>25</wp:post_id>
		<wp:post_date>2008-08-05 21:45:00</wp:post_date>
		<wp:post_date_gmt>2008-08-05 21:45:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%b1%a1%e6%a3%8b%e6%8e%92%e5%b1%80%ef%bc%9a%e5%b0%86nim%e6%b8%b8%e6%88%8f%e7%ad%96%e7%95%a5%e5%ba%94%e7%94%a8%e5%85%b6%e4%b8%ad</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="nim"><![CDATA[Nim]]></category>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="post_tag" nicename="%e6%a3%8b%e7%b1%bb"><![CDATA[棋类]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e6%b8%b8%e6%88%8f"><![CDATA[游戏]]></category>
		<category domain="post_tag" nicename="%e7%ad%96%e7%95%a5"><![CDATA[策略]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>一些免费的（部分是开源的甚至自由的）有限元分析软件</title>
		<link>http://hmgle.com/archives/26</link>
		<pubDate>Wed, 18 Jun 2008 15:40:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/26</guid>
		<description></description>
		<content:encoded><![CDATA[<p class="0" style="text-align: justify;"><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">有限元法是以变分发为基础的，它的思想是将物体离散化进而达到求解目的，打个比方：我们要求圆的面积，但不知道圆的面积公式，而三角形的面积我们是熟悉并能精确求解的，我们可以以圆心为中心近似地把圆分割成有限个三角形（<span style="color: #99ccff;">离散化</span>），每个三角形就被称之为<span style="color: #99ccff;">单元</span>，将单元的集合称为<span style="color: #99ccff;">网格</span>，引入单元的计算面积的方程（单元方程），然后集合单元方程，就可以得到圆的面积的近似解，只要网格划分得足够细，就可以确保得到足够精确的解。</span></span></p>
<p class="0" style="text-align: justify;"><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">有限元分析（FEA）软件随着</span></span><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">有限元</span></span><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">理论的完善和计算机的发展而出现并发展。目前已有大量的可进行结构、流体、热、电场、磁场、声场分析的大型</span></span><span style="color: #ff0000;"><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">商业</span></span></span><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">通用有限元分析软件</span></span><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">。最早的Adina是开放源代码的<span style="background-color: #000000;">（那个时代没有开源之说，微软</span></span></span><span style="font-size: 10.5pt; background-color: #000000;"><span style="font-family: 宋体;">诞生</span></span><span style="font-size: 10.5pt;"><span style="font-family: 宋体;"><span style="background-color: #000000;">后开始变糟糕）</span>，</span></span><span style="font-size: 10.5pt;">Hacker<span style="font-family: 宋体;">将其改进并继续自由发放。微软来了，在利益的驱动下，商人来了，大量技术人员被聚集起来，于是出现MSC，Nastran，Abaqus，Ansys，LS-DYNA，……Cracker随着微软的诞生而兴起，他们沉溺于破坏和破解中不可自拔，于是盗版肆虐。对此我感到矛盾，我们应该持什么的态度？唾弃？别忘了我们机房的主机、教育机构的ftp站点、你的个人电脑里装的是什么（不用Windows的跳过，并致以崇高的敬意），这不完全是我们的错……</span></span></p>
<p class="0" style="text-align: justify;"><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">用<a href="http://www.google.com" target="_blank">Google</a>搜索“<a href="http://www.google.cn/search?complete=1&amp;hl=zh-CN&amp;q=free+fea&amp;btnG=Google+%E6%90%9C%E7%B4%A2&amp;meta=&amp;aq=f" target="_blank">free fea</a>”，还是可以找到一些免费的（尽管我们期望<span style="color: #000000;">free</span>是<span style="color: #99ccff;">自由</span>的）有限元分析软件。打开<a href="http://www.freebyte.com/cad/fea.htm" target="_blank">http://www.freebyte.com/cad/fea.htm</a>页面可以看到，它们之中很多只有<span style="color: #ff0000;">Windows</span>版本的。对比<span style="color: #ff0000;">商业</span>的你可能不屑，功能少又不稳定，cpu占用奇高，输错一个数字可能使你的电脑死机，一顿折腾后可能给你一个匪夷所思的结果，但我推荐它们仅仅因为它们不是私有的，有的还是开源的，特别是Linux平台上的，使用它们你不再产生像使用盗版时产生的负罪感，你阅读它们的源代码，学习他们的优点，找出程序中的bug并改进它们，自由发放给别的用户使用，分享你的所得，你就又达到一个新境界了。</span></span></p>
<p class="0" style="text-align: justify;"><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">下面的<a href="http://impact.sourceforge.net/" target="_blank">Impact</a>，采用GPL协议，你要先安装java环境才能使用。支持大变形分析。
<a href="http://hmgle.com/wp-content/uploads/2008/06/Impact.jpg"><img class="alignnone size-full wp-image-253" title="Impact" src="http://hmgle.com/wp-content/uploads/2008/06/Impact.jpg" alt="" width="849" height="619" /></a>
</span></span></p>

<div></div>
<p class="0" style="text-align: justify;"><span style="font-size: 10.5pt;"><a href="http://www.autofea.com/Download-FEA-software.htm" target="_blank">JL-Analyzer</a><span style="font-family: 宋体;">：仅仅免费，具有良好的建模功能，支持非线性和热分析。例如分析一机械部件：</span></span></p>
<p class="0" style="text-align: justify;"><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">1.建立有限元模型并加载，如图：
<a href="http://hmgle.com/wp-content/uploads/2008/06/JL-Analyzer_0.jpg"><img class="alignnone size-full wp-image-254" title="JL-Analyzer_0" src="http://hmgle.com/wp-content/uploads/2008/06/JL-Analyzer_0.jpg" alt="" width="951" height="703" /></a>
</span></span></p>

<div></div>
2.求解；

3.读取结果：

位移：
<a href="http://hmgle.com/wp-content/uploads/2008/06/results1.jpg"><img class="alignnone size-full wp-image-255" title="results1" src="http://hmgle.com/wp-content/uploads/2008/06/results1.jpg" alt="" width="924" height="702" /></a>
<div></div>
y方向应力：
<a href="http://hmgle.com/wp-content/uploads/2008/06/results2.jpg"><img class="alignnone size-full wp-image-256" title="results2" src="http://hmgle.com/wp-content/uploads/2008/06/results2.jpg" alt="" width="922" height="699" /></a>
<div></div>
<p class="0" style="text-align: justify;"><span style="font-size: 10.5pt;"><a href="http://www.cuylaerts.net/" target="_blank">Analysis for Windows</a><span style="font-family: 宋体;">：这个其实只用到矩阵位移法，用Delphi开发的，支持杆单元，<a href="http://www.freebyte.com/cad/screen/analysisforwindows.jpg" target="_blank">空间结构</a>。这里给出的是没有交互界面的版本（只支持平面结构），我通过计算上次的<a href="http://hi.baidu.com/hmgle/blog/item/46569b0f04c3a9eeaa645750.html" target="_blank">一个算例</a>得出一个不大正确的结果：
<a href="http://hmgle.com/wp-content/uploads/2008/06/ana1.jpg"><img class="alignnone size-full wp-image-257" title="模型" src="http://hmgle.com/wp-content/uploads/2008/06/ana1.jpg" alt="" width="639" height="507" />
</a>
<a href="http://hmgle.com/wp-content/uploads/2008/06/ana2.jpg"><img class="alignnone size-full wp-image-258" title="位移" src="http://hmgle.com/wp-content/uploads/2008/06/ana2.jpg" alt="" width="639" height="507" /></a>

<a href="http://hmgle.com/wp-content/uploads/2008/06/ana3.jpg"><img class="alignnone size-full wp-image-259" title="result" src="http://hmgle.com/wp-content/uploads/2008/06/ana3.jpg" alt="" width="696" height="392" /></a> </span></span></p>

<div></div>
<div></div>
<span style="font-size: 10.5pt;"><span style="font-family: 宋体;">和理论解相差百分之十以上。</span></span>
<p class="0" style="text-align: justify;"><span style="font-size: 10.5pt;"><span style="font-family: 宋体;">
</span></span></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[<p style="text-align: justify;" class="0"><span style="font-size: 10.5pt;"><font face="宋体">有限元法是以变分发为基础的，它的思想是将物体离散化进而达到求解目的，打个比方：我们要求圆的面积，但不知道圆的面积公式，而三角形的面积我们是熟悉并能精确求解的，我们可以以圆心为中心近似地把圆分割成有限个三角形（<font color="#99ccff">离散化</font>），每个三角形就被称之为<font color="#99ccff">单元</font>，将单元的集合称为<font color="#99ccff">网格</font>，引入单元的计算面积的方程（单元方程），然后集合单元方程，就可以得到圆的面积的近似解，只要网格划分得足够细，就可以确保得到足够精确的解。</font></span></p>
<p style="text-align: justify;" class="0"><span style="font-size: 10.5pt;"><font face="宋体">有限元分析（FEA）软件随着</font></span><span style="font-size: 10.5pt;"><font face="宋体">有限元</font></span><span style="font-size: 10.5pt;"><font face="宋体">理论的完善和计算机的发展而出现并发展。目前已有大量的可进行结构、流体、热、电场、磁场、声场分析的大型</font></span><font color="#ff0000"><span style="font-size: 10.5pt;"><font face="宋体">商业</font></span></font><span style="font-size: 10.5pt;"><font face="宋体">通用有限元分析软件</font></span><span style="font-size: 10.5pt;"><font face="宋体">。最早的Adina是开放源代码的<span style="background-color: rgb(0, 0, 0);">（那个时代没有开源之说，微软</span></font></span><span style="font-size: 10.5pt; background-color: rgb(0, 0, 0);"><font face="宋体">诞生</font></span><span style="font-size: 10.5pt;"><font face="宋体"><span style="background-color: rgb(0, 0, 0);">后开始变糟糕）</span>，</font></span><span style="font-size: 10.5pt;">Hacker<font face="宋体">将其改进并继续自由发放。微软来了，在利益的驱动下，商人来了，大量技术人员被聚集起来，于是出现MSC，Nastran，Abaqus，Ansys，LS-DYNA，……Cracker随着微软的诞生而兴起，他们沉溺于破坏和破解中不可自拔，于是盗版肆虐。对此我感到矛盾，我们应该持什么的态度？唾弃？别忘了我们机房的主机、教育机构的ftp站点、你的个人电脑里装的是什么（不用Windows的跳过，并致以崇高的敬意），这不完全是我们的错……</font></span></p>
<p style="text-align: justify;" class="0"><span style="font-size: 10.5pt;"><font face="宋体">用<a href="http://www.google.com" target="_blank">Google</a>搜索“<a href="http://www.google.cn/search?complete=1&amp;hl=zh-CN&amp;q=free+fea&amp;btnG=Google+%E6%90%9C%E7%B4%A2&amp;meta=&amp;aq=f" target="_blank">free fea</a>”，还是可以找到一些免费的（尽管我们期望<font color="#000000">free</font>是<font color="#99ccff">自由</font>的）有限元分析软件。打开<a href="http://www.freebyte.com/cad/fea.htm" target="_blank">http://www.freebyte.com/cad/fea.htm</a>页面可以看到，它们之中很多只有<font color="#ff0000">Windows</font>版本的。对比<font color="#ff0000">商业</font>的你可能不屑，功能少又不稳定，cpu占用奇高，输错一个数字可能使你的电脑死机，一顿折腾后可能给你一个匪夷所思的结果，但我推荐它们仅仅因为它们不是私有的，有的还是开源的，特别是Linux平台上的，使用它们你不再产生像使用盗版时产生的负罪感，你阅读它们的源代码，学习他们的优点，找出程序中的bug并改进它们，自由发放给别的用户使用，分享你的所得，你就又达到一个新境界了。</font></span></p>
<p style="text-align: justify;" class="0"><span style="font-size: 10.5pt;"><font face="宋体">下面的<a target="_blank" href="http://impact.sourceforge.net/">Impact</a>，采用GPL协议，你要先安装java环境才能使用。支持大变形分析。<br/><div forimg="1"><a href="http://hiphotos.baidu.com/hmgle/pic/item/5702c4ed21d91a5a79f055af.jpg" target="_blank"><img border="0" src="http://hiphotos.baidu.com/hmgle/abpic/item/5702c4ed21d91a5a79f055af.jpg" small="1" class="blogimg"/></a></div>
</font></span></p>
<p style="text-align: justify;" class="0"><span style="font-size: 10.5pt;"><a target="_blank" href="http://www.autofea.com/Download-FEA-software.htm">JL-Analyzer</a><font face="宋体">：仅仅免费，具有良好的建模功能，支持非线性和热分析。例如分析一机械部件：</font></span></p>
<p style="text-align: justify;" class="0"><span style="font-size: 10.5pt;"><font face="宋体">1.建立有限元模型并加载，如图：<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/7ca01a2d3cf53121359bf78a.jpg" small="0" class="blogimg"/></div>
2.求解；<br/>
3.读取结果：<br/>
位移：<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/32249ccc733e940500e92891.jpg" small="0" class="blogimg"/></div>
y方向应力：<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/2903d9cd016787440eb34598.jpg" small="0" class="blogimg"/></div>
</font></span></p>
<p style="text-align: justify;" class="0"><span style="font-size: 10.5pt;"><a target="_blank" href="http://www.cuylaerts.net/">Analysis for Windows</a><font face="宋体">：这个其实只用到矩阵位移法，用Delphi开发的，支持杆单元，<a target="_blank" href="http://www.freebyte.com/cad/screen/analysisforwindows.jpg">空间结构</a>。这里给出的是没有交互界面的版本（只支持平面结构），我通过计算上次的<a href="http://hi.baidu.com/hmgle/blog/item/46569b0f04c3a9eeaa645750.html" target="_blank">一个算例</a>得出一个不大正确的结果：<br/><div forimg="1">
<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/e425ee00e05ad404708b656d.jpg" small="0" class="blogimg"/></div>
<div forimg="1"><a href="http://hiphotos.baidu.com/hmgle/pic/item/ebcf90c3f7331040b219a875.jpg" target="_blank">
<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/34c120305927a28ca8018e76.jpg" small="0" class="blogimg"/></div>
<div forimg="1">
<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/16823d08c3f210c463d98671.jpg" small="0" class="blogimg"/></div>
</div>
</a><span style="font-size: 10.5pt;"><font face="宋体">和理论解相差百分之十以上。</font></span></div>
</div>
<br/><br/></font></span></p>
<p style="text-align: justify;" class="0"><span style="font-size: 10.5pt;"><font face="宋体"><br/></font></span></p>
<p style="text-indent: 21pt; text-align: justify;" class="0"> </p>]]></excerpt:encoded>
		<wp:post_id>26</wp:post_id>
		<wp:post_date>2008-06-18 15:40:00</wp:post_date>
		<wp:post_date_gmt>2008-06-18 15:40:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%80%e4%ba%9b%e5%85%8d%e8%b4%b9%e7%9a%84%ef%bc%88%e9%83%a8%e5%88%86%e6%98%af%e5%bc%80%e6%ba%90%e7%9a%84%e7%94%9a%e8%87%b3%e8%87%aa%e7%94%b1%e7%9a%84%ef%bc%89%e6%9c%89%e9%99%90%e5%85%83%e5%88%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="fea"><![CDATA[FEA]]></category>
		<category domain="post_tag" nicename="%e5%bc%80%e6%ba%90"><![CDATA[开源]]></category>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<category domain="post_tag" nicename="%e6%9c%89%e9%99%90%e5%85%83"><![CDATA[有限元]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>残存在记忆的电视剧</title>
		<link>http://hmgle.com/archives/28</link>
		<pubDate>Tue, 03 Jun 2008 23:55:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/28</guid>
		<description></description>
		<content:encoded><![CDATA[《海灯法师》是有残留记忆的最早的电视剧，那时还没念幼儿园吧，隐约只记得一个模糊的情景了：和尚，门，血，手指，一声惨叫（不太确定）。

看《西游记》时大概三四岁，现在回想起来还很清晰：第一个镜头是在黄（还是王？）土根的铺子（那时叫合作社）里看的，姐姐带我，一大群人在里面，那时孙悟空在单手（绝对是单手）舞棍，很得意的样子。

《封神榜》和《绝代双骄》哪个先看已不记得，只记得看《封神榜》第一集是是非常无趣的，纣王祭祀仪式，八点开始播放，我当时看得眼睛都睁不开了，但还要坚持到结束。之后幼儿园分为两帮，我方称呼我为大王，可惜老被干。

《绝代双骄》开了港产片在大陆流行的先河，剧情虽超出我的理解力，但觉得好看，有点印象的片段是好像是黑夜里小鱼儿在一个亭子里对不知哪个说：我抵死（该死）。不知为啥对这句话记得这么清楚。

《雪山飞狐》也是在幼儿园期间看到（我四岁到六岁这三年都在幼儿园混），以后上小学时又有机会看了一遍。等稍微懂得一点剧情的时候发现以后很少有机会看到了，现在证明果然如此。

一年级《葫芦兄弟》。对动画卡通片记忆不深，连环画反倒很有印象，那里面的剑画得线条棱角分明，很锋利的样子。

晚上《太极张三丰》。今天又听了十几遍主题歌：

风中柳丝舒懒腰

几点絮飞飘也飘

谁能力抗劲风

为何梁木折腰

柳絮却可轻卸掉


于世上

也知颠沛未能料

傲然笑

冷观得失感玄妙

风惊雨急自巍立

扁舟也可渡狂潮

以柔力博千斤

淡然随遇变招

雨后红日千里耀

下面片头的情景当时羡慕无比，神幻飘逸的手法令人向往。
<div></div>
<a href="http://hmgle.com/wp-content/uploads/2008/06/shadow.jpg"><img class="alignnone size-full wp-image-270" title="shadow" src="http://hmgle.com/wp-content/uploads/2008/06/shadow.jpg" alt="" width="352" height="288" /></a>

小学：《小龙人》，他们都长大了吗？

未完待续。期间杨栋在看《莲花争霸》，听着主题曲觉得熟悉，所以敲下以上文字。]]></content:encoded>
		<excerpt:encoded><![CDATA[《海灯法师》是有残留记忆的最早的电视剧，那时还没念幼儿园吧，隐约只记得一个模糊的情景了：和尚，门，血，手指，一声惨叫（不太确定）。<br/>
看《西游记》时大概三四岁，现在回想起来还很清晰：第一个镜头是在黄（还是王？）土根的铺子（那时叫合作社）里看的，姐姐带我，一大群人在里面，那时孙悟空在单手（绝对是单手）舞棍，很得意的样子。<br/>
《封神榜》和《绝代双骄》哪个先看已不记得，只记得看《封神榜》第一集是是非常无趣的，纣王祭祀仪式，八点开始播放，我当时看得眼睛都睁不开了，但还要坚持到结束。之后幼儿园分为两帮，我方称呼我为大王，可惜老被干。<br/>
《绝代双骄》开了港产片在大陆流行的先河，剧情虽超出我的理解力，但觉得好看，有点印象的片段是好像是黑夜里小鱼儿在一个亭子里对不知哪个说：我抵死（该死）。不知为啥对这句话记得这么清楚。<br/>
《雪山飞狐》也是在幼儿园期间看到（我四岁到六岁这三年都在幼儿园混），以后上小学时又有机会看了一遍。等稍微懂得一点剧情的时候发现以后很少有机会看到了，现在证明果然如此。<br/>
一年级《葫芦兄弟》。对动画卡通片记忆不深，连环画反倒很有印象，那里面的剑画得线条棱角分明，很锋利的样子。<br/>
晚上《太极张三丰》。今天又听了十几遍主题歌：<br/>
风中柳丝舒懒腰<br/>
几点絮飞飘也飘<br/>
谁能力抗劲风<br/>
为何梁木折腰<br/>
柳絮却可轻卸掉<br/><br/>
于世上<br/>
也知颠沛未能料<br/>
傲然笑<br/>
冷观得失感玄妙<br/>
风惊雨急自巍立<br/>
扁舟也可渡狂潮<br/>
以柔力博千斤<br/>
淡然随遇变招<br/>
雨后红日千里耀<br/>
下面片头的情景当时羡慕无比，神幻飘逸的手法令人向往。<br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hmgle/pic/item/cbd35f59bf2cb23e2934f06b.jpg"/></div>
<br/>
小学：《小龙人》，他们都长大了吗？<br/>
未完待续。期间杨栋在看《莲花争霸》，听着主题曲觉得熟悉，所以敲下以上文字。]]></excerpt:encoded>
		<wp:post_id>28</wp:post_id>
		<wp:post_date>2008-06-03 23:55:00</wp:post_date>
		<wp:post_date_gmt>2008-06-03 23:55:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%ae%8b%e5%ad%98%e5%9c%a8%e8%ae%b0%e5%bf%86%e7%9a%84%e7%94%b5%e8%a7%86%e5%89%a7</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%b0%98%e5%b0%81"><![CDATA[尘封]]></category>
		<category domain="post_tag" nicename="%e6%80%80%e6%97%a7"><![CDATA[怀旧]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%94%b5%e8%a7%86%e5%89%a7"><![CDATA[电视剧]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>回来了</title>
		<link>http://hmgle.com/archives/29</link>
		<pubDate>Tue, 03 Jun 2008 08:16:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/29</guid>
		<description></description>
		<content:encoded><![CDATA[Ping request could not find host www.google.com. Please check the name and try again.。<br/>
我神经很混乱了。<br/><br/>
???????]]></content:encoded>
		<excerpt:encoded><![CDATA[Ping request could not find host www.google.com. Please check the name and try again.。<br/>
我神经很混乱了。<br/><br/>
???????]]></excerpt:encoded>
		<wp:post_id>29</wp:post_id>
		<wp:post_date>2008-06-03 08:16:00</wp:post_date>
		<wp:post_date_gmt>2008-06-03 08:16:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%9b%9e%e6%9d%a5%e4%ba%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%9c%aa%e5%88%86%e7%b1%bb"><![CDATA[未分类]]></category>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e7%90%90%e4%ba%8b"><![CDATA[琐事]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>一道题的证明</title>
		<link>http://hmgle.com/archives/30</link>
		<pubDate>Sat, 31 May 2008 19:43:00 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/archives/30</guid>
		<description></description>
		<content:encoded><![CDATA[<div align="left">

原题来源：<a href="http://www.eaglefantasy.cn/archives/196" target="_blank">http://www.eaglefantasy.cn/archives/196</a>本文遵从<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank">cc-by-nc-sa版权协议</a>

今天在Eagle_Fantasy的站点上偶然看到一道有意思的小数学题，原题如下：汽油危机已经来临，大家都在叫油荒。分散在长长的环形公路各处的加油站所存的油量仅仅够你跑一圈而无点滴富余。请证明，如果你在一个合适的加油站开始启程，把空油箱加足了汽油，你有充分把握可以跑完一圈，不会中途抛锚。

Eagle_Fantasy给出的解答是：设想你在第一站带上足够的燃料，沿着公路环行，每到一处，便做好记录油箱里还有多少油，并把那里的汽油全部倒进油箱。当你回到第一站时，你将发现，油箱里的剩油与出发时一样多。总有一站油箱里的油量最小，我们就从这站开始启程，这样保证环行一周途中不愁汽油断档。

Eagle_Fantasy给出的解答更像一个解法，当然我们可以进一步证明它的确是可行的，这将在后面看到。下面是我的不严格阐述：

设共有n站，从任意一个站点开始按顺序编号，第i站可加油量为A[i],从第i站跑到第(i+1)站需耗掉的油量为a[i] (a[n]表示从第n站到第一站)，由题设可知：

sum(A[i],i=1..n) = sum(a[i],i=1..n)        (1)

我们采用反证法：假设不存在可完成不中途抛锚行程的站点，即对于任意站点i，至少存在一个正整数j(0&lt;j&lt;n)，使得：从第i站出发，在第(i+j) mod(n)站前耗尽油抛锚，即最后加油的一站是[i+j-1]站,于是有

A[i]&gt;=a[i]    (2),

A[i]+A[i+1]&gt;=a[i]+a[i+1]    (3),

...,

A[i]+A[i+1]+...+A[i+j-2]&gt;=a[i]+a[i+1]+...+a[i+j-2]    (4),

A[i]+A[i+1]+...+A[i+j-1]&lt;a[i]+a[i+1]+...+a[i+j-1]    (5),

由上面(2),(3),(4),(5)式得

A[i+1]+A[i+2]+...+A[i+j-1]&lt;a[i+1]+a[i+2]+...+a[i+j-1]    ,

A[i+2]+A[i+3]+...+A[i+j-1]&lt;a[i+2]+a[i+2]+...+a[i+j-1]    ,

...,

A[i+j-1]&lt;a[i+j-1],

它说明从第i,(i+1),(i+2),...,直至第(i+j-1)站出发，都是无法到达第(i+j)站的。

好，我们从第1站出发，可以找到第k(1&lt;k&lt;=n)站使得在k站前抛锚，若从第k站出发，可以找到中途抛锚未到达的p站，依次类推，直到找到一站最接近第n站的q(q&lt;=n)站。编号在q之前的所有站点作为出发点，都是不可能到达q站的。根据假设，我们一定可以找到一站p(0&lt;p&lt;q),使得从q站出发，在p站之前因耗尽油而抛锚。p编号在q之前，故从p站出发，也是不能到达q站的。即

A[q]+A[q+1]+...+A[n]+A[1]+A[2]+...+A[p-1]&lt;a[q]+a[q+1]+...+a[n]+a[1]+a[2]+...+a[p-1]    (6),

A[p]+A[p+1]+...+A[q-1]&lt;a[p]+a[p+1]+...+a[q-1]    (7),

由(6),(7)得

A[1]+A[2]+...+A[n]&lt;a[1]+a[2]+...+a[n],

即sum(A[i],i=1..n)&lt;sum(a[i],i=1..n),与题设(1)矛盾，于是假设不成立。

得证。

为什么Eagle_Fantasy给出的解答是合理可行的呢？

以纵坐标表示油量，我们假设不受油量限制可以一直行驶，我们可以画出如下的油量变化图.
<a href="http://hmgle.com/wp-content/uploads/2008/05/youliang_xingcheng.jpg"><img class="alignnone size-full wp-image-273" title="youliang_xingcheng" src="http://hmgle.com/wp-content/uploads/2008/05/youliang_xingcheng.jpg" alt="" width="344" height="240" /></a>
<div></div>
它要求起点和终点的纵坐标一样，如果我们选择纵坐标为最小值的点为起点，就可以保证油量曲线在x轴上方了，即油量一直大于等于零，就可以顺利绕环行路一周了。

</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[<div align="left">原题来源：<a href="http://www.eaglefantasy.cn/archives/196" target="_blank">http://www.eaglefantasy.cn/archives/196</a>本文遵从<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank">cc-by-nc-sa版权协议</a><br/>
今天在Eagle_Fantasy的站点上偶然看到一道有意思的小数学题，原题如下：汽油危机已经来临，大家都在叫油荒。分散在长长的环形公路各处的加油站所存的油量仅仅够你跑一圈而无点滴富余。请证明，如果你在一个合适的加油站开始启程，把空油箱加足了汽油，你有充分把握可以跑完一圈，不会中途抛锚。<br/><br/><br/>
Eagle_Fantasy给出的解答是：设想你在第一站带上足够的燃料，沿着公路环行，每到一处，便做好记录油箱里还有多少油，并把那里的汽油全部倒进油箱。当你回到第一站时，你将发现，油箱里的剩油与出发时一样多。总有一站油箱里的油量最小，我们就从这站开始启程，这样保证环行一周途中不愁汽油断档。<br/>
Eagle_Fantasy给出的解答更像一个解法，当然我们可以进一步证明它的确是可行的，这将在后面看到。下面是我的不严格阐述：<br/>
设共有n站，从任意一个站点开始按顺序编号，第i站可加油量为A[i],从第i站跑到第(i+1)站需耗掉的油量为a[i] (a[n]表示从第n站到第一站)，由题设可知：<br/>
sum(A[i],i=1..n) = sum(a[i],i=1..n)              (1)<br/>
我们采用反证法：假设不存在可完成不中途抛锚行程的站点，即对于任意站点i，至少存在一个正整数j(0&lt;j&lt;n)，使得：从第i站出发，在第(i+j) mod(n)站前耗尽油抛锚，即最后加油的一站是[i+j-1]站,于是有<br/>
A[i]&gt;=a[i]       (2),<br/>
A[i]+A[i+1]&gt;=a[i]+a[i+1]       (3),<br/>
...,<br/>
A[i]+A[i+1]+...+A[i+j-2]&gt;=a[i]+a[i+1]+...+a[i+j-2]       (4),<br/>
A[i]+A[i+1]+...+A[i+j-1]&lt;a[i]+a[i+1]+...+a[i+j-1]       (5),<br/><br/>
由上面(2),(3),(4),(5)式得<br/>
A[i+1]+A[i+2]+...+A[i+j-1]&lt;a[i+1]+a[i+2]+...+a[i+j-1]       ,<br/>
A[i+2]+A[i+3]+...+A[i+j-1]&lt;a[i+2]+a[i+2]+...+a[i+j-1]       ,<br/>
...,<br/>
A[i+j-1]&lt;a[i+j-1],<br/>
它说明从第i,(i+1),(i+2),...,直至第(i+j-1)站出发，都是无法到达第(i+j)站的。<br/>
好，我们从第1站出发，可以找到第k(1&lt;k&lt;=n)站使得在k站前抛锚，若从第k站出发，可以找到中途抛锚未到达的p站，依次类推，直到找到一站最接近第n站的q(q&lt;=n)站。编号在q之前的所有站点作为出发点，都是不可能到达q站的。根据假设，我们一定可以找到一站p(0&lt;p&lt;q),使得从q站出发，在p站之前因耗尽油而抛锚。p编号在q之前，故从p站出发，也是不能到达q站的。即<br/>
A[q]+A[q+1]+...+A[n]+A[1]+A[2]+...+A[p-1]&lt;a[q]+a[q+1]+...+a[n]+a[1]+a[2]+...+a[p-1]       (6),<br/>
A[p]+A[p+1]+...+A[q-1]&lt;a[p]+a[p+1]+...+a[q-1]       (7),<br/>
由(6),(7)得<br/>
A[1]+A[2]+...+A[n]&lt;a[1]+a[2]+...+a[n],<br/>
即sum(A[i],i=1..n)&lt;sum(a[i],i=1..n),与题设(1)矛盾，于是假设不成立。<br/>
得证。<br/>
为什么Eagle_Fantasy给出的解答是合理可行的呢？<br/>
以纵坐标表示油量，我们假设不受油量限制可以一直行驶，我们可以画出如下的油量变化图.<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hmgle/pic/item/c8c6b894e4533d0ad31b70fa.jpg" small="0" class="blogimg"/></div>
<br/>
它要求起点和终点的纵坐标一样，如果我们选择纵坐标为最小值的点为起点，就可以保证油量曲线在x轴上方了，即油量一直大于等于零，就可以顺利绕环行路一周了。</div>]]></excerpt:encoded>
		<wp:post_id>30</wp:post_id>
		<wp:post_date>2008-05-31 19:43:00</wp:post_date>
		<wp:post_date_gmt>2008-05-31 19:43:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%80%e9%81%93%e9%a2%98%e7%9a%84%e8%af%81%e6%98%8e</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%b5%81%e5%85%a5"><![CDATA[流入]]></category>
		<category domain="post_tag" nicename="%e8%af%81%e6%98%8e"><![CDATA[证明]]></category>
		<category domain="post_tag" nicename="%e8%b6%a3%e9%a2%98"><![CDATA[趣题]]></category>
		<category domain="category" nicename="%e9%80%90%e6%b5%aa"><![CDATA[逐浪]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>神奇的红绿灯</title>
		<link>http://hmgle.com/archives/143</link>
		<pubDate>Mon, 28 Feb 2011 00:44:18 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=143</guid>
		<description></description>
		<content:encoded><![CDATA[碰到这样的红绿灯，踌躇不前
<a href="http://hmgle.com/wp-content/uploads/2011/02/022611_002.jpg"><img class="alignnone size-medium wp-image-144" title="022611_002" src="http://hmgle.com/wp-content/uploads/2011/02/022611_002-300x240.jpg" alt="" width="600" height="480" /></a>

<a href="http://hmgle.com/wp-content/uploads/2011/02/022611_002.jpg"></a>
<a href="http://hmgle.com/wp-content/uploads/2011/02/022611_003.jpg"><img class="alignnone size-medium wp-image-145" title="022611_003" src="http://hmgle.com/wp-content/uploads/2011/02/022611_003-300x240.jpg" alt="" width="600" height="480" /></a>
总算还有正常的状态：
<a href="http://hmgle.com/wp-content/uploads/2011/02/022611_004.jpg"><img class="alignnone size-medium wp-image-146" title="022611_004" src="http://hmgle.com/wp-content/uploads/2011/02/022611_004-300x240.jpg" alt="" width="600" height="480" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>143</wp:post_id>
		<wp:post_date>2011-02-28 00:44:18</wp:post_date>
		<wp:post_date_gmt>2011-02-28 00:44:18</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%a5%9e%e5%a5%87%e7%9a%84%e7%ba%a2%e7%bb%bf%e7%81%af</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bug"><![CDATA[bug]]></category>
		<category domain="category" nicename="%e6%b5%ae%e7%94%9f"><![CDATA[浮生]]></category>
		<category domain="post_tag" nicename="%e7%85%a7%e7%89%87"><![CDATA[照片]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>读阿城小说是一种享受</title>
		<link>http://hmgle.com/archives/164</link>
		<pubDate>Sat, 18 Jun 2011 13:57:41 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=164</guid>
		<description></description>
		<content:encoded><![CDATA[有时间的话，想读读阿城的小说。以前只读过他的《棋王》——多年前的事情了。
附上豆瓣上的一篇评论链接：<a href="http://book.douban.com/review/1421693/">http://book.douban.com/review/1421693/</a>
当然先要把那本《<a href="http://book.douban.com/subject/2175630/">8051微控制器和嵌入式系统</a>》看完。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>164</wp:post_id>
		<wp:post_date>2011-06-18 13:57:41</wp:post_date>
		<wp:post_date_gmt>2011-06-18 13:57:41</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%af%bb%e9%98%bf%e5%9f%8e%e5%b0%8f%e8%af%b4%e6%98%af%e4%b8%80%e7%a7%8d%e4%ba%ab%e5%8f%97</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%9c%aa%e5%88%86%e7%b1%bb"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>servfox分析</title>
		<link>http://hmgle.com/archives/173</link>
		<pubDate>Sun, 11 Sep 2011 13:57:20 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=173</guid>
		<description></description>
		<content:encoded><![CDATA[<h1 id="toc_1"><a href="http://hmgle.com/wiki/servfox_ans.html" target="_self">servfox分析</a></h1>
--by:hmgle Copyleft: <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh">CC BY-NC-SA</a>

构建嵌入式Linux网络视频监控系统中,我们采用servfox来做服务器采集程序. servfox涉及到的内容主要有:V4L1接口、套接字和多线程编程. 这里简单分析一下servfox-R1_1_3.
<h2 id="toc_1.1">1. servfox做了什么?</h2>
servfox在采集图像的过程中主要做什么事情?
它初始化摄像头设备后创建了线程1采集视频图像. 然后主程序创建一个套接字监听,阻塞等待客户端的请求连接. 连接成功后再创建线程2发送采集到的图像数据给客户端.
<ul>
	<li>线程1:采集视频图像.</li>
	<li>线程2:发送图像数据给客户端.</li>
</ul>
在采集线程和发送线程同时运行的情况下,会存在对存储压缩过的图像数据的缓冲区这个临界区竞争的情况. 为了能把采集到的一帧图像数据完整地发送出去,需要采用一些同步机制.
servfox只是个应用程序,它初始化设备,获取设备属性和图像属性,设置图像参数,捕捉图像数据,都是通过Video4Linux接口标准调用驱动的相关函数完成的. 本文末尾将会列举部分摄像头设备驱动要实现的file_oerations结构体里面的函数.
<h2 id="toc_1.2">2. servfox运行步骤</h2>
servfox运行流程图如下:

<img class=" alignnone" title="servfox_ans" src="http://hmgle.com/photo_html/servfox_ans_.png" alt="" width="498" height="565" />
<h3 id="toc_1.2.1">2.1 从命令行传递参数给变量</h3>
main()函数内,首先执行的是一个for循环体. 看一下里面的几个语句:
<pre>...
if (strcmp (argv[i], "-d") == 0) {
	if (i + 1 &gt;= argc) {
		if(debug)
			printf ("No parameter specified with -d, aborting.\n");
		exit (1);
	}
	videodevice = strdup (argv[i + 1]);
}
...</pre>
videodevice保存了摄像头设备节点名称. 用户不指定的话,后面会将它设置为"/dev/video0".
<pre>...
if (strcmp (argv[i], "-g") == 0) {
	/* Ask for read instead default  mmap */
	grabmethod = 0;
}
...</pre>
通过grabmethod的设置就指定了采集图像时使用mmap()内存映射的方法还是read()读取的方法. 采用read系统调用来读取图像数据的话在连续抓取的情况下会发生频繁的用户态和内核态的切换,效率低. 通过mmap内存映射的话,把摄像头对应的设备文件映射到进程内存中,减少I/O操作,提高了效率. 因此启动servfox时不加"-g"选项的话默认采用grabmethod=1为mmap方式.

在for循环体里面还根据用户输入的选项分配了存储分辨率大小width/height,创建套接字时用的端口号serverport(默认为7070).
<h3 id="toc_1.2.2">2.2 初始化视频采集设备</h3>
接下来主要要执行的语句有:
<pre>memset (&amp;videoIn, 0, sizeof (struct vdIn));	// 将结构体videoIn初始化为0</pre>
先来看看videoIn这个结构体:
<ul>
	<li>vdIn 结构体(在spcav4l.h中定义,它里面的成员都是依据Video4Linux接口标准而定义的):
<pre>struct vdIn {
	int fd;				// 设备文件描述符
	char *videodevice ;		// 设备,视频捕捉接口文件
	struct video_mmap vmmap;
	/* 用于内存映射方法时进行图像数据的获取,
	 * 里面的成员.frame表示当前将获取的帧号,
	 * 成员.height和.width表示图像高度和宽度,
	 * 成员.format表示图像格式.
	 */

	struct video_capability videocap;
	/* 包含设备的基本信息(设备名称,支持的最大最小分辨率,信号源信息等)
	 */

	int mmapsize;
	struct video_mbuf videombuf;
	/* 利用mmap映射到摄像头存储缓冲区的帧信息,
	 * 包括帧的大小(size),最多支持的帧数(frames),
	 * 每帧相对基址的偏移(offset)
	 */

	struct video_picture videopict;		// 采集到的图像的各种属性
	struct video_window videowin;		// 包含capture area的信息
	struct video_channel videochan;		// 各个信号源的属性
	struct video_param videoparam;
	int cameratype ;		// 是否能capture,彩色还是黑白,是否能裁剪等等
	char *cameraname;		// 设备名称
	char bridge[9];
	int sizenative; 		// available size in jpeg.
	int sizeothers;			// others palette.
	int palette; 			// available palette.
	int norme ;				// set spca506 usb video grabber.
	int channel ; 		// set spca506 usb video grabber 信号源个数
	int grabMethod ;
	unsigned char *pFramebuffer;	// 指向内存映射的指针
	unsigned char *ptframe[4];		// 指向压缩后的帧的指针数组
	int framelock[4];
	pthread_mutex_t grabmutex;		// 视频采集线程和传输线程的互斥信号
	int framesizeIn ;				// 视频帧的大小
	volatile int frame_cour;		// 指向压缩后的帧的指针数组下标
	int bppIn;		// 采集的视频帧的BPP
	int hdrwidth;			// 采集的视频帧的宽度
	int hdrheight;  		// 采集的视频帧的高度
	int formatIn;			// 采集的视频帧的格式
	int signalquit;		// 停止视频采集的信号
};</pre>
</li>
</ul>
接下来执行:
<pre>if (init_videoIn
            (&amp;videoIn, videodevice, width, height, format,grabmethod) != 0)</pre>
这个函数主要是设置了grabmethod:用mmap方式还是read方式;
设置videodevice成员设备文件名称,默认是 "/dev/video0";
设置信号vd-&gt;signalquit=1,图像宽高:vd-&gt;hdrwidth=width;vd-&gt;hdrheight=height;
设置图像格式为VIDEO_PALETTE_JPEG:vd-&gt;formatIn = format;
获得色深:vd-&gt;bppIn = GetDepth (vd-&gt;formatIn);

<hr />

调用init_v4l():
=================进入init_v4l()================================================
init_v4l()是初始化v4l视频设备的函数,它首先通过系统调用open()打开视频设备,成功打开后主要执行下面几个步骤:
<ul>
	<li>1. 通过系统调用ioctl (vd-&gt;fd, VIDIOCGCAP, &amp;(vd-&gt;videocap))取得设备信息。读取struct video_capability中有关摄像头的信息,保存到vd-&gt;videocap中.</li>
	<li>2. 初始化图像.</li>
</ul>
ioctl (vd-&gt;fd, VIDIOCGPICT, &amp;vd-&gt;videopict);
带VIDIOCGPICT参数的ioctl调用会获取图像的属性,并保存在vd-&gt;videopict指向的结构体中.
<ul>
	<li>3. 读取ruct video chanel中有关设备通道的信息，保存到vd-&gt;videochan指向的结构体中。</li>
</ul>
ioctl (vd-&gt;fd, VIDIOCGCHAN, &amp;vd-&gt;videochan);
<ul>
	<li>4. 设置摄像头参数.</li>
</ul>
读取摄像头数据前,需要对摄像头进行设置,主要包括图像参数和分辨率.
<pre>ioctl (vd-&gt;fd, VIDIOCSPICT, &amp;vd-&gt;videopict)</pre>
设置分辨率主要是对vd-&gt;videowin各分量进行修改,若为read方式,具体实现为:
<pre>if (ioctl (vd-&gt;fd, VIDIOCGWIN, &amp;(vd-&gt;videowin)) &lt; 0)	// 获得捕获源的大小
	perror ("VIDIOCGWIN failed \n");
vd-&gt;videowin.height = vd-&gt;hdrheight;
vd-&gt;videowin.width = vd-&gt;hdrwidth;
if (ioctl (vd-&gt;fd, VIDIOCSWIN, &amp;(vd-&gt;videowin)) &lt; 0)
	perror ("VIDIOCSWIN failed \n");</pre>
<ul>
	<li>5. 摄像头设备文件映射初始化或read方式初始化</li>
</ul>
完成上述初始化设备工作后,就可以对访问到摄像头设备文件的内容了. 如果选用mmap()内存映射方式的话,下面的步骤将摄像头设备文件映射到进程内存,这样就可以直接读取映射了的这片内存,而不必read设备文件了:

a. 获取摄像头缓冲区帧信息:
<pre>ioctl (vd-&gt;fd, VIDIOCGMBUF, &amp;(vd-&gt;videombuf));</pre>
该操作获取摄像头存储缓冲区的帧信息:包括帧的大小(size),最多支持的帧数(frames),每帧相对基址的偏移(offset). 这些参数都是由摄像头设备硬件决定的. 这些信息将被保存在videombuf结构体里面,下面的映射摄像头设备文件到内存操作马上就要用到了:

b. 映射摄像头设备文件到内存:
<pre>vd-&gt;pFramebuffer =
            (unsigned char *) mmap (0, vd-&gt;videombuf.size, PROT_READ | PROT_WRITE,
                    MAP_SHARED, vd-&gt;fd, 0);</pre>
该操作把摄像头对应的设备文件映射到内存区. 该映射内容区可读可写并且不同进程间可共享. 帧的大小(vd-&gt;videombuf. size)是a步骤获取的. 该函数成功返回映像内存区的指针,该指针赋值给vd-&gt;pFramebuffer,失败时返回-1.

c. 视频图像捕捉测试:
<pre>/* Grab frames 抓取一帧*/
if (ioctl(vd-&gt;fd, VIDIOCMCAPTURE, &amp;(vd-&gt;vmmap))) {
	perror ("cmcapture");
}</pre>
该操作捕捉一帧图像,获取图像信息到vmmap里. 它会根据vmmap中设置的属性参数(frame,height,width和format)通知驱动程序启动摄像头抓拍图像. 该操作是非阻塞的,是否截取完毕留给VDIOCSYNC来判断. 在init_v4l()这里只是为了测试是否可以成功捕获一帧图像,真正采集图像是在采集线程时执行v4lGrab()这个函数的时候.

以上是用mmap内存映射方式,如果采用直接读取摄像头设备文件的方式获取图像的话,将执行:
<pre>els {
	/* read method */
	/* allocate the read buffer */
	vd-&gt;pFramebuffer = (unsigned char *) realloc(vd-&gt;pFramebuffer, \
			(size_t) vd-&gt;framesizeIn);
	/* 为pFrameffer分配内存 */

	if (ioctl (vd-&gt;fd, VIDIOCGWIN, &amp;(vd-&gt;videowin)) &lt; 0)	// 获得捕获源的大小
		perror("VIDIOCGWIN failed \n");
	vd-&gt;videowin.height = vd-&gt;hdrheight;
	vd-&gt;videowin.width = vd-&gt;hdrwidth;
	if (ioctl(vd-&gt;fd, VIDIOCSWIN, &amp;(vd-&gt;videowin)) &lt; 0)
		perror("VIDIOCSWIN failed \n");
}</pre>
摄像头设备文件映射初始化或read方式初始化完成后,返回init_videoIn().

=============从init_v4l() 返回========================================

<hr />

从init_v4l()返回到init_videoIn()后,分配vd-&gt;ptframe[i]空间.
<pre>for (i = 0; i &lt; OUTFRMNUMB; i++) {
	vd-&gt;ptframe[i] = NULL;
	vd-&gt;ptframe[i] = (unsigned char *) realloc (vd-&gt;ptframe[i],\
			sizeof(struct frame_t) + (size_t) vd-&gt;framesizeIn );
	vd-&gt;framelock[i] = 0;
}</pre>
unsigned char* ptframe[4]：指向四个buffer缓冲数组，用来存放已压缩完成的图像数据.
<h3 id="toc_1.2.3">2.3 采集图像数据线程</h3>
init_videoIn()执行完后返回main(),接下来创建采集视频图像的线程:
<pre>pthread_create (&amp;w1, NULL, (void *) grab, NULL);</pre>
进入grab()函数:可以看到在死循环体里面调用v4lGrab()函数.
进入v4lGrab()函数,先判断一下是用mmap方法还是用read方法. 下面仅就mmap方法分析:
<pre>ioctl (vd-&gt;fd, VIDIOCSYNC, &amp;vd-&gt;vmmap.frame);</pre>
这条语句是等待捕捉完这一帧图像,调用成功后表明一帧图像捕捉完毕,可以开始进行下一次图像捕捉. vd-&gt;vmmap.frame是当前捕捉到帧的序号.

接下来的是个循环睡眠等待:
<pre>while((vd-&gt;framelock[vd-&gt;frame_cour] != 0) &amp;&amp; vd-&gt;signalquit)
            usleep(1000);</pre>
它是等待之后执行的另一个用来的发送采集到的图像数据给客户端的线程,直到它把这一帧图像完整地发送出去. 每隔1毫秒就检查一次是否发完. 如果不等待就执行下面的操作的话,那么还没发送完就把本来要发送的图像数据重写掉,采集到的数据没用上. 可以采用更好的同步机制--信号量来实现.

等到上一帧图像数据发送出去之后,这个线程等待直到获得一把线程互斥锁:
<pre>pthread_mutex_lock (&amp;vd-&gt;grabmutex);</pre>
它把临界区资源vd-&gt;ptframe锁住,防止下面获取时间和拷贝数据到ptframe及设置一帧图像的头部时被别的线程抢占. 虽然在发送线程里并没有找到相关互斥锁的操作(这个应该是要加的),但为了扩展,有可能以后我们添加一些访问临界区vd-&gt;ptframe的线程时可以用它这把锁.

然后执行:
<pre>  tems = ms_time();</pre>
tems获得的是距离UNIX的Epoch时间即:1970年1月1日0时0分0秒算起的毫秒数. 它可以用在视频图像的时间戳.
然后执行:
<pre>jpegsize= convertframe(vd-&gt;ptframe[vd-&gt;frame_cour]+ sizeof(struct frame_t),
                vd-&gt;pFramebuffer + vd-&gt;videombuf.offsets[vd-&gt;vmmap.frame],
                vd-&gt;hdrwidth,vd-&gt;hdrheight,vd-&gt;formatIn,vd-&gt;framesizeIn);</pre>
跟踪进去可以看出要是视频图像格式是VIDEO_PALETTE_JPEG的话,直接将pFramebuffer中的数据拷贝到ptframe缓存中去，而不压缩处理,因为获得的就是已经压缩过的jpeg格式了(是硬件或底层驱动做了,一般USB摄像头对采集到的图像都作了jpeg格式压缩(内置JPEG硬件压缩)). 获得jpeg格式文件的大小是通过调用get_jpegsize()实现的. 进入get_jpegsize()可以发现,它利用了jpeg文件格式中是以0xFF 0xD9结尾的这个特性. ptframe里面的经压缩过的图像数据就是发送线程要发送出去的内容了.

pFramebuffer中的数据拷贝进ptframe完成后,就截取下一帧图像数据了:
<pre>/* Grab frames */
if ((ioctl (vd-&gt;fd, VIDIOCMCAPTURE, &amp;(vd-&gt;vmmap))) &lt; 0)	{
	perror ("cmcapture");
	if(debug) printf ("&gt;&gt;cmcapture err \n");
	erreur = -1;
}
	vd-&gt;vmmap.frame = (vd-&gt;vmmap.frame + 1) % vd-&gt;videombuf.frames;
	vd-&gt;frame_cour = (vd-&gt;frame_cour +1) % OUTFRMNUMB;</pre>
执行完后,跳出v4lGrab()函数体,返回到grab()去. 正常运行状态下,将不断循环调用v4lGrab()采集图像数据. 采集线程分析完毕.
<h3 id="toc_1.2.4">2.4 建立TCP套接字服务端,为图像数据发送线程做好准备</h3>
回到main(),继续往下执行:
<pre>serv_sock = open_sock(serverport);</pre>
跟踪进入open_sock()里面可以看到通过执行socket(),bind(),listen()建立了一个TCP套接字服务端并在指定端口上监听,等待客户端连接. 紧跟在socket()后面有一句:
<pre>setsockopt(server_handle, SOL_SOCKET, SO_REUSEADDR, &amp;O_on, sizeof (int));</pre>
这个语句应该是为了允许启动多个服务端或多个servfox. 参见:<a href="http://blog.csdn.net/liusujian02/article/details/1944520">http://blog.csdn.net/liusujian02/article/details/1944520</a> (关于SO_REUSEADDR的使用说明)

执行完serv_sock = open_sock(serverport)这个语句之后,下一条语句是:
<pre>signal(SIGPIPE, SIG_IGN);	/* Ignore sigpipe */</pre>
这是为了忽略SIGPIPE信号:若客户端关闭了和服务端的连接,但服务端依然试图发送图像数据给客户端(write to pipe with no readers),系统就会发出一个SIGPIPE信号,默认对SIGPIPE的处理是terminate(终止),那么负责发送图像数据的服务端就挂掉了,即使还有别的客户端连接. 这当然不是我们想要的,因此把我们要执行这句语句把SIGPIPE信号忽略掉.
<h3 id="toc_1.2.5">2.5 发送图像数据到客户端的线程</h3>
接下来,是一个while(videoIn.signalquit)循环体,如果没有接收到退出信号,它就一直循环运行里面的语句:
<pre>while (videoIn.signalquit) {
	sin_size = sizeof(struct sockaddr_in);

	/* 等待客户端的连接，如果没有连接就一直阻塞下去，
	 * 如果有客户连接就创建一个线程，
	 * 在新的套接口上与客户端进行数据交互
	 */
	if ((new_sock = accept(serv_sock, (struct sockaddr *)&amp;their_addr, &amp;sin_size)) == -1) {
            continue;
	}
	syslog(LOG_ERR,"Got connection from %s\n",inet_ntoa(their_addr.sin_addr));
	printf("Got connection from %s\n",inet_ntoa(their_addr.sin_addr));
	pthread_create(&amp;server_th, NULL, (void *)service, &amp;new_sock);
}</pre>
之前建立的服务端一直监听等待客户端来连接,一旦有客户端connect()过来,服务端执行accept()建立连接后,就创建了发送图像数据到客户端的线程了:
<pre>pthread_create(&amp;server_th, NULL, (void *)service, &amp;new_sock);</pre>
我们再进入这个线程执行的service()函数去分析:

<hr />

=============进入service()==============================
<pre>/* initialize video setting */
    bright = upbright(&amp;videoIn);
    contrast = upcontrast(&amp;videoIn);
    bright = downbright(&amp;videoIn);
    contrast = downcontrast(&amp;videoIn);</pre>
上面所谓的初始话视频设置,是先增大一下亮度和对比度,在减小亮度和对比度恢复到原来的状态,顺便将亮度值保存在bright变量,将对比度值保存在contrast变量.
然后是一个死循环体:
<pre>for ( ; ; ) {
	memset(&amp;message,0,sizeof(struct client_t));
	ret = read(sock,(unsigned char*)&amp;message,sizeof(struct client_t));
	......
	if (message.updobright){
		switch (message.updobright){
			case 1: bright = upbright(&amp;videoIn);
				break;
			case 2: bright = downbright(&amp;videoIn);
				break;
		}
		ack = 1;
	} else if (message.updocontrast){
		switch (message.updocontrast){
			case 1: contrast = upcontrast(&amp;videoIn);
				break;
			case 2: contrast = downcontrast(&amp;videoIn);
				break;
		}
		ack = 1;
	} else if (message.updoexposure){
		switch (message.updoexposure){
			case 1: spcaSetAutoExpo(&amp;videoIn);
				break;
			case 2:;
				break;
		}
		ack = 1;
	} else if (message.updosize){ //compatibility FIX chg quality factor ATM
		switch (message.updosize){
			case 1: qualityUp(&amp;videoIn);
				break;
			case 2: qualityDown(&amp;videoIn);
				break;
		}
		ack = 1;
	} else if (message.fps){
		switch (message.fps){
			case 1: timeDown(&amp;videoIn);
				break;
			case 2: timeUp(&amp;videoIn);
				break;
		}
		ack = 1;
	} else if (message.sleepon){
		ack = 1;
	} else ack =0;
	while ((frameout == videoIn.frame_cour) &amp;&amp; videoIn.signalquit)
		usleep(1000);
	if (videoIn.signalquit){
		videoIn.framelock[frameout]++;
		headerframe = (struct frame_t *) videoIn.ptframe[frameout];
		headerframe-&gt;acknowledge = ack;
		headerframe-&gt;bright = bright;
		headerframe-&gt;contrast = contrast;
		headerframe-&gt;wakeup = wakeup;
		ret = write_sock(sock, (unsigned char *)headerframe, sizeof(struct frame_t)) ;
		/* 发送帧信息头 */

		if(!wakeup)
			ret = write_sock(sock,(unsigned char*)(videoIn.ptframe[frameout] + \
						sizeof(struct frame_t)),headerframe-&gt;size);

		videoIn.framelock[frameout]--;
		frameout = (frameout+1)%4;
	} else {
		if(debug)
			printf("reader %d going out \n",*id);
		break;
	}
}</pre>
和客户端建立连接后,客户端会先将设置图像的信息发给服务端,因此上面代码,首先读取客户端对图像的设置,把设置信息存放在message结构体里,然后是根据message里的信息对采集图像的显示属性(如亮度bright,对比度contrast等)进行设置,具体操作是通过ioctl()调用底层驱动来完成对摄像头抓拍图像的显示设置.

设置完采集图像显示属性后,执行:
<pre>while ((frameout == videoIn.frame_cour) &amp;&amp; videoIn.signalquit)
	usleep(1000);</pre>
frame_cour是指向压缩后的图像帧的指针数组下标,我们一共存储4帧(unsigned char *ptframe[4]),为了按顺序读取每一帧,就等待知道frameout和videoIn.frame_cour相等时才执行后面的发送操作,发送这帧图像完成后会执行frameout = (frameout+1)%4使得下一次发送下一帧图像. 个人觉得这里采取信号量的同步机制更好.
等采集线程完成一帧采集使得videoIn.frame_cour等于frameout之后(因为这里没有采用同步机制,有可能这一轮会落空),就开始执行发送这一帧图像给客户端的操作了:先将让headerframe指向帧信息头,然后发送headerframe指向的信息头给客户端,再发送剩下的图像数据. 这样就把完整的一帧图像发送给客户端了.
只要没有收到客户端退出的信号,以上的发送过程会循环执行.

当收到客户端退出的信息后,它就退出循环,执行close_sock(sock)关闭套接字,终止线程.

=============从service()返回=================================

<hr />

服务器发送图像线程终止后,只要进程没有退出信号还会在while (videoIn.signalquit)这个循环体继续,阻塞等待客户端的连接,重复上面的过程.

若videoIn.signalquit等于0了,就不再执行这个循环体,等待采集线程退出:pthread_join (w1, NULL);关闭套接字:close(serv_sock);回收以前分配的资源:close_v4l (&amp;videoIn);整个程序就正常退出了.
<h2 id="toc_1.3">3. servfox与底层驱动的接口</h2>
前面说过,servfox只是个应用程序,它初始化设备,获取设备属性和图像属性,设置图像参数,捕捉图像数据,都是通过V4L1接口标准调用驱动的相关函数完成的.V4L1就是Video4Linux的版本1,Video4Linux已整合进Linux内核里面了.新版本是v4l2,它和v4l1不是完全兼容的.而V4L1已经是过时了.从Linux 2.6.38 内核就已经完全放弃了对v4l1的支持,因此不修改过的servfox不能在2.6.38以上的内核上运行了.不过有功能更强大的mjpeg-streamer来取代servfox.而mjpeg-streamer是基于v4l2接口的.

由于servfox体积小,在它上面进行扩展是很容易的,比如加入基于libjpeg库的本地解码jpeg显示到lcd屏的线程,加入截屏的线程等.

下面列出了servfox用到的一些v4l1的接口,如果非要把servfox移植到2.6.38的Linux内核上运行的话,必须修改这些v4l1的接口使之兼容于v4l2.
<ul>
	<li>摄像头驱动里要实现的ioctl()
<pre>1. ioctl(vd-&gt;fd, VIDIOCSYNC, &amp;vd-&gt;vmmap.frame)

	/* VIDIOCSYNC: Sync with mmap grabbing */

	/* 等待捕捉到这一帧图象.
	 * 即等待一帧截取结束.
	 * 若成功，表明一帧截取已完成。
	 * 可以开始做下一次 VIDIOCMCAPTURE
	 */</pre>
</li>
</ul>
<pre>2. if ((ioctl (vd-&gt;fd, VIDIOCMCAPTURE, &amp;(vd-&gt;vmmap))) &lt; 0)

	/* Mmap方式下做视频截取的 VIDIOCMCAPTURE.
	 * 若调用成功，开始一帧的截取，是非阻塞的，
	 * 是否截取完毕留给VIDIOCSYNC来判断
	 */</pre>
<pre>3. 读video_picture中信息
	ioctl(vd-&gt;fd, VIDIOCGPICT, &amp;(vd-&gt;picture))；

if (ioctl (vd-&gt;fd, VIDIOCGPICT, &amp;vd-&gt;videopict) &lt; 0)	/* Get picture properties */
访问摄像头设备采集的图像的各种属性。然后通过访问结构体vd-&gt;videopict 就可以读出图像的各种信息。
vd-&gt;videopict中分量的值是可以改变的，实现方法为：先为分量赋新值，再调用VIDIOCSPICT. 如:</pre>
<pre>4.
	if (ioctl (vd-&gt;fd, VIDIOCGCAP, &amp;(vd-&gt;videocap)) == -1)		/* Get capabilities */
        exit_fatal ("Couldn't get videodevice capability");

	读video_capability 中信息
	ioctl(vd-&gt;fd, VIDIOCGCAP, &amp;(vd-&gt;capability))
	成功后可读取vd-&gt;capability各分量  eg.
	Printf（”maxwidth = %d”vd-&gt;capability.maxwidth）;</pre>
<pre>5. 初始化channel:
 if (ioctl (vd-&gt;fd, VIDIOCGCHAN, &amp;vd-&gt;videochan) == -1)		/* Get channel info (sources) */
		// 用来取得和设置channel信息，例如使用那个输入源，制式等
    {
        if(debug) printf ("Hmm did not support Video_channel\n");
        vd-&gt;cameratype = UNOW;
    }</pre>
<pre>6. 初始化video_mbuf，以得到所映射的buffer的信息
	ioctl(vd-&gt;fd, VIDIOCGMBUF, &amp;(vd-&gt;mbuf))
	if (ioctl (vd-&gt;fd, VIDIOCGMBUF, &amp;(vd-&gt;videombuf)) &lt; 0)		/* Memory map buffer info */
    {
		perror (" init VIDIOCGMBUF FAILED\n");
    }</pre>
<pre>	// 要确定是否捕捉到图象，要用到下一个命令。
			if (ioctl (vd-&gt;fd, VIDIOCMCAPTURE, &amp;(vd-&gt;vmmap)))	/* Grab frames 抓取帧*/
            {
                perror ("cmcapture");
            }</pre>
<pre>7. if (ioctl (vd-&gt;fd, VIDIOCGWIN, &amp;(vd-&gt;videowin)) &lt; 0)	// 获得捕获源的大小
            perror ("VIDIOCGWIN failed \n");</pre>
<ul>
	<li>v4l2中的ioctl()的cmd:</li>
</ul>
在进行V4L2开发中，一般会用到以下的命令标志符：

1. VIDIOC_REQBUFS：分配内存

2. VIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址

3. VIDIOC_QUERYCAP：查询驱动功能

4. VIDIOC_ENUM_FMT：获取当前驱动支持的视频格式

5. VIDIOC_S_FMT：设置当前驱动的频捕获格式

6. VIDIOC_G_FMT：读取当前驱动的频捕获格式

7. VIDIOC_TRY_FMT：验证当前驱动的显示格式

8. VIDIOC_CROPCAP：查询驱动的修剪能力

9. VIDIOC_S_CROP：设置视频信号的边框

10. VIDIOC_G_CROP：读取视频信号的边框

11. VIDIOC_QBUF：把数据从缓存中读取出来

12. VIDIOC_DQBUF：把数据放回缓存队列

13. VIDIOC_STREAMON：开始视频显示函数

14. VIDIOC_STREAMOFF：结束视频显示函数

15. VIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。

这些IO调用，有些是必须的，有些是可选择的。

=========END=====================================================
<ul>
	<li>参考文献</li>
</ul>
1. 基于S3C2440的嵌入式视频网络监控系统--柳亚东
2. 基于嵌入式ARM的远程视频监控系统研究--李保国
3. 基于ARM的嵌入式网络视频监控系统设计与实现--方卫民
......]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>173</wp:post_id>
		<wp:post_date>2011-09-11 13:57:20</wp:post_date>
		<wp:post_date_gmt>2011-09-11 13:57:20</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>servfox%e5%88%86%e6%9e%90</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%b5%8c%e5%85%a5%e5%bc%8f"><![CDATA[嵌入式]]></category>
		<category domain="category" nicename="%e6%9c%aa%e5%88%86%e7%b1%bb"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>Copyleft</wp:meta_key>
			<wp:meta_value><![CDATA[CC BY-NC-SA]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>嵌入式Linux基于framebuffer的jpeg格式本地LCD屏显示</title>
		<link>http://hmgle.com/archives/190</link>
		<pubDate>Tue, 18 Oct 2011 07:20:31 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=190</guid>
		<description></description>
		<content:encoded><![CDATA[在基于Linux的视频监控采集系统中,摄像头采集到的一帧视频图像数据一般都是经过硬件自动压缩成jpeg格式的,然后再保存到摄像头设备的缓冲区.如果要把采集到的jpeg格式显示在本地LCD屏上,由于我们的Linux系统没有移植任何GUI系统,就要考虑以下方面:
1. 将jpeg格式解压缩为位图格式,也就是jpeg解码.

2. 将解码出来的位图格式输出到本地的LCD屏上. 在Linux系统下是通过写入帧缓冲(framebuffer)来实现的.

3. framebuffer相当于为LCD设备提供一个统一的接口,对framebuffer的操控会反映到LCD显示设备上去. 如果配置Linux内核时没有找到支持本地lcd屏这种型号的驱动,那我们要自己写lcd屏驱动,然后选择静态加入内核或以模块的形式加入内核动态加载.

针对以上三点,我们逐一解决:
<h2 id="toc_1.1">1. jpeg解码</h2>
先了解一下jpeg标准的编码过程:原始的一帧未压缩过的图像可以看成是RGB(红绿蓝)色彩空间上的一组向量集合,但在RGB空间是不利于数据压缩的,因此为了压缩先要把图像映射到利于压缩的YUV空间上(原因是因为人类的眼睛对于亮度差异的敏感度高于色彩变化,而YUV空间的一个基向量Y就是亮度), 这一步叫色彩空间转换.下一步可以在YUV空间上减少U(色调)和V(饱和度)的成分,也就是在亮度信息不减少的情况下移除部分色彩信息,谁叫人的眼睛对亮度的敏感优于对色彩的敏感呢.这一步叫缩减取样.下一步是将图像从色彩空间映射到频率空间,可以采用的变换方法有:离散余弦变换, 傅氏变换, 正弦变换等. 其中应用最广的是离散余弦变换(DCT).这一步是无损的,目的是为了在下一步称之为量化的过程中可以经过四舍五入删除高频量得到压缩后的矩阵.量化之后就是对这个矩阵的编码问题了.针对这个矩阵的分布特点, 采用"Z"字形的顺序扫描编排,然后进行RLE行程编码, 把大量连续重复的数据压缩.最后再用范式Huffman编码.要了解详细的过程,可以查看<a href="http://www.jpeg.org/">JPEG标准</a>.

而解码就是以上编码的逆过程了.除非想要自己实现jpeg的编码和解码函数,我们可以不必细究这些过程,而是直接使用别人已经实现的jpeg编码解码库.在Linux平台下, 有libjpeg库, 它是完全用C语言编写的, 依照它的许可协议,可自由使用, 不是GPL协议,它可以用于商业目的.

libjpeg的6b版本有个问题,就是解码接口,它只接受文件源.打开源的函数<code>jpeg_stdio_src(j_decompress_ptr cinfo, FILE *infile)</code>要求解码源infile是文件.而我们希望解码的是直接来自映射内存中的数据.要解码内存流的话就要修改libjpeg的源码了,可以参考这里:<a href="http://my.unix-center.net/~Simon_fu/?p=565">http://my.unix-center.net/~Simon_fu/?p=565</a> 目前libjpeg的最新版8c已经解决了这个接口不好的问题了,它增加了对内存流解码的支持.通过调用函数
<pre>jpeg_mem_src(&amp;cinfo, fdmem, st.st_size);</pre>
就可以将保存在内存的jpeg格式数据作为源输入了.因此我们就用libjpeg 8c这个版本来解码.

用到的函数主要有:
<ol>
	<li>初始化jpeg解压对象:
<pre>  /* init jpeg decompress object error handler */
  cinfo.err = jpeg_std_error(&amp;jerr);
  jpeg_create_decompress(&amp;cinfo);</pre>
</li>
	<li>绑定jpeg解压对象到输入流:
<pre>	/* bind jpeg decompress object to infile */
#if READ_FILE	// 从jpeg文件读入
	jpeg_stdio_src(&amp;cinfo, infile);
#elif READ_MEM	// 从内存读入jpeg格式
	jpeg_mem_src(&amp;cinfo, fdmem, st.st_size);
#endif</pre>
</li>
	<li>读取jpeg头部信息:
<pre>	/* read jpeg header */
	jpeg_read_header(&amp;cinfo, TRUE);</pre>
</li>
	<li>解压过程:
<pre>	/* decompress process */
	jpeg_start_decompress(&amp;cinfo);</pre>
</li>
</ol>
调用这个函数之后,可以得到jpeg图像的下面几个参数:
<ol>
	<li>output_width // 图像的宽度</li>
	<li>output_height // 图像的高度</li>
	<li>output_components // 每个像素占用的字节数</li>
</ol>
我们采用每扫描一行像素就输出到屏幕的方法的话,根据以上参数可以确定分配一行信息需要的缓冲区:
<pre>	buffer = (unsigned char *)malloc(cinfo.output_width *
			cinfo.output_components);</pre>
总共需要扫描output_height行.
<ol>
	<li>读取一行扫描数据并输出到LCD屏幕:
<pre>	y = 0;
	while (cinfo.output_scanline &lt; cinfo.output_height) {
		jpeg_read_scanlines(&amp;cinfo, &amp;buffer, 1);
		if (fb_depth == 16) {	// 如果显示设备色深是16位
			...
		} else if (fb_depth == 24) {	// 如果显示设备色深是24位
			...
		} else if (fb_depth == 32) {	// 如果显示设备色深是32位
			...
		}
		y++;
	}</pre>
</li>
	<li>结束jpeg解码:
<pre>	/* finish decompress, destroy decompress object */
	jpeg_finish_decompress(&amp;cinfo);
	jpeg_destroy_decompress(&amp;cinfo);</pre>
</li>
	<li>释放缓冲区:
<pre>	/* release memory buffer */
	free(buffer);</pre>
</li>
</ol>
<h2 id="toc_1.2">2. 输出位图到LCD屏</h2>
通过framebuffer直接写屏的主要步骤有:
<ol>
	<li>打开framebuffer设备:
<pre>	/* open framebuffer device */
	fbdev = fb_open("/dev/fb0");</pre>
</li>
	<li>获取framebuffer设备参数:
<pre>	/* get status of framebuffer device */
	fb_stat(fbdev, &amp;fb_width, &amp;fb_height, &amp;fb_depth);</pre>
</li>
	<li>映射framebuffer设备到共享内存:
<pre>	screensize = fb_width * fb_height * fb_depth / 8;
	fbmem = fb_mmap(fbdev, screensize);</pre>
</li>
	<li>直接对映射到那片内存进行写操作,LCD屏刷新刷新时就会反应到屏幕上去了.
<pre>	y = 0;
    while (cinfo.output_scanline &lt; cinfo.output_height) {
        jpeg_read_scanlines(&amp;cinfo, &amp;buffer, 1);
        if (fb_depth == 16) {
            unsigned short color;

            for (x = 0; x &lt; cinfo.output_width; x++) {
                color =
                    RGB888toRGB565(buffer[x * 3],
                            buffer[x * 3 + 1], buffer[x * 3 + 2]);
                fb_pixel(fbmem, fb_width, fb_height, x, y, color);
            }
        } else if (fb_depth == 24) {
            memcpy((unsigned char *) fbmem + y * fb_width * 3,
                    buffer, cinfo.output_width * cinfo.output_components);
        } else if (fb_depth == 32) {
            // memcpy((unsigned char *) fbmem + y * fb_width * 4,
                    // buffer, cinfo.output_width * cinfo.output_components);
            for (x = 0; x &lt; cinfo.output_width; x++) {
                *(fbmem + y * fb_width * 4 + x * 4)     = (unsigned char) buffer[x * 3 + 2];
                *(fbmem + y * fb_width * 4 + x * 4 + 1) = (unsigned char) buffer[x * 3 + 1];
                *(fbmem + y * fb_width * 4 + x * 4 + 2) = (unsigned char) buffer[x * 3 + 0];
                *(fbmem + y * fb_width * 4 + x * 4 + 3) = (unsigned char) 0;
            }
        }
        y++;    // next scanline
	}</pre>
</li>
	<li>卸载映射framebuffer的那部分内存:
<pre>	/* unmap framebuffer's shared memory */
	fb_munmap(fbmem, screensize);</pre>
</li>
	<li>关闭framebuffer设备:
<pre>	close(fbdev);</pre>
</li>
</ol>
根据以上两点,可以写一个测试程序,在不开X-window图形系统的情况下,将本地的jpeg文件直接显示到屏幕上.
<pre>#include    &lt;stdio.h&gt;
#include    &lt;string.h&gt;
#include    &lt;stdlib.h&gt;
#include    &lt;unistd.h&gt;
#include    &lt;sys/ioctl.h&gt;
#include    &lt;sys/types.h&gt;
#include    &lt;sys/stat.h&gt;
#include    &lt;errno.h&gt;
#include    &lt;fcntl.h&gt;
#include    &lt;sys/mman.h&gt;
#include    &lt;linux/fb.h&gt;
#include    "jpeglib.h"
#include    "jerror.h"

#define FB_DEV  "/dev/fb0"
#define __fnc__ __FUNCTION__

#define debug           0
#define debug_printf    0
#define BYREAD          0
#define BYMEM           1

/* function deciaration */

void usage(char *msg);
unsigned short RGB888toRGB565(unsigned char red,
        unsigned char green, unsigned char blue);
int fb_open(char *fb_device);
int fb_close(int fd);
int fb_stat(int fd, unsigned int *width, unsigned int *height, unsigned int *    depth);
void *fb_mmap(int fd, unsigned int screensize);
void *fd_mmap(int fd, unsigned int filesize);
int fb_munmap(void *start, size_t length);
int fb_pixel(void *fbmem, int width, int height,
        int x, int y, unsigned short color);

#if(debug)
void draw(unsigned char *fbp,
        struct fb_var_screeninfo vinfo,
        struct fb_fix_screeninfo finfo);
#endif

/* function implementation */

int main(int argc, char **argv)
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
#if(BYREAD)
    FILE *infile;
#endif
    int fd;
    unsigned char *buffer;
    struct stat st;

    int fbdev;
    char *fb_device;
    unsigned char *fbmem;
    unsigned char *fdmem;
    unsigned int screensize;
    unsigned int fb_width;
    unsigned int fb_height;
    unsigned int fb_depth;
    register unsigned int x;
    register unsigned int y;

    /* check auguments */
    if (argc != 2) {
        usage("insuffient auguments");
        exit(-1);
    }

    /* open framebuffer device */
    if ((fb_device = getenv("FRAMEBUFFER")) == NULL)
        fb_device = FB_DEV;
    fbdev = fb_open(fb_device);

    /* get status of framebuffer device */
    fb_stat(fbdev, &amp;fb_width, &amp;fb_height, &amp;fb_depth);

    /* map framebuffer device to shared memory */
    screensize = fb_width * fb_height * fb_depth / 8;
    fbmem = fb_mmap(fbdev, screensize);

#if (BYREAD)
    /* open input jpeg file */
    if ((infile = fopen(argv[1], "rb")) == NULL) {
        fprintf(stderr, "open %s failed\n", argv[1]);
        exit(-1);
    }
#endif

    if ((fd = open(argv[1], O_RDONLY)) &lt; 0) {
        perror("open");
        exit(-1);
    }

    if (fstat(fd, &amp;st) &lt; 0) {
        perror("fstat");
        exit(-1);
    }

    fdmem = fd_mmap(fd, st.st_size);

    /* init jpeg decompress object error handler */
    cinfo.err = jpeg_std_error(&amp;jerr);
    jpeg_create_decompress(&amp;cinfo);

    /* bind jpeg decompress object to infile */
#if (BYREAD)
    jpeg_stdio_src(&amp;cinfo, infile);
#endif

#if (BYMEM)
    jpeg_mem_src(&amp;cinfo, fdmem, st.st_size);
#endif

    /* read jpeg header */
    jpeg_read_header(&amp;cinfo, TRUE);

    /* decompress process */
    jpeg_start_decompress(&amp;cinfo);
    if ((cinfo.output_width &gt; fb_width) ||
            (cinfo.output_height &gt; fb_height)) {
        printf("too large jpeg file, can't display\n");
#if (0)
        return -1;
#endif
    }

    buffer = (unsigned char *) malloc(cinfo.output_width *
            cinfo.output_components);

    struct fb_fix_screeninfo fb_finfo;
    struct fb_var_screeninfo fb_vinfo;

    if (ioctl(fbdev, FBIOGET_FSCREENINFO, &amp;fb_finfo)) {
        perror(__fnc__);
        return -1;
    }

    if (ioctl(fbdev, FBIOGET_VSCREENINFO, &amp;fb_vinfo)) {
        perror(__fnc__);
        return -1;
    }

#if(debug)
    draw(fbmem, fb_vinfo, fb_finfo);
#endif
    y = 0;
    while (cinfo.output_scanline &lt; cinfo.output_height) {
        jpeg_read_scanlines(&amp;cinfo, &amp;buffer, 1);
        if (fb_depth == 16) {
            unsigned short color;

            for (x = 0; x &lt; cinfo.output_width; x++) {
                color =
                    RGB888toRGB565(buffer[x * 3],
                            buffer[x * 3 + 1], buffer[x * 3 + 2]);
                fb_pixel(fbmem, fb_width, fb_height, x, y, color);
            }
        } else if (fb_depth == 24) {
            memcpy((unsigned char *) fbmem + y * fb_width * 3,
                    buffer, cinfo.output_width * cinfo.output_components);
        } else if (fb_depth == 32) {
            // memcpy((unsigned char *) fbmem + y * fb_width * 4,
                    // buffer, cinfo.output_width * cinfo.output_components);
            for (x = 0; x &lt; cinfo.output_width; x++) {
                * (fbmem + y * fb_width * 4 + x * 4)     = (unsigned char)       buffer[x * 3 + 2];
                * (fbmem + y * fb_width * 4 + x * 4 + 1) = (unsigned char)       buffer[x * 3 + 1];
                * (fbmem + y * fb_width * 4 + x * 4 + 2) = (unsigned char)       buffer[x * 3 + 0];
                * (fbmem + y * fb_width * 4 + x * 4 + 3) = (unsigned char) 0;
            }
        }
        y++;    // next scanline
    }

    /* finish decompress, destroy decompress object */
    jpeg_finish_decompress(&amp;cinfo);
    jpeg_destroy_decompress(&amp;cinfo);

    /* release memory buffer */
    free(buffer);

#if (BYREAD)
    /* close jpeg inputing file */
    fclose(infile);
#endif

    /* unmap framebuffer's shared memory */
    fb_munmap(fbmem, screensize);

#if (BYMEM)
    munmap(fdmem, (size_t) st.st_size);
    close(fd);
#endif

    /* close framebuffer device */
    fb_close(fbdev);

    return 0;
}

void usage(char *msg)
{
    fprintf(stderr, "%s\n", msg);
    printf("Usage: fv some-jpeg-file.jpg\n");
}

/* open framebuffer device.
 * return positive file descriptor if success,
 * else return -1
 */
int fb_open(char *fb_device)
{
    int fd;

    if ((fd = open(fb_device, O_RDWR)) &lt; 0) {
        perror(__fnc__);
        return -1;
    }
    return fd;
}

int fb_close(int fd)
{
    return (close(fd));
}

/* get framebuffer's width, height, and depth.
 * return 0 if success, else return -1.
 */
int fb_stat(int fd, unsigned int *width, unsigned int *height, unsigned int *    depth)
{
    struct fb_fix_screeninfo fb_finfo;
    struct fb_var_screeninfo fb_vinfo;

    if (ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_finfo)) {
        perror(__fnc__);
        return -1;
    }

    if (ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_vinfo)) {
        perror(__fnc__);
        return -1;
    }

    *width = fb_vinfo.xres;
    *height = fb_vinfo.yres;
    *depth = fb_vinfo.bits_per_pixel;

    return 0;
}

/* map shared memory to framebuffer device.
 * return maped memory if success
 * else return -1, as mmap dose
 */
void *fb_mmap(int fd, unsigned int screensize)
{
    caddr_t fbmem;

    if ((fbmem = mmap(0, screensize, PROT_READ | PROT_WRITE,
                    MAP_SHARED, fd, 0)) == MAP_FAILED) {
        perror(__func__);
        return (void *) (-1);
    }

    return fbmem;
}

/* map shared memmory to a opened file */
void *fd_mmap(int fd, unsigned int filesize)
{
    caddr_t fdmem;

    if ((fdmem = mmap(0, filesize, PROT_READ,
                    MAP_SHARED, fd, 0)) == MAP_FAILED) {
        perror(__func__);
        return (void *) (-1);
    }

    return fdmem;
}

/* unmap map memory for framebuffer device */
int fb_munmap(void *start, size_t length)
{
    return (munmap(start, length));
}

/* convert 24bit RGB888 to 16bit RGB565 color format */
unsigned short RGB888toRGB565(unsigned char red,
        unsigned char green, unsigned char blue)
{
    unsigned short B = (blue &gt;&gt; 3) &amp; 0x001F;
    unsigned short G = ((green &gt;&gt; 2) &lt;&lt; 5) &amp; 0x07E0;
    unsigned short R = ((red &gt;&gt; 3) &lt;&lt; 11) &amp; 0xF800;

    return (unsigned short) (R | G | B);
}

/* display a pixel on the framebuffer device.
 * fbmem is the starting memory of framebuffer,
 * width and height are dimension of framebuffer,
 * width and height are dimension of framebuffer,
 * x and y are the coordinates to display,
 * color is the pixel's color value.
 * return 0 if success, otherwise return -1.
 */
int fb_pixel(void *fbmem, int width, int height,
        int x, int y, unsigned short color)
{
    if ((x &gt; width) || (y &gt; height))
        return -1;

    unsigned short *dst = ((unsigned short *) fbmem + y * width + x);

    *dst = color;
    return 0;
}</pre>
<h2 id="toc_1.3">3. LCD驱动</h2>
我们用到的是一块东华3.5寸数字屏,型号为WXCAT35-TG3.下面的驱动程序是韦东山老师课堂上现场写的,如下:
<pre>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/fb.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/ioport.h&gt;
#include &lt;linux/dma-mapping.h&gt;

#include &lt;asm/uaccess.h&gt;
#include &lt;asm/system.h&gt;
#include &lt;asm/irq.h&gt;
#include &lt;asm/setup.h&gt;

/* WXCAT35-TG3 */
struct s3c_lcd_regs {
	unsigned long	lcdcon1;
	unsigned long	lcdcon2;
	unsigned long	lcdcon3;
	unsigned long	lcdcon4;
	unsigned long	lcdcon5;
	unsigned long	lcdsaddr1;
	unsigned long	lcdsaddr2;
	unsigned long	lcdsaddr3;
	unsigned long	redlut;
	unsigned long	greenlut;
	unsigned long	bluelut;
	unsigned long	reserved[9];
	unsigned long	dithmode;
	unsigned long	tpal;
	unsigned long	lcdintpnd;
	unsigned long	lcdsrcpnd;
	unsigned long	lcdintmsk;
	unsigned long	lpcsel;
};

static u32 colregs[16];
static struct fb_info *s3c_fb_info;
static dma_addr_t s3c_fb_handle;
static unsigned long fb_va;

/* from pxafb.c */
static inline unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
{
	chan &amp;= 0xffff;
	chan &gt;&gt;= 16 - bf-&gt;length;
	return chan &lt;&lt; bf-&gt;offset;
}

static int s3cfb_setcolreg(unsigned regno,
			       unsigned red, unsigned green, unsigned blue,
			       unsigned transp, struct fb_info *info)
{
	unsigned int val;

	/* dprintk("setcol: regno=%d, rgb=%d,%d,%d\n", regno, red, green, blue); */

	/* true-colour, use pseuo-palette */

	if (regno &lt; 16) {
		u32 *pal = s3c_fb_info-&gt;pseudo_palette;

		val  = chan_to_field(red,   &amp;s3c_fb_info-&gt;var.red);
		val |= chan_to_field(green, &amp;s3c_fb_info-&gt;var.green);
		val |= chan_to_field(blue,  &amp;s3c_fb_info-&gt;var.blue);

		pal[regno] = val;
	}

	return 0;
}

static struct fb_ops s3cfb_ops = {
	.owner		= THIS_MODULE,
//	.fb_check_var	= clps7111fb_check_var,
//	.fb_set_par	= clps7111fb_set_par,
//	.fb_setcolreg	= clps7111fb_setcolreg,
//	.fb_blank	= clps7111fb_blank,

	.fb_setcolreg	= s3cfb_setcolreg,
	.fb_fillrect	= cfb_fillrect,
	.fb_copyarea	= cfb_copyarea,
	.fb_imageblit	= cfb_imageblit,
};

struct s3c_lcd_regs *s3c_lcd_regs;
static volatile unsigned long *gpccon;
static volatile unsigned long *gpdcon;
static volatile unsigned long *gpgcon;

int s3c_lcd_init(void)
{
	extern int debug_lcd;
	/* 1. 分配一个fb_info结构体 */
	s3c_fb_info = framebuffer_alloc(0, NULL);
    printk("%s %d\n", __FUNCTION__, __LINE__);

	/* 2. 设置fb_info结构体 */
	/*
	   2.1 设置固定的信息
	   2.2 设置可变的信息
	   2.3 设置操作函数
	*/

	/* 24BPP(bits per pixel), 会用到4字节, 其中浪费1字节 */
	strcpy(s3c_fb_info-&gt;fix.id, "WXCAT35-TG3");
	// s3c_fb_info-&gt;fix.smem_start // frame buffer's physical address
	s3c_fb_info-&gt;fix.smem_len    = 320*240*32/8;
	s3c_fb_info-&gt;fix.type        = FB_TYPE_PACKED_PIXELS;
	s3c_fb_info-&gt;fix.visual      = FB_VISUAL_TRUECOLOR;
	s3c_fb_info-&gt;fix.line_length = 320 * 4;

	s3c_fb_info-&gt;var.xres             = 320;
	s3c_fb_info-&gt;var.yres             = 240;
	s3c_fb_info-&gt;var.xres_virtual     = 320;
	s3c_fb_info-&gt;var.yres_virtual     = 240;
	s3c_fb_info-&gt;var.bits_per_pixel   = 32;

	s3c_fb_info-&gt;var.red.offset       = 16;
	s3c_fb_info-&gt;var.red.length       = 8;

	s3c_fb_info-&gt;var.green.offset     = 8;
	s3c_fb_info-&gt;var.green.length     = 8;

	s3c_fb_info-&gt;var.blue.offset      = 0;
	s3c_fb_info-&gt;var.blue.length      = 8;

	//s3c_fb_info-&gt;var.activate         = FB_ACTIVATE;

	s3c_fb_info-&gt;fbops                = &amp;s3cfb_ops;
	s3c_fb_info-&gt;pseudo_palette       = colregs;

	/* 3. 硬件相关的操作 */
    /* 配置GPIO */
    gpccon     = ioremap(0x56000020, 4);
    gpdcon     = ioremap(0x56000030, 4);
    gpgcon     = ioremap(0x56000060, 4);
    *gpccon = 0xaaaaaaaa;
    *gpdcon = 0xaaaaaaaa;
    *gpgcon |= (3&lt;&lt;8);  /* GPG4 use as lcd_pwren */
    printk("%s %d\n", __FUNCTION__, __LINE__);

	s3c_lcd_regs = ioremap(0X4D000000, sizeof(struct s3c_lcd_regs));

	/*
	 * VCLK = HCLK / [(CLKVAL+1)x2] = 100M/[(CLKVAL+1)x2] = 6.4
	 * CLKVAL = 6.8 = 7
	 * TFT LCD panel
	 * 24bpp
	 */
	s3c_lcd_regs-&gt;lcdcon1 = (7&lt;&lt;8)|(0&lt;&lt;7)|(3&lt;&lt;5)|(0x0d&lt;&lt;1)|(0&lt;&lt;0);
    printk("%s %d\n", __FUNCTION__, __LINE__);

	/* VBPD: 电子枪收到VSYNC信号后,"多长时间"才能跳回第1行
	 * VBPD=14,      LCD: tvb=15
	 * LINEVAL=239,  LCD: 有240行
	 * VFPD=11,      LCD: tvf=12  // 发出最后一行数据后,再过多长时间才发出VSYNC
	 * VSPW=2,       LCD: tvp=3   // VSYNC的宽度
	 */
	s3c_lcd_regs-&gt;lcdcon2 = (14&lt;&lt;24)|(239&lt;&lt;14)|(11&lt;&lt;6)|(2&lt;&lt;0);

	/* HBPD: 电子枪收到HSYNC信号后,"多长时间"才能跳回第1列
	 * HBPD=37,      LCD: thb=38
	 * HORVAL=319,   LCD: 有320行
	 * HFPD=19,      LCD: thf=20  // 发出最后一象素数据后,再过多长时间才发出HSYNC
	 * HSPW=29,      LCD: thp=30   // VSYNC的宽度
	 */
	s3c_lcd_regs-&gt;lcdcon3 = (37&lt;&lt;19)|(319&lt;&lt;8)|(19&lt;&lt;0);
	s3c_lcd_regs-&gt;lcdcon4 = 29;

	/* bit10:  在VCLK上升沿取数据 
	 * bit9 :  VSYNC低电平有效
	 * bit8 :  HSYNC低电平有效
	 * bit5 :  PWREN低电平有效
	 */	
	s3c_lcd_regs-&gt;lcdcon5 = (1&lt;&lt;10)|(1&lt;&lt;9)|(1&lt;&lt;8)|(1&lt;&lt;5)|(0&lt;&lt;3);

	/* 分配frame buffer */
	fb_va = (unsigned long)dma_alloc_writecombine(NULL, s3c_fb_info-&gt;fix.smem_len, &amp;s3c_fb_handle, GFP_KERNEL);

	printk("fb_va = 0x%x, pa = 0x%x\n", fb_va, s3c_fb_handle);
	s3c_fb_info-&gt;fix.smem_start = s3c_fb_handle;
	s3c_fb_info-&gt;screen_base    = fb_va;

	/* 把framebuffer的地址告诉LCD控制器 */
	s3c_lcd_regs-&gt;lcdsaddr1 = (s3c_fb_info-&gt;fix.smem_start &gt;&gt; 1);
	s3c_lcd_regs-&gt;lcdsaddr2 = ((s3c_fb_info-&gt;fix.smem_start+320*240*4) &gt;&gt; 1) &amp; 0x1fffff;
	s3c_lcd_regs-&gt;lcdsaddr3 = 320*4/2;

	/* 使能LCD */
    s3c_lcd_regs-&gt;lcdcon1 |= (1&lt;&lt;0);

	/* 4. register_framebuffer */
    printk("%s %d\n", __FUNCTION__, __LINE__);
	//debug_lcd = 1;
	register_framebuffer(s3c_fb_info);
    printk("%s %d\n", __FUNCTION__, __LINE__);

	return 0; 
}

void s3c_lcd_exit(void)
{
	unregister_framebuffer(s3c_fb_info);
	dma_free_writecombine(NULL, s3c_fb_info-&gt;fix.smem_len, fb_va, s3c_fb_handle);
	iounmap(s3c_lcd_regs);
    iounmap(gpccon);
    iounmap(gpdcon);
    iounmap(gpgcon);
	framebuffer_release(s3c_fb_info);
}

module_init(s3c_lcd_init);
module_exit(s3c_lcd_exit);

MODULE_LICENSE("GPL");</pre>
然后把它加入到内核,以静态加载的模式启动.

最后,可以把读取内存jpeg格式数据输出到LCD屏的这部分整合到mjpg-stream或servfox去,就实现了采集图像本地显示了.

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>190</wp:post_id>
		<wp:post_date>2011-10-18 07:20:31</wp:post_date>
		<wp:post_date_gmt>2011-10-18 07:20:31</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%b5%8c%e5%85%a5%e5%bc%8flinux%e5%9f%ba%e4%ba%8eframebuffer%e7%9a%84jpeg%e6%a0%bc%e5%bc%8f%e6%9c%ac%e5%9c%b0lcd%e5%b1%8f%e6%98%be%e7%a4%ba</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%9c%aa%e5%88%86%e7%b1%bb"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>看了这样的makefile</title>
		<link>http://hmgle.com/archives/195</link>
		<pubDate>Sun, 11 Dec 2011 04:23:18 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=195</guid>
		<description></description>
		<content:encoded><![CDATA[</head>
<body>

<p>
GNU make是个非常好的工具. 大部分Linux程序员都自己编写Makefile, 再利用make构建工程. 优秀的程序员编写层次分明的代码, 将它们放在合适的位置, 优雅地用make生成目标文件以及管理工程. 不过, 再好的工具和材料, 到了笨拙建造师手里, 也有可能造出丑陋的建筑. 我就看了这样一个例子.
</p>

<p>
这个工程共有 3 层目录: 顶层有一个makefile. 要编译某个平台的目标文件首先要进入这个以这个平台名字命名的子目录, 比如 "Linux-x86-xx". 子目录"Linux-x86-xx"内也有个makefile, 打开一看, 部分语句是这样的:
</p>
<pre>
# makefile
compilevos: generateconfigfiles
		$(MAKE) -f ../../makefile xos.o
generateconfigfiles: runtailor
runtailor:
	...
</pre>
<p>
发现上两层目录已经不属于这个工程了. 又看了下readme才知道要编译目标得先运行这个"Linux-x86-xx"目录里面的一个脚本"makelib", 部分语句是这样的:
</p>
<pre>
# makelib
cd obj
make -f ../makefile compilelibs
cd ..
</pre>
<p>
先进入"obj"这个子目录, 这样"makefile" 里面的"$(MAKE) -f ../../makefile xos.o" 其实是调用上层目录的makefile了. 看得我都吐血了. 往下看发现依然现象严重, 写这个makefile的哥儿们竟全用名字诸如"makeobj", "makexox", "maketarget"等脚本调用make的, 关键是在脚本里每次调用之前都先cd到另外一个目录里, 在makefile根本不知道这条命令是在哪个目录里执行的. "goto"都不能比肩.
</p>

<p>
这么好的make就这样给糟蹋了.
</p>

</body>
</html>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>195</wp:post_id>
		<wp:post_date>2011-12-11 04:23:18</wp:post_date>
		<wp:post_date_gmt>2011-12-11 04:23:18</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%9c%8b%e4%ba%86%e8%bf%99%e6%a0%b7%e7%9a%84makefile</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%a2%8e%e8%af%ad"><![CDATA[碎语]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>一次面试</title>
		<link>http://hmgle.com/archives/204</link>
		<pubDate>Mon, 26 Dec 2011 15:19:52 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=204</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;

上周六(12.24)去X公司面试, 打了趟酱油. 收获还是有的.

上午十点来到X公司. 先是笔试: 题目类型是Linux C++的, 120分钟. 题目还记得些.

前面几题是问答题: 1.Linux下malloc函数的实现. 只依稀记得 K&amp;R 里大概提了下. 2. errno的作用及实现. 实现我还真不知道怎么答. 3. sync命令的作用. 简单的说: 同步缓冲区数据到设备. 4. 好象是问TCP连接中如何确定send的数据被接收方全部接受完. 不知道是不是通过接收方对数据包进行对齐检校后再回应发送方而实现的. TCP是可靠连接嘛. 5. Linux中线程和进程的异同. 这个问题每一本讲Linux编程的书应该都有详细解释. 然后是几道编程题: 前面3题都是简单的字符串操作之类的, 没什么好说的. 看到第4题的时候觉得有点意思了:
<pre>  某公园门票5角, 有5个游客手里有且仅有一张5角纸币,
  另外5个游客手里有且仅有一张1元纸币. 售票员手中
  没有任何纸币. 设计一个程序演示这10个游客可使售票员
  能顺利找零的所有排队方法.
  例如 "5 5 5 5 5 10 10 10 10 10" 这种方法就能顺利找零.</pre>
这题看起来眼熟了(后来回来才回忆起在Richard.A.Brualdi的那本组合数学里看的, 著名的Catalan数呀). 当时老是想去带吸收壁的随机行走问题去了, 其实就是同样问题的不同阐述而已, 不同阐述的Catalan问题还多着呢: 元素的进栈出栈具体有哪些方式, 列举n对括号的所有合法方式, 将凸多边形划分成三角形区域的方法等等, 举不胜举.
题目说演示, 那就把所有的可接受序列打印出来吧. 我想着想着就想到用递归实现, 不过当时根本没有划分清楚不同的状态: 比如售票员手中有几张5角的票, 还有几个五毛游客在排队等等. 因此没写明白. 回去捋了下, 果然用递归实现是很易理解的, 而且容易扩展: 比如<del>再加几种类型的纸币也可以很容易修改程序使之继续可用</del>(钱币类型多的话不是想象中的那么容易的). 不过缺点就是递归效率太低. 因为字符串 "10" 太长了, 所以就用 "T" 表示手持1元的游客购票, 用 "F" 表示持有5角的游客购票. 把 "F" 替换成 "(", 把 "T" 替换成 ")" 就是列出所有合法的括号配对方法了. 代码如下:
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

static unsigned int COUNT = 0;

void sale_ticket(int num_of_push_fiftycents, int sum_of_fiftycents_instack, char *pstr, const int max_push)
{
    /*
     * 若钱箱内五角钱币为空， 且还有持有五角的游客排队时，则下次
     * 只能接受五角游客购票。
     */
    if (sum_of_fiftycents_instack == 0 &amp;&amp; num_of_push_fiftycents &lt; max_push) {
        strcat(pstr, "F");      /* 把F加到字符串尾部表示有五角进了售票员的钱箱 */
        sale_ticket(num_of_push_fiftycents + 1, 1, pstr, max_push);
    }

    /*
     * 若钱箱内五角钱币非空， 且还有持有五角的游客排队时， 则下次
     * 可以接受两种游客的购票要求。
     */
    if (sum_of_fiftycents_instack &gt; 0 &amp;&amp; num_of_push_fiftycents &lt; max_push) {
        /* 情况1：下一个游客是1元党 */
        char *new_pstr;
        if ((new_pstr = malloc(2 * max_push + 1)) == NULL) {
            perror("sale_ticket: malloc");
            exit(1);
        }
        strcpy(new_pstr, pstr);
        strcat(new_pstr, "T");  /* 把T加到字符串尾部表示有五角出了钱箱， 即找零 */

        COUNT++;            /* 又多了一种可接受的排队方案 */
        sale_ticket(num_of_push_fiftycents, sum_of_fiftycents_instack - 1, new_pstr, max_push);

        /* 情况2：下一个购票的是五毛 */
        strcat(pstr, "F");
        sale_ticket(num_of_push_fiftycents + 1, sum_of_fiftycents_instack + 1, pstr, max_push);
    }

    /*
     * 当只剩下一元党在排队购票时，下一个购票的必然是一元的了
     */
    if (sum_of_fiftycents_instack &gt; 0 &amp;&amp; num_of_push_fiftycents == max_push) {
        strcat(pstr, "T");
        sale_ticket(num_of_push_fiftycents, sum_of_fiftycents_instack - 1, pstr, max_push);
    }

    /*
     * 当五毛入钱箱次数等于持有五毛游客的数量，
     * 且钱箱内五角钱币为空时， 表明到达了边界，
     * 则输出之前记录的买票顺序字符串. 并释放
     * 内存, 返回.
     */
    if (num_of_push_fiftycents == max_push &amp;&amp; sum_of_fiftycents_instack == 0) {
        printf("%s\n", pstr);
        free(pstr);
        return;
    }
}

int main(int argc, char **argv)
{
    char *prt;
    int max_push;   /* 五毛游客数, 即五毛进钱箱的最大次数 */

    if (argc &lt; 2) {
        fprintf(stderr, "usage: %s num\n", argv[0]);
        exit(0);
    }
    max_push = atoi(argv[1]);
    if (max_push &gt; 0)
        COUNT++;
    if ((prt = malloc(2 * max_push + 1)) == NULL) {
        perror("main: malloc");
        exit(1);
    }
    memset(prt, 0, 2 * max_push + 1);

    sale_ticket(0, 0, prt, max_push);
    printf("The total number is: %d\n", COUNT);
    return 0;
}</pre>
输入程序名后加数字即运行. 设置的数字不要超过16, 根据卡特兰数的一般项公式: Cn = (2*n)!/((n+1)! n!) . 第16项为35357670, 把所有可接受的排队顺序字符串输出需要1.1G的空间! 在我机器上大概10秒才运行完. 输入5的情况见这里:<a href="http://codepad.org/VKu9Bbb8">http://codepad.org/VKu9Bbb8</a>

最后一题问的是如何排查一个程序的瓶颈. 很惭愧我不知道.

下午项目面试: 走进X公司的内部, 里面环境出乎我意料: 像个饭馆, 看上去挺惬意的, 不过里面没有人逗留. 最后面试官问了如何用多路复用改进我目前接触的项目(面试官技术不错, 听我稍微介绍完项目后就看出用定时轮询的方式耗资源).只要和网络开发有关的一般都会问到多路复用: select和poll机制. 这次果然也是. 结果没答明白. 拿了盒冬瓜茶就被叫回去了.

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>204</wp:post_id>
		<wp:post_date>2011-12-26 15:19:52</wp:post_date>
		<wp:post_date_gmt>2011-12-26 15:19:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%80%e6%ac%a1%e9%9d%a2%e8%af%95</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>47</wp:comment_id>
			<wp:comment_author><![CDATA[51anygo]]></wp:comment_author>
			<wp:comment_author_email>51anygo@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>27.38.33.183</wp:comment_author_IP>
			<wp:comment_date>2012-02-05 14:27:26</wp:comment_date>
			<wp:comment_date_gmt>2012-02-05 14:27:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[是xunlei吧，我也只拿了瓶茶，楼主水平比我高，xunlei没眼光，期待跟你交个朋友！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>48</wp:comment_id>
			<wp:comment_author><![CDATA[hmgle]]></wp:comment_author>
			<wp:comment_author_email>dustgle@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>115.174.87.209</wp:comment_author_IP>
			<wp:comment_date>2012-02-05 15:54:01</wp:comment_date>
			<wp:comment_date_gmt>2012-02-05 15:54:01</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[是啊. 我自己还是比较菜的.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>47</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>递归中的改进</title>
		<link>http://hmgle.com/archives/210</link>
		<pubDate>Thu, 12 Jan 2012 04:57:30 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=210</guid>
		<description></description>
		<content:encoded><![CDATA[在<a href="http://hmgle.com/archives/204">上一篇</a>(<a href="http://hmgle.com/archives/204">一次面试</a>)中, 我用递归实现了输出所有可接受序列的排队方法. 后来, 我意识到, 在递归中, 频繁地申请内存来存储新增加的可接受序列的字符串, 再释放掉这片存储区域的方法是不必要的. 因为在递归中每调用一次新的递归后, 这时的可接受序列的字符串前面部分是一样的, 可以每次调用递归函数都用这块存储区域. 这时我们就不能用strcat()函数来加入新的字符了, 而是要先计算出目前要修改的字符的位置(pstr + (num_of_push_fiftycents * 2 - sum_of_fiftycents_inbox)), 然后直接在这个位置上修改要加入的字符. 改进后的代码如下:
[php lang_name="C"]

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#define USEMALLOC   0

static unsigned int COUNT = 0;

static void
sale_ticket(int num_of_push_fiftycents, int sum_of_fiftycents_inbox, char *pstr, const int num_of_fiftycents)
{
	/*
	 * 若钱箱内五角钱币为空, 且还有五毛游客排队时, 
	 * 则下次只能接受五毛游客购票
	 */
	if (sum_of_fiftycents_inbox == 0 && num_of_push_fiftycents < num_of_fiftycents) {
#if USEMALLOC
		strcat(pstr, "F");	/* 把"F"加到字符串尾部表示有五角进了售票员的钱箱 */
#else
        *(pstr + (num_of_push_fiftycents * 2 - sum_of_fiftycents_inbox)) = 'F';
#endif
		sale_ticket(num_of_push_fiftycents + 1, 1, pstr, num_of_fiftycents);
	}

	/*
	 * 若钱箱内五毛钱币非空, 且还有五毛游客排队,
	 * 则下次可以接受两种游客的购票请求
	 */
    if (sum_of_fiftycents_inbox > 0 && num_of_push_fiftycents < num_of_fiftycents) {
		/* 情况1: 下一张票卖给1元游客 */
#if USEMALLOC
		strcat(pstr, "T");	/* 把"T"加到字符串尾部表示有1元进了售票员的钱箱 */
#else
        *(pstr + (num_of_push_fiftycents * 2 - sum_of_fiftycents_inbox)) = 'T';
#endif
		sale_ticket(num_of_push_fiftycents, sum_of_fiftycents_inbox - 1, pstr, num_of_fiftycents);

		/* 情况2: 下一张票卖给五毛游客 */
#if USEMALLOC
		strcat(pstr, "F");
#else
        *(pstr + (num_of_push_fiftycents * 2 - sum_of_fiftycents_inbox)) = 'F';
#endif
		sale_ticket(num_of_push_fiftycents + 1, sum_of_fiftycents_inbox + 1, pstr, num_of_fiftycents);
	}

    /* 
     * 排队的只剩下手持一元的游客,
     * 下一张票只能卖给这类游客了
     */
    if (sum_of_fiftycents_inbox > 0 && num_of_push_fiftycents == num_of_fiftycents) {
#if USEMALLOC
        strcat(pstr, "T");
#else
        *(pstr + (num_of_push_fiftycents * 2 - sum_of_fiftycents_inbox)) = 'T';
#endif
        sale_ticket(num_of_push_fiftycents, sum_of_fiftycents_inbox - 1, pstr, num_of_fiftycents);
    }

    /*
	 * 当所有游客都买到票了,
	 * 则输出之前记录的买票顺序字符串
	 */
	if (sum_of_fiftycents_inbox == 0 && num_of_push_fiftycents >= num_of_fiftycents) {
		COUNT++;
		printf("%s\n", pstr);
		return;
	}
}

int
main(int argc, char **argv)
{
    char *prt;
    int max_push;   /* 五毛游客数, 即五毛进钱箱的最大次数 */

    if (argc < 2) {
        fprintf(stderr, "usage: %s num\n", argv[0]);
        exit(0);
    }
    max_push = atoi(argv[1]);
#if 0
    if (max_push <= 0) {
        fprintf(stderr, "usage: %s num\n", argv[0]);
        exit(0);
    }
#endif
    if ((prt = malloc(2 * max_push + 1)) == NULL) {
        perror("main: malloc");
        exit(1);
    }
    memset(prt, 0, 2 * max_push + 1);

    sale_ticket(0, 0, prt, max_push);
    printf("The total number is: %d\n", COUNT);
	free(prt);

    return 0;
}
[/php]

不过, 频繁的申请, 释放内存并不是这个程序的瓶颈. 修改后的程序运行时间基本是和原来一样的. 原因之一是每一次调用malloc申请到的其实是同一片区域, 没有调用到sbrk()申请过一片大的存储区域. 另一个原因是递归实在是效率低下, 没有留给别的东西当瓶颈的机会.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>210</wp:post_id>
		<wp:post_date>2012-01-12 04:57:30</wp:post_date>
		<wp:post_date_gmt>2012-01-12 04:57:30</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e9%80%92%e5%bd%92%e4%b8%ad%e7%9a%84%e6%94%b9%e8%bf%9b</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ARM平台下位域结构体的问题</title>
		<link>http://hmgle.com/archives/304</link>
		<pubDate>Sat, 17 Mar 2012 15:25:22 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=304</guid>
		<description></description>
		<content:encoded><![CDATA[最近在做个IP camera, 开发板是Hi3511的. 在写h.264码流封装成rtp包进行网络传输时, 出问题了: 在客户端用vlc看不到期待的画面. 用wireshark抓包, 把源源不断的rtp包拆包一看, 竟然没有fu-a包, 全是单个的nal包. 而输入的nalu基本都是大于最大传输单元MTU的, 需要分解成fu-a包的形式. 通过测试发现, 问题出现在设置fu分片包的indicator和header上. 再往下分析, 得到在ARM平台下令人惊奇的现象. 假如我们有下面代码:

[php lang_name="C"]
#include &lt;stdint.h&gt;

typedef struct fu_indicator {
    uint8_t type: 5;
    uint8_t nri: 2;
    uint8_t f: 1;
} fu_indicator_t;

int main(int argc, char **argv)
{
    uint8_t n = 7;
    fu_indicator_t *pstf;

    pstf = (fu_indicator_t *) &amp;n;
    pstf-&gt;type = 0x0f;
    printf("now n is %d\n", n);
    return 0;
}
[/php]
以上代码在x86平台上运行结果正如预想的一样, 但在arm平台下就不一样了, 结果竟然是n变成0了. 看汇编内容:
[php lang_name="C"]
main:
@ args = 0, pretend = 0, frame = 12
@ frame_needed = 1, uses_anonymous_args = 0
mov ip, sp
stmfd sp!, {fp, ip, lr, pc}
sub fp, ip, #4
sub sp, sp, #12
mov r3, #7
strb r3, [fp, #-13]     @ 在内存单元[fp, #-13]地址上保存n=7
sub r3, fp, #13         @ r3放n的地址
str r3, [fp, #-20]      @ 将n的地址保存在内存单元[fp, #-20]上, 即pstf的地址
ldr r2, [fp, #-20]      @ 将n的地址加载到r2上
ldr r1, [r2, #0]        @ 将[r2, #0]的内容即n = 7加载到r1上
str r1, [fp, #-24]      @ 将r1即n = 7保存在[fp, #-24]上
ldr r1, [fp, #-24]      @ 加载地址[fp, #-24]的内容即n = 7到r1
bic r3, r1, #16         @ 将n &amp; ~0x10 = 7 放在r3
orr r3, r3, #15         @ 将7 | 15 = 15 放在r3
str r3, [fp, #-24]      @ 将结果r3 = 15 保存在内存单元[fp, #-24]
ldr r3, [fp, #-24]      @ 加载[fp, #-24] = 15 到r3
str r3, [r2, #0]        @ 保存r3 = 15 到 n的地址[r2, #0]上, 之后n应该=15
ldrb r3, [fp, #-13]     @ zero_extendqisi2
mov r0, r3
sub sp, fp, #12
ldmfd sp, {fp, sp, pc}
.size main, .-main
.ident "GCC: (GNU) 3.4.3 (release) (CodeSourcery ARM Q3cvs 2004)"
[/php]
汇编代码文件看起来没有问题, 但问题是程序跑出来的结果n是不等于15的. 这说明出现问题的阶段是发生在编译阶段之后的, 也许是汇编阶段, 也许是链接阶段. 据老夫多年行医经验来看, 汇编阶段不过是将汇编指令的机器码查找出翻译成机器码就可以了, 像查英汉字典一样有固定解释, 很少有出错的可能, 基本可诊断为问题出现在链接阶段, 而像地址分配, 内存对齐,重定位等都在这一阶段完成.
接下来用sizeof(fu_indicator_t)一看, 在ARM平台上竟然是4, 不是x86平台下的1了. 我试着改这个结构体里面各个位域的不同值发现, 各个位域的位置是随机的呀! 连顺序都会改变呢! 就是说这个结构体的位域的位置连顺序也不保证. 你见过一个结构体的比特序都会变化的吗? 当fu_indicator结构体里面的type位于后三个字节的时候当然就不是我预想的结果了.

解决办法: 强制这个结构体按最紧凑的方式对齐, 可以在声明fu_indicator结构体后加入"__attribute__ ((packed))" 或在Makefile里的加编译选项"-fpack-struct", 这样fu_indicator结构体的长度就为1字节了, 比特顺序也能得到保证. 或按最保险的方法: 放弃用位域这种结构, 而直接用按位操作来代替.

总结: 位域这种结构移植性是非常差的. C语言参考手册说了: 依赖于存储策略是危险的, 原因有几个. 1, 不同的计算机对数据类型的对齐限制不同. 2, 位字段宽度的限制不同. 3, 字节序不同. 甚至比特序也不同, 像上面的例子在arm平台就在同一个结构体上出现了截然相反的比特序. 如处于移植性考虑, 尽量不要用位域这种结构体来实现设置位的操作, 而是直接用按位操作.

另: 从这个<a title="ARM平台上编译器的地址对齐/指针优化问题" href="http://www.linuxforum.net/forum/printthread.php?Cat=&amp;Board=embedded&amp;main=535759&amp;type=thread">帖子</a>来看, 这个问题还和GCC的版本有关.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>304</wp:post_id>
		<wp:post_date>2012-03-17 15:25:22</wp:post_date>
		<wp:post_date_gmt>2012-03-17 15:25:22</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>arm%e5%b9%b3%e5%8f%b0%e4%b8%8b%e4%bd%8d%e5%9f%9f%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e9%97%ae%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%8b%be%e9%9b%b6"><![CDATA[拾零]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>手机号码patch</title>
		<link>http://hmgle.com/archives/313</link>
		<pubDate>Mon, 30 Apr 2012 16:50:10 +0000</pubDate>
		<dc:creator>hmgle</dc:creator>
		<guid isPermaLink="false">http://hmgle.com/?p=313</guid>
		<description></description>
		<content:encoded><![CDATA[昨天更换手机号码了. 原号码不再使用.
<h3 id="toc_0.1">如何获取我的新号码</h2>

<ul>
	<li><a name="a1">1. 如果存有我原来的号码: 以原号码为参数运行下面的脚本</a>
[php lang_name="shell"]
#!/bin/sh
if [ "$#" -ne 1 ] ; then
    echo "Usage: $0 my_old_num";
    exit 1;
fi
echo `expr $1 + \`echo -n MjI2MDgyMDIxNgo= | base64 -d\``
[/php]
</li>
</ul>

<ul>
	<li>2. 如果没有我原来的号码: 在页面<a href="http_//hmgle.com/archives/21.html">手机号码更换</a>获取我以前的号码, 然后跳转到<a href="#a1">1</a>.</li>
</ul>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>313</wp:post_id>
		<wp:post_date>2012-05-01 00:50:10</wp:post_date>
		<wp:post_date_gmt>2012-04-30 16:50:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%89%8b%e6%9c%ba%e5%8f%b7%e7%a0%81patch</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%b0%98%e5%b0%81"><![CDATA[尘封]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
